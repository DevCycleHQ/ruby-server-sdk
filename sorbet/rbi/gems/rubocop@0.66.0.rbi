# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop` gem.
# Please instead update this file by running `bin/tapioca gem rubocop`.

# source://rubocop//lib/rubocop/version.rb#3
module RuboCop; end

# source://rubocop//lib/rubocop/ast/sexp.rb#4
module RuboCop::AST; end

# A node extension for `until` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `until` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/and_node.rb#8
class RuboCop::AST::AndNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode

  # Returns the alternate operator of the `and` as a string.
  # Returns `and` for `&&` and vice versa.
  #
  # @return [String] the alternate of the `and` operator
  #
  # source://rubocop//lib/rubocop/ast/node/and_node.rb#16
  def alternate_operator; end

  # Returns the inverse keyword of the `and` node as a string.
  # Returns `||` for `&&` and `or` for `and`.
  #
  # @return [String] the inverse of the `and` operator
  #
  # source://rubocop//lib/rubocop/ast/node/and_node.rb#24
  def inverse_operator; end
end

# A node extension for `args` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `args` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/args_node.rb#8
class RuboCop::AST::ArgsNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::CollectionNode

  # It returns true if arguments are empty and delimiters do not exist.
  # @example:
  #   # true
  #   def x; end
  #   x { }
  #   -> {}
  #
  #   # false
  #   def x(); end
  #   def x a; end
  #   x { || }
  #   -> () {}
  #   -> a {}
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node/args_node.rb#24
  def empty_and_without_delimiters?; end
end

# A node extension for `array` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `array` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/array_node.rb#8
class RuboCop::AST::ArrayNode < ::RuboCop::AST::Node
  # Checks whether the `array` literal is delimited by either percent or
  # square brackets
  #
  # brackets
  #
  # @return [Boolean] whether the array is enclosed in percent or square
  #
  # source://rubocop//lib/rubocop/ast/node/array_node.rb#52
  def bracketed?; end

  # Checks whether the `array` literal is delimited by percent brackets.
  #
  # @overload percent_literal?
  # @overload percent_literal?
  # @return [Boolean] whether the array is enclosed in percent brackets
  #
  # source://rubocop//lib/rubocop/ast/node/array_node.rb#39
  def percent_literal?(type = T.unsafe(nil)); end

  # Checks whether the `array` literal is delimited by square brackets.
  #
  # @return [Boolean] whether the array is enclosed in square brackets
  #
  # source://rubocop//lib/rubocop/ast/node/array_node.rb#24
  def square_brackets?; end

  # Returns an array of all value nodes in the `array` literal.
  #
  # @return [Array<Node>] an array of value nodes
  #
  # source://rubocop//lib/rubocop/ast/node/array_node.rb#17
  def values; end
end

# source://rubocop//lib/rubocop/ast/node/array_node.rb#9
RuboCop::AST::ArrayNode::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Hash)

# Common functionality for primitive literal nodes: `sym`, `str`,
# `int`, `float`, ...
#
# source://rubocop//lib/rubocop/ast/node/mixin/basic_literal_node.rb#7
module RuboCop::AST::BasicLiteralNode
  # Returns the value of the literal.
  #
  # @return [mixed] the value of the literal
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/basic_literal_node.rb#11
  def value; end
end

# Common functionality for nodes that are binary operations:
# `or`, `and` ...
#
# source://rubocop//lib/rubocop/ast/node/mixin/binary_operator_node.rb#7
module RuboCop::AST::BinaryOperatorNode
  # Returns all of the conditions, including nested conditions,
  # of the binary operation.
  #
  # operation and the let and right hand side of any nested binary
  # operators
  #
  # @return [Array<Node>] the left and right hand side of the binary
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/binary_operator_node.rb#28
  def conditions; end

  # Returns the left hand side node of the binary operation.
  #
  # @return [Node] the left hand side of the binary operation
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/binary_operator_node.rb#11
  def lhs; end

  # Returns the right hand side node of the binary operation.
  #
  # @return [Node] the right hand side of the binary operation
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/binary_operator_node.rb#18
  def rhs; end
end

# A node extension for `block` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `send` nodes within RuboCop.
#
# A `block` node is essentially a method send with a block. Parser nests
# the `send` node inside the `block` node.
#
# source://rubocop//lib/rubocop/ast/node/block_node.rb#11
class RuboCop::AST::BlockNode < ::RuboCop::AST::Node
  # The arguments of this block.
  #
  # @return [Array<Node>]
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#24
  def arguments; end

  # Checks whether this block takes any arguments.
  #
  # @return [Boolean] whether this `block` node takes any arguments
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#45
  def arguments?; end

  # The body of this block.
  #
  # @return [Node, nil] the body of the `block` node or `nil`
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#31
  def body; end

  # Checks whether the `block` literal is delimited by curly braces.
  #
  # @return [Boolean] whether the `block` literal is enclosed in braces
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#52
  def braces?; end

  # The closing delimiter for this `block` literal.
  #
  # @return [String] the closing delimiter for the `block` literal
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#80
  def closing_delimiter; end

  # The delimiters for this `block` literal.
  #
  # @return [Array<String>] the delimiters for the `block` literal
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#66
  def delimiters; end

  # Checks whether the `block` literal is delimited by `do`-`end` keywords.
  #
  # @return [Boolean] whether the `block` literal is enclosed in `do`-`end`
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#59
  def keywords?; end

  # Checks whether this `block` literal belongs to a lambda.
  #
  # @return [Boolean] whether the `block` literal belongs to a lambda
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#103
  def lambda?; end

  # The name of the dispatched method as a symbol.
  #
  # @return [Symbol] the name of the dispatched method
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#38
  def method_name; end

  # Checks whether this is a multiline block. This is overridden here
  # because the general version in `Node` does not work for `block` nodes.
  #
  # @return [Boolean] whether the `block` literal is on a several lines
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#96
  def multiline?; end

  # The opening delimiter for this `block` literal.
  #
  # @return [String] the opening delimiter for the `block` literal
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#73
  def opening_delimiter; end

  # The `send` node associated with this block.
  #
  # @return [SendNode] the `send` node associated with the `block` node
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#17
  def send_node; end

  # Checks whether this is a single line block. This is overridden here
  # because the general version in `Node` does not work for `block` nodes.
  #
  # @return [Boolean] whether the `block` literal is on a single line
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#88
  def single_line?; end

  # Checks whether this node body is a void context.
  #
  # @return [Boolean] whether the `block` node body is a void context
  #
  # source://rubocop//lib/rubocop/ast/node/block_node.rb#110
  def void_context?; end
end

# source://rubocop//lib/rubocop/ast/node/block_node.rb#12
RuboCop::AST::BlockNode::VOID_CONTEXT_METHODS = T.let(T.unsafe(nil), Array)

# A node extension for `break` nodes. This will be used in place of a
# plain node when the builder constructs the AST, making its methods
# available to all `break` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/break_node.rb#8
class RuboCop::AST::BreakNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::ParameterizedNode

  # source://rubocop//lib/rubocop/ast/node/break_node.rb#12
  def arguments; end
end

# `RuboCop::AST::Builder` is an AST builder that is utilized to let `Parser`
# generate ASTs with {RuboCop::AST::Node}.
#
# @example
#   buffer = Parser::Source::Buffer.new('(string)')
#   buffer.source = 'puts :foo'
#
#   builder = RuboCop::AST::Builder.new
#   require 'parser/ruby25'
#   parser = Parser::Ruby25.new(builder)
#   root_node = parser.parse(buffer)
#
# source://rubocop//lib/rubocop/ast/builder.rb#16
class RuboCop::AST::Builder < ::Parser::Builders::Default
  # Generates {Node} from the given information.
  #
  # @return [Node] the generated node
  #
  # source://rubocop//lib/rubocop/ast/builder.rb#58
  def n(type, children, source_map); end

  # TODO: Figure out what to do about literal encoding handling...
  # More details here https://github.com/whitequark/parser/issues/283
  #
  # source://rubocop//lib/rubocop/ast/builder.rb#64
  def string_value(token); end

  private

  # source://rubocop//lib/rubocop/ast/builder.rb#70
  def node_klass(type); end
end

# source://rubocop//lib/rubocop/ast/builder.rb#17
RuboCop::AST::Builder::NODE_MAP = T.let(T.unsafe(nil), Hash)

# A node extension for `case` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `case` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/case_node.rb#8
class RuboCop::AST::CaseNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode

  # Calls the given block for each `when` node in the `case` statement.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/case_node.rb#23
  def each_when; end

  # Checks whether this case statement has an `else` branch.
  #
  # @return [Boolean] whether the `case` statement has an `else` branch
  #
  # source://rubocop//lib/rubocop/ast/node/case_node.rb#51
  def else?; end

  # Returns the else branch of the `case` statement, if any.
  #
  # @return [Node] the else branch node of the `case` statement
  # @return [nil] if the case statement does not have an else branch.
  #
  # source://rubocop//lib/rubocop/ast/node/case_node.rb#44
  def else_branch; end

  # Returns the keyword of the `case` statement as a string.
  #
  # @return [String] the keyword of the `case` statement
  #
  # source://rubocop//lib/rubocop/ast/node/case_node.rb#14
  def keyword; end

  # Returns an array of all the when branches in the `case` statement.
  #
  # @return [Array<WhenNode>] an array of `when` nodes
  #
  # source://rubocop//lib/rubocop/ast/node/case_node.rb#36
  def when_branches; end
end

# A mixin that helps give collection nodes array polymorphism.
#
# source://rubocop//lib/rubocop/ast/node/mixin/collection_node.rb#6
module RuboCop::AST::CollectionNode
  extend ::Forwardable

  # source://forwardable/1.3.3/forwardable.rb#231
  def &(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def *(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def +(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def -(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def all?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def any?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def append(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def assoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bsearch(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bsearch_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def chain(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def chunk(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def chunk_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def collect(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def collect!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def collect_concat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def combination(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def compact(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def compact!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def concat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def count(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cycle(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deconstruct(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def delete(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def delete_at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def delete_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def detect(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def difference(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def dig(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def drop(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def drop_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_cons(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_entry(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_with_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_with_object(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def entries(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fetch(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fill(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def filter(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def filter!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def filter_map(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def find(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def find_all(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def find_index(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def first(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def flat_map(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def flatten(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def flatten!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def grep(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def grep_v(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def group_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def include?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def index(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def inject(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def insert(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def intersect?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def intersection(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def join(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def keep_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def last(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def lazy(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def map(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def map!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def max(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def max_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def member?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def min(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def min_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def minmax(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def minmax_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def none?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def one?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pack(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def partition(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def permutation(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def place(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pop(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def prepend(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def product(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def push(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def rassoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reduce(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reject(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reject!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def repeated_combination(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def repeated_permutation(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def replace(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reverse(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reverse!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reverse_each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def rindex(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def rotate(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def rotate!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sample(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def select(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def select!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shelljoin(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shift(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shuffle(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shuffle!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def size(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slice!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slice_after(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slice_before(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slice_when(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sort(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sort!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sort_by(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sort_by!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sum(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def take(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def take_while(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def tally(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_ary(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_h(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_set(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def transpose(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def union(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uniq(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uniq!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def unshift(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def values_at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def zip(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def |(*args, **_arg1, &block); end
end

# source://rubocop//lib/rubocop/ast/node/mixin/collection_node.rb#9
RuboCop::AST::CollectionNode::ARRAY_METHODS = T.let(T.unsafe(nil), Array)

# Common functionality for nodes that have conditions:
# `if`, `while`, `until`, `case`.
# This currently doesn't include `when` nodes, because they have multiple
# conditions, and need to be checked for that.
#
# source://rubocop//lib/rubocop/ast/node/mixin/conditional_node.rb#9
module RuboCop::AST::ConditionalNode
  # Returns the body associated with the condition. This works together with
  # each node's custom destructuring method to select the correct part of
  # the node.
  #
  # @note For `if` nodes, this is the truthy branch.
  # @return [Node, nil] the body of the node
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/conditional_node.rb#40
  def body; end

  # Returns the condition of the node. This works together with each node's
  # custom destructuring method to select the correct part of the node.
  #
  # @return [Node, nil] the condition of the node
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/conditional_node.rb#29
  def condition; end

  # Checks whether the condition of the node is written on more than
  # one line.
  #
  # @return [Boolean] whether the condition is on more than one line
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/conditional_node.rb#21
  def multiline_condition?; end

  # Checks whether the condition of the node is written on a single line.
  #
  # @return [Boolean] whether the condition is on a single line
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/conditional_node.rb#13
  def single_line_condition?; end
end

# A node extension for `def` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `def` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/def_node.rb#8
class RuboCop::AST::DefNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates

  # An array containing the arguments of the method definition.
  #
  # @return [Array<Node>] the arguments of the method definition
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#29
  def arguments; end

  # The body of the method definition.
  #
  # @note this can be either a `begin` node, if the method body contains
  #   multiple expressions, or any other node, if it contains a single
  #   expression.
  # @return [Node] the body of the method definition
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#40
  def body; end

  # The name of the defined method as a symbol.
  #
  # @return [Symbol] the name of the defined method
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#22
  def method_name; end

  # Custom destructuring method. This can be used to normalize
  # destructuring for different variations of the node.
  #
  # In this case, the `def` node destructures into:
  #
  #   `method_name, arguments, body`
  #
  # while the `defs` node destructures into:
  #
  #   `receiver, method_name, arguments, body`
  #
  # so we reverse the destructured array to get the optional receiver
  # at the end, where it can be discarded.
  #
  # @return [Array] the different parts of the `def` or `defs` node
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#66
  def node_parts; end

  # The receiver of the method definition, if any.
  #
  # @return [Node, nil] the receiver of the method definition, or `nil`.
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#47
  def receiver; end

  # Checks whether this node body is a void context.
  #
  # @return [Boolean] whether the `def` node body is a void context
  #
  # source://rubocop//lib/rubocop/ast/node/def_node.rb#15
  def void_context?; end
end

# A node extension for `defined?` nodes. This will be used in place of a
# plain node when the builder constructs the AST, making its methods
# available to all `send` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/defined_node.rb#8
class RuboCop::AST::DefinedNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # source://rubocop//lib/rubocop/ast/node/defined_node.rb#12
  def node_parts; end
end

# A node extension for `ensure` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `ensure` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/ensure_node.rb#8
class RuboCop::AST::EnsureNode < ::RuboCop::AST::Node
  # Returns the body of the `ensure` clause.
  #
  # @return [Node, nil] The body of the `ensure`.
  #
  # source://rubocop//lib/rubocop/ast/node/ensure_node.rb#12
  def body; end
end

# A node extension for `for` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `for` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/for_node.rb#8
class RuboCop::AST::ForNode < ::RuboCop::AST::Node
  # Returns the body of the `for` loop.
  #
  # @return [Node, nil] The body of the `for` loop.
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#48
  def body; end

  # Returns the collection the `for` loop is iterating over.
  #
  # @return [Node] The collection the `for` loop is iterating over
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#41
  def collection; end

  # Checks whether the `for` node has a `do` keyword.
  #
  # @return [Boolean] whether the `for` node has a `do` keyword
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#19
  def do?; end

  # Returns the keyword of the `for` statement as a string.
  #
  # @return [String] the keyword of the `until` statement
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#12
  def keyword; end

  # Returns the iteration variable of the `for` loop.
  #
  # @return [Node] The iteration variable of the `for` loop
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#34
  def variable; end

  # Checks whether this node body is a void context.
  # Always `true` for `for`.
  #
  # @return [true] whether the `for` node body is a void context
  #
  # source://rubocop//lib/rubocop/ast/node/for_node.rb#27
  def void_context?; end
end

# Common functionality for nodes that can be used as hash elements:
# `pair`, `kwsplat`
#
# source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#7
module RuboCop::AST::HashElementNode
  # Returns the delta between this element's delimiter and the argument's.
  #
  # @note Pairs with different delimiter styles return a delta of 0
  # @return [Integer] the delta between the two delimiters
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#61
  def delimiter_delta(other); end

  # Returns the key of this `hash` element.
  #
  # @note For keyword splats, this returns the whole node
  # @return [Node] the key of the hash element
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#13
  def key; end

  # Returns the delta between this pair's key and the argument pair's.
  #
  # @note Keys on the same line always return a delta of 0
  # @note Keyword splats always return a delta of 0 for right alignment
  # @param alignment [Symbol] whether to check the left or right side
  # @return [Integer] the delta between the two keys
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#43
  def key_delta(other, alignment = T.unsafe(nil)); end

  # Checks whether this `hash` element is on the same line as `other`.
  #
  # @note A multiline element is considered to be on the same line if it
  #   shares any of its lines with `other`
  # @return [Boolean] whether this element is on the same line as `other`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#32
  def same_line?(other); end

  # Returns the value of this `hash` element.
  #
  # @note For keyword splats, this returns the whole node
  # @return [Node] the value of the hash element
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#22
  def value; end

  # Returns the delta between this element's value and the argument's.
  #
  # @note Keyword splats always return a delta of 0
  # @return [Integer] the delta between the two values
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#52
  def value_delta(other); end
end

# A helper class for comparing the positions of different parts of a
# `pair` node.
#
# source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#67
class RuboCop::AST::HashElementNode::HashElementDelta
  # @raise [ArgumentError]
  # @return [HashElementDelta] a new instance of HashElementDelta
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#68
  def initialize(first, second); end

  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#89
  def delimiter_delta; end

  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#75
  def key_delta(alignment = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#82
  def value_delta; end

  private

  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#106
  def delta(first, second, alignment = T.unsafe(nil)); end

  # Returns the value of attribute first.
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#98
  def first; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#117
  def keyword_splat?; end

  # Returns the value of attribute second.
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#98
  def second; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/hash_element_node.rb#100
  def valid_argument_types?; end
end

# A node extension for `hash` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `hash` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/hash_node.rb#8
class RuboCop::AST::HashNode < ::RuboCop::AST::Node
  # Checks whether the `hash` literal is delimited by curly braces.
  #
  # @return [Boolean] whether the `hash` literal is enclosed in braces
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#104
  def braces?; end

  # Calls the given block for each `key` node in the `hash` literal.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#50
  def each_key; end

  # Calls the given block for each `pair` node in the `hash` literal.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#28
  def each_pair; end

  # Calls the given block for each `value` node in the `hash` literal.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#72
  def each_value; end

  # Checks whether the `hash` node contains any `pair`- or `kwsplat` nodes.
  #
  # @return[Boolean] whether the `hash` is empty
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#19
  def empty?; end

  # Returns an array of all the keys in the `hash` literal.
  #
  # @return [Array<Node>] an array of keys in the `hash` literal
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#41
  def keys; end

  # Checks whether this `hash` uses a mix of hash rocket and colon
  # delimiters for its pairs.
  #
  # @return [Boolean] whether the `hash` uses mixed delimiters
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#97
  def mixed_delimiters?; end

  # Returns an array of all the key value pairs in the `hash` literal.
  #
  # @return [Array<PairNode>] an array of `pair` nodes
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#12
  def pairs; end

  # Checks whether any of the key value pairs in the `hash` literal are on
  # the same line.
  #
  # @note A multiline `pair` is considered to be on the same line if it
  #   shares any of its lines with another `pair`
  # @return [Boolean] whether any `pair` nodes are on the same line
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#89
  def pairs_on_same_line?; end

  # Returns an array of all the values in the `hash` literal.
  #
  # @return [Array<Node>] an array of values in the `hash` literal
  #
  # source://rubocop//lib/rubocop/ast/node/hash_node.rb#63
  def values; end
end

# A node extension for `if` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `if` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/if_node.rb#8
class RuboCop::AST::IfNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # Returns an array of all the branches in the conditional statement.
  #
  # @return [Array<Node>] an array of branch nodes
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#148
  def branches; end

  # Calls the given block for each branch node in the conditional statement.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#166
  def each_branch; end

  # Checks whether the `if` node has an `else` clause.
  #
  # @note This returns `true` for nodes containing an `elsif` clause.
  #   This is legacy behavior, and many cops rely on it.
  # @return [Boolean] whether the node has an `else` clause
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#42
  def else?; end

  # Returns the branch of the `if` node that gets evaluated when its
  # condition is falsey.
  #
  # @note This is normalized for `unless` nodes.
  # @return [Node] the falsey branch node of the `if` node
  # @return [nil] when there is no else branch
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#127
  def else_branch; end

  # Checks whether the `if` is an `elsif`. Parser handles these by nesting
  # `if` nodes in the `else` branch.
  #
  # @return [Boolean] whether the node is an `elsif`
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#32
  def elsif?; end

  # Checks whether the `if` node has at least one `elsif` branch. Returns
  # true if this `if` node itself is an `elsif`.
  #
  # @return [Boolean] whether the `if` node has at least one `elsif` branch
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#105
  def elsif_conditional?; end

  # Checks whether this node is an `if` statement. (This is not true of
  # ternary operators and `unless` statements.)
  #
  # @return [Boolean] whether the node is an `if` statement
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#16
  def if?; end

  # Returns the branch of the `if` node that gets evaluated when its
  # condition is truthy.
  #
  # @note This is normalized for `unless` nodes.
  # @return [Node] the truthy branch node of the `if` node
  # @return [nil] if the truthy branch is empty
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#116
  def if_branch; end

  # Returns the inverse keyword of the `if` node as a string. Returns `if`
  # for `unless` nodes and vice versa. Returns an empty string for ternary
  # operators.
  #
  # @return [String] the inverse keyword of the `if` statement
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#66
  def inverse_keyword; end

  # Returns the keyword of the `if` statement as a string. Returns an empty
  # string for ternary operators.
  #
  # @return [String] the keyword of the `if` statement
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#57
  def keyword; end

  # Checks whether the `if` node is in a modifier form, i.e. a condition
  # trailing behind an expression. Only `if` and `unless` nodes without
  # other branches can be modifiers.
  #
  # @return [Boolean] whether the `if` node is a modifier
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#81
  def modifier_form?; end

  # Chacks whether the `if` node has nested `if` nodes in any of its
  # branches.
  #
  # @note This performs a shallow search.
  # @return [Boolean] whether the `if` node contains nested conditionals
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#91
  def nested_conditional?; end

  # Custom destructuring method. This is used to normalize the branches
  # for `if` and `unless` nodes, to aid comparisons and conversions.
  #
  # @return [Array<Node>] the different parts of the `if` statement
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#135
  def node_parts; end

  # Checks whether the `if` node is a ternary operator.
  #
  # @return [Boolean] whether the `if` node is a ternary operator
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#49
  def ternary?; end

  # Checks whether this node is an `unless` statement. (This is not true
  # of ternary operators and `if` statements.)
  #
  # @return [Boolean] whether the node is an `unless` statement
  #
  # source://rubocop//lib/rubocop/ast/node/if_node.rb#24
  def unless?; end
end

# A node extension for `kwsplat` nodes. This will be used in place of a
# plain  node when the builder constructs the AST, making its methods
# available to all `kwsplat` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#8
class RuboCop::AST::KeywordSplatNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::HashElementNode

  # This is used for duck typing with `pair` nodes which also appear as
  # `hash` elements.
  #
  # @return [false]
  #
  # source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#25
  def colon?; end

  # This is used for duck typing with `pair` nodes which also appear as
  # `hash` elements.
  #
  # @return [false]
  #
  # source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#17
  def hash_rocket?; end

  # Custom destructuring method. This is used to normalize the branches
  # for `pair` and `kwsplat` nodes, to add duck typing to `hash` elements.
  #
  # @return [Array<KeywordSplatNode>] the different parts of the `kwsplat`
  #
  # source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#40
  def node_parts; end

  # Returns the operator for the `kwsplat` as a string.
  #
  # @return [String] the double splat operator
  #
  # source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#32
  def operator; end
end

# source://rubocop//lib/rubocop/ast/node/keyword_splat_node.rb#11
RuboCop::AST::KeywordSplatNode::DOUBLE_SPLAT = T.let(T.unsafe(nil), String)

# Common functionality for nodes that are a kind of method dispatch:
# `send`, `csend`, `super`, `zsuper`, `yield`, `defined?`
#
# source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#7
module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  extend ::RuboCop::NodePattern::Macros

  # Checks whether the dispatched method is an access modifier.
  #
  # @return [Boolean] whether the dispatched method is an access modifier
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#56
  def access_modifier?; end

  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#238
  def adjacent_def_modifier?(node = T.unsafe(nil)); end

  # An array containing the arguments of the dispatched method.
  #
  # @return [Array<Node>] the arguments of the dispatched method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#30
  def arguments; end

  # Checks whether this node is an arithmetic operation
  #
  # @return [Boolean] whether the dispatched method is an arithmetic
  #   operation
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#150
  def arithmetic_operation?; end

  # Checks whether the dispatched method is a setter method.
  #
  # @return [Boolean] whether the dispatched method is a setter
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#90
  def assignment?; end

  # Checks whether the dispatched method is a bare access modifier that
  # affects all methods defined after the macro.
  #
  # @return [Boolean] whether the dispatched method is a bare
  #   access modifier
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#65
  def bare_access_modifier?; end

  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#242
  def bare_access_modifier_declaration?(node = T.unsafe(nil)); end

  # Checks whether this is a binary operation.
  #
  # @example
  #
  #   foo + bar
  # @return [Bookean] whether this method is a binary operation
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#205
  def binary_operation?; end

  # Whether this method dispatch has an explicit block.
  #
  # @return [Boolean] whether the dispatched method has a block
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#142
  def block_literal?; end

  # The `block` node associated with this method dispatch, if any.
  #
  # @return [BlockNode, nil] the `block` node associated with this method
  #   call or `nil`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#38
  def block_node; end

  # Checks whether the name of the dispatched method matches the argument
  # and has an implicit receiver.
  #
  # @param name [Symbol, String] the method name to check for
  # @return [Boolean] whether the method name matches the argument
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#83
  def command?(name); end

  # Checks whether the *explicit* receiver of this method dispatch is a
  # `const` node.
  #
  # @return [Boolean] whether the receiver of this method dispatch
  #   is a `const` node
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#127
  def const_receiver?; end

  # Checks if this node is part of a chain of `def` modifiers.
  #
  # @example
  #
  #   private def foo; end
  # @return [Boolean] whether the dispatched method is a `def` modifier
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#161
  def def_modifier?; end

  # Checks whether the dispatched method uses a dot to connect the
  # receiver and the method name.
  #
  # This is useful for comparison operators, which can be called either
  # with or without a dot, i.e. `foo == bar` or `foo.== bar`.
  #
  # @return [Boolean] whether the method was called with a connecting dot
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#102
  def dot?; end

  # Checks whether the dispatched method uses a double colon to connect the
  # receiver and the method name.
  #
  # @return [Boolean] whether the method was called with a connecting dot
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#110
  def double_colon?; end

  # Checks whether the method dispatch is the implicit form of `#call`,
  # e.g. `foo.(bar)`.
  #
  # @return [Boolean] whether the method is the implicit form of `#call`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#135
  def implicit_call?; end

  # Checks whether this is a lambda. Some versions of parser parses
  # non-literal lambdas as a method send.
  #
  # @return [Boolean] whether this method is a lambda
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#170
  def lambda?; end

  # Checks whether this is a lambda literal (stabby lambda.)
  #
  # @example
  #
  #   -> (foo) { bar }
  # @return [Boolean] whether this method is a lambda literal
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#181
  def lambda_literal?; end

  # Checks whether the dispatched method is a macro method. A macro method
  # is defined as a method that sits in a class, module, or block body and
  # has an implicit receiver.
  #
  # @note This does not include DSLs that use nested blocks, like RSpec
  # @return [Boolean] whether the dispatched method is a macro method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#49
  def macro?; end

  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#213
  def macro_scope?(node = T.unsafe(nil)); end

  # The name of the dispatched method as a symbol.
  #
  # @return [Symbol] the name of the dispatched method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#23
  def method_name; end

  # Checks whether the dispatched method is a non-bare access modifier that
  # affects only the method it receives.
  #
  # @return [Boolean] whether the dispatched method is a non-bare
  #   access modifier
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#74
  def non_bare_access_modifier?; end

  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#246
  def non_bare_access_modifier_declaration?(node = T.unsafe(nil)); end

  # The receiving node of the method dispatch.
  #
  # @return [Node, nil] the receiver of the dispatched method or `nil`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#16
  def receiver; end

  # Checks whether the *explicit* receiver of this method dispatch is
  # `self`.
  #
  # @return [Boolean] whether the receiver of this method dispatch is `self`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#118
  def self_receiver?; end

  # Checks whether the dispatched method is a setter method.
  #
  # @return [Boolean] whether the dispatched method is a setter
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#90
  def setter_method?; end

  # Checks whether this is a unary operation.
  #
  # @example
  #
  #   -foo
  # @return [Boolean] whether this method is a unary operation
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#192
  def unary_operation?; end

  private

  # Check if a node's parent is a kwbegin wrapper within a macro scope
  #
  # @param parent [Node] parent of the node being checked
  # @return [Boolean] true if the parent is a kwbegin in a macro scope
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#225
  def macro_kwbegin_wrapper?(parent); end

  # Check if a node does not have a parent
  #
  # @param node [Node]
  # @return [Boolean] if the parent is nil
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#234
  def root_node?(node); end
end

# source://rubocop//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#11
RuboCop::AST::MethodDispatchNode::ARITHMETIC_OPERATORS = T.let(T.unsafe(nil), Array)

# Common predicates for nodes that reference method identifiers:
# `send`, `csend`, `def`, `defs`, `super`, `zsuper`
#
# @note this mixin expects `#method_name` and `#receiver` to be implemented
#
# source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#9
module RuboCop::AST::MethodIdentifierPredicates
  # Checks whether the method is an assignment method.
  #
  # @return [Boolean] whether the method is an assignment
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#44
  def assignment_method?; end

  # Checks whether the method is a bang method.
  #
  # @return [Boolean] whether the method is a bang method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#66
  def bang_method?; end

  # Checks whether the method is a camel case method,
  # e.g. `Integer()`.
  #
  # @return [Boolean] whether the method is a camel case method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#74
  def camel_case_method?; end

  # Checks whether the method is a comparison method.
  #
  # @return [Boolean] whether the method is a comparison
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#37
  def comparison_method?; end

  # Checks whether the *explicit* receiver of node is a `const` node.
  #
  # @return [Boolean] whether the receiver of this node is a `const` node
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#88
  def const_receiver?; end

  # Checks whether the method is an enumerator method.
  #
  # @return [Boolean] whether the method is an enumerator
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#51
  def enumerator_method?; end

  # Checks whether the method name matches the argument.
  #
  # @param name [Symbol, String] the method name to check for
  # @return [Boolean] whether the method name matches the argument
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#23
  def method?(name); end

  # Checks whether this is a negation method, i.e. `!` or keyword `not`.
  #
  # @return [Boolean] whether this method is a negation method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#95
  def negation_method?; end

  # Checks whether the method is an operator method.
  #
  # @return [Boolean] whether the method is an operator
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#30
  def operator_method?; end

  # Checks whether the method is a predicate method.
  #
  # @return [Boolean] whether the method is a predicate method
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#59
  def predicate_method?; end

  # Checks whether this is a prefix bang method, e.g. `!foo`.
  #
  # @return [Boolean] whether this method is a prefix bang
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#109
  def prefix_bang?; end

  # Checks whether this is a prefix not method, e.g. `not foo`.
  #
  # @return [Boolean] whether this method is a prefix not
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#102
  def prefix_not?; end

  # Checks whether the *explicit* receiver of this node is `self`.
  #
  # @return [Boolean] whether the receiver of this node is `self`
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#81
  def self_receiver?; end
end

# source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#10
RuboCop::AST::MethodIdentifierPredicates::ENUMERATOR_METHODS = T.let(T.unsafe(nil), Array)

# http://phrogz.net/programmingruby/language.html#table_18.4
#
# source://rubocop//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#16
RuboCop::AST::MethodIdentifierPredicates::OPERATOR_METHODS = T.let(T.unsafe(nil), Array)

# Common functionality for nodes that can be used as modifiers:
# `if`, `while`, `until`
#
# source://rubocop//lib/rubocop/ast/node/mixin/modifier_node.rb#7
module RuboCop::AST::ModifierNode
  # Checks whether the node is in a modifier form, i.e. a condition
  # trailing behind an expression.
  #
  # @return [Boolean] whether the node is a modifier
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/modifier_node.rb#12
  def modifier_form?; end
end

# `RuboCop::AST::Node` is a subclass of `Parser::AST::Node`. It provides
# access to parent nodes and an object-oriented way to traverse an AST with
# the power of `Enumerable`.
#
# It has predicate methods for every node type, like this:
#
# @example
#   node.send_type?    # Equivalent to: `node.type == :send`
#   node.op_asgn_type? # Equivalent to: `node.type == :op_asgn`
#
#   # Non-word characters (other than a-zA-Z0-9_) in type names are omitted.
#   node.defined_type? # Equivalent to: `node.type == :defined?`
#
#   # Find the first lvar node under the receiver node.
#   lvar_node = node.each_descendant.find(&:lvar_type?)
#
# source://rubocop//lib/rubocop/ast/node.rb#21
class RuboCop::AST::Node < ::Parser::AST::Node
  include ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros

  # @return [Node] a new instance of Node
  # @see https://www.rubydoc.info/gems/ast/AST/Node:initialize
  #
  # source://rubocop//lib/rubocop/ast/node.rb#58
  def initialize(type, children = T.unsafe(nil), properties = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def __ENCODING___type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def __FILE___type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def __LINE___type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def alias_type?; end

  # Returns an array of ancestor nodes.
  # This is a shorthand for `node.each_ancestor.to_a`.
  #
  # @return [Array<Node>] an array of ancestor nodes
  #
  # source://rubocop//lib/rubocop/ast/node.rb#162
  def ancestors; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def and_asgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def and_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def arg_expr_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def arg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def args_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#466
  def argument?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def array_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def array_pattern_with_tail_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def array_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#310
  def asgn_rhs(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#431
  def assignment?; end

  # source://rubocop//lib/rubocop/ast/node.rb#370
  def assignment_or_similar?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def back_ref_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#435
  def basic_conditional?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#378
  def basic_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def begin_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def block_pass_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def block_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def blockarg_expr_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def blockarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def break_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def case_match_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def case_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def casgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def cbase_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#462
  def chained?; end

  # Returns an array of child nodes.
  # This is a shorthand for `node.each_child_node.to_a`.
  #
  # @return [Array<Node>] an array of child nodes
  #
  # source://rubocop//lib/rubocop/ast/node.rb#203
  def child_nodes; end

  # source://rubocop//lib/rubocop/ast/node.rb#491
  def class_constructor?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def class_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#92
  def complete!; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#97
  def complete?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def complex_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#439
  def conditional?; end

  # source://rubocop//lib/rubocop/ast/node.rb#313
  def const_name; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def const_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def const_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def csend_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def cvar_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def cvasgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def def_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#334
  def defined_module; end

  # source://rubocop//lib/rubocop/ast/node.rb#339
  def defined_module_name; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def defined_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def defs_type?; end

  # Returns an array of descendant nodes.
  # This is a shorthand for `node.each_descendant.to_a`.
  #
  # @return [Array<Node>] an array of descendant nodes
  #
  # source://rubocop//lib/rubocop/ast/node.rb#237
  def descendants; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def dstr_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def dsym_type?; end

  # Calls the given block for each ancestor node from parent to root.
  # If no block is given, an `Enumerator` is returned.
  #
  # @overload each_ancestor
  # @overload each_ancestor
  # @overload each_ancestor
  # @overload each_ancestor
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  # @yieldparam node [Node] each ancestor node
  #
  # source://rubocop//lib/rubocop/ast/node.rb#150
  def each_ancestor(*types, &block); end

  # Calls the given block for each child node.
  # If no block is given, an `Enumerator` is returned.
  #
  # Note that this is different from `node.children.each { |child| ... }`
  # which yields all children including non-node elements.
  #
  # @overload each_child_node
  # @overload each_child_node
  # @overload each_child_node
  # @overload each_child_node
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  # @yieldparam node [Node] each child node
  #
  # source://rubocop//lib/rubocop/ast/node.rb#187
  def each_child_node(*types); end

  # Calls the given block for each descendant node with depth first order.
  # If no block is given, an `Enumerator` is returned.
  #
  # @overload each_descendant
  # @overload each_descendant
  # @overload each_descendant
  # @overload each_descendant
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  # @yieldparam node [Node] each descendant node
  #
  # source://rubocop//lib/rubocop/ast/node.rb#225
  def each_descendant(*types, &block); end

  # Calls the given block for the receiver and each descendant node in
  # depth-first order.
  # If no block is given, an `Enumerator` is returned.
  #
  # This method would be useful when you treat the receiver node as the root
  # of a tree and want to iterate over all nodes in the tree.
  #
  # @overload each_node
  # @overload each_node
  # @overload each_node
  # @overload each_node
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  # @yieldparam node [Node] each node
  #
  # source://rubocop//lib/rubocop/ast/node.rb#263
  def each_node(*types, &block); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def eflipflop_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def empty_else_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#365
  def empty_source?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def ensure_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#423
  def equals_asgn?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def erange_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def false_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#386
  def falsey_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def find_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#281
  def first_line; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def float_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def for_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def forward_arg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def forward_args_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def forwarded_args_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def forwarded_kwrestarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def forwarded_restarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#478
  def guard_clause?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def gvar_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def gvasgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def hash_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def hash_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def ident_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def if_guard_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def if_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def iflipflop_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#394
  def immutable_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def in_match_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def in_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def index_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def indexasgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def int_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def irange_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def ivar_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def ivasgn_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#443
  def keyword?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwargs_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwbegin_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwnilarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwoptarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwrestarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def kwsplat_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#488
  def lambda?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#489
  def lambda_or_proc?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def lambda_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#285
  def last_line; end

  # source://rubocop//lib/rubocop/ast/node.rb#289
  def line_count; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#374
  def literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def lvar_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def lvasgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def masgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_alt_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_as_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_current_line_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_nil_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_pattern_p_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_pattern_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_rest_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_var_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_with_lvasgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def match_with_trailing_comma_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def mlhs_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#496
  def module_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def module_type?; end

  # Predicates
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#357
  def multiline?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#390
  def mutable_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#637
  def new_class_or_module_block?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def next_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def nil_type?; end

  # Common destructuring method. This can be used to normalize
  # destructuring for different variations of the node.
  # Some node types override this with their own custom
  # destructuring method.
  #
  # @return [Array<Node>] the different parts of the ndde
  #
  # source://rubocop//lib/rubocop/ast/node.rb#128
  def node_parts; end

  # source://rubocop//lib/rubocop/ast/node.rb#295
  def nonempty_line_count; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def not_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def nth_ref_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def numargs_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def numblock_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#470
  def numeric_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def objc_kwarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def objc_restarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def objc_varargs_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def op_asgn_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#454
  def operator_keyword?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def optarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def or_asgn_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def or_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def pair_type?; end

  # Returns the parent node, or `nil` if the receiver is a root node.
  #
  # @return [Node, nil] the parent node or `nil`
  #
  # source://rubocop//lib/rubocop/ast/node.rb#84
  def parent; end

  # Searching the AST
  #
  # source://rubocop//lib/rubocop/ast/node.rb#345
  def parent_module_name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#458
  def parenthesized_call?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def pin_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def postexe_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def preexe_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#482
  def proc?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def procarg0_type?; end

  # Some expressions are evaluated for their value, some for their side
  # effects, and some for both.
  # If we know that expressions are useful only for their return values,
  # and have no side effects, that means we can reorder them, change the
  # number of times they are evaluated, or replace them with other
  # expressions which are equivalent in value.
  # So, is evaluation of this node free of side effects?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#540
  def pure?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#474
  def range_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def rational_type?; end

  # Destructuring
  #
  # source://rubocop//lib/rubocop/ast/node.rb#305
  def receiver(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#401
  def recursive_basic_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#401
  def recursive_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def redo_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#419
  def reference?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def regexp_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def regopt_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def resbody_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def rescue_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def restarg_expr_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def restarg_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def retry_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def return_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def sclass_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def self_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def send_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def shadowarg_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#427
  def shorthand_asgn?; end

  # Returns the index of the receiver node in its siblings. (Sibling index
  # uses zero based numbering.)
  #
  # @return [Integer] the index of the receiver node in its siblings
  #
  # source://rubocop//lib/rubocop/ast/node.rb#118
  def sibling_index; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#361
  def single_line?; end

  # source://rubocop//lib/rubocop/ast/node.rb#273
  def source; end

  # source://rubocop//lib/rubocop/ast/node.rb#299
  def source_length; end

  # source://rubocop//lib/rubocop/ast/node.rb#277
  def source_range; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#450
  def special_keyword?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def splat_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#311
  def str_content(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def str_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def super_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def sym_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def true_type?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#382
  def truthy_literal?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def undef_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def unless_guard_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def until_post_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def until_type?; end

  # Override `AST::Node#updated` so that `AST::Processor` does not try to
  # mutate our ASTs. Since we keep references from children to parents and
  # not just the other way around, we cannot update an AST and share
  # identical subtrees. Rather, the entire AST must be copied any time any
  # part of it is changed.
  #
  # source://rubocop//lib/rubocop/ast/node.rb#108
  def updated(type = T.unsafe(nil), children = T.unsafe(nil), properties = T.unsafe(nil)); end

  # Some expressions are evaluated for their value, some for their side
  # effects, and some for both
  # If we know that an expression is useful only for its side effects, that
  # means we can transform it in ways which preserve the side effects, but
  # change the return value
  # So, does the return value of this node matter? If we changed it to
  # `(...; nil)`, might that affect anything?
  #
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#509
  def value_used?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#415
  def variable?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def when_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def while_post_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def while_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def xstr_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def yield_type?; end

  # source://rubocop//lib/rubocop/ast/node.rb#76
  def zsuper_type?; end

  protected

  # source://rubocop//lib/rubocop/ast/node.rb#88
  def parent=(node); end

  # source://rubocop//lib/rubocop/ast/node.rb#558
  def visit_descendants(types, &block); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#577
  def begin_value_used?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#588
  def case_if_value_used?; end

  # source://rubocop//lib/rubocop/ast/node.rb#324
  def defined_module0(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#582
  def for_value_used?; end

  # source://rubocop//lib/rubocop/ast/node.rb#624
  def parent_module_name_for_block(ancestor); end

  # source://rubocop//lib/rubocop/ast/node.rb#612
  def parent_module_name_for_sclass(sclass_node); end

  # source://rubocop//lib/rubocop/ast/node.rb#599
  def parent_module_name_part(node); end

  # source://rubocop//lib/rubocop/ast/node.rb#567
  def visit_ancestors(types); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node.rb#594
  def while_until_value_used?; end
end

# source://rubocop//lib/rubocop/ast/node.rb#43
RuboCop::AST::Node::ASSIGNMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#45
RuboCop::AST::Node::BASIC_CONDITIONALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#35
RuboCop::AST::Node::BASIC_LITERALS = T.let(T.unsafe(nil), Array)

# <=> isn't included here, because it doesn't return a boolean.
#
# source://rubocop//lib/rubocop/ast/node.rb#26
RuboCop::AST::Node::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#33
RuboCop::AST::Node::COMPOSITE_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#46
RuboCop::AST::Node::CONDITIONALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#40
RuboCop::AST::Node::EQUALS_ASSIGNMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#31
RuboCop::AST::Node::FALSEY_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#38
RuboCop::AST::Node::IMMUTABLE_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#49
RuboCop::AST::Node::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#32
RuboCop::AST::Node::LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#36
RuboCop::AST::Node::MUTABLE_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#54
RuboCop::AST::Node::OPERATOR_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#48
RuboCop::AST::Node::REFERENCES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#42
RuboCop::AST::Node::SHORTHAND_ASSIGNMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#55
RuboCop::AST::Node::SPECIAL_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#28
RuboCop::AST::Node::TRUTHY_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/node.rb#47
RuboCop::AST::Node::VARIABLES = T.let(T.unsafe(nil), Array)

# A node extension for `or` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `or` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/or_node.rb#8
class RuboCop::AST::OrNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode

  # Returns the alternate operator of the `or` as a string.
  # Returns `or` for `||` and vice versa.
  #
  # @return [String] the alternate of the `or` operator
  #
  # source://rubocop//lib/rubocop/ast/node/or_node.rb#16
  def alternate_operator; end

  # Returns the inverse keyword of the `or` node as a string.
  # Returns `and` for `or` and `&&` for `||`.
  #
  # @return [String] the inverse of the `or` operator
  #
  # source://rubocop//lib/rubocop/ast/node/or_node.rb#24
  def inverse_operator; end
end

# A node extension for `pair` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `pair` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/pair_node.rb#8
class RuboCop::AST::PairNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::HashElementNode

  # Checks whether the `pair` uses a colon delimiter.
  #
  # @return [Boolean] whether this `pair` uses a colon delimiter
  #
  # source://rubocop//lib/rubocop/ast/node/pair_node.rb#26
  def colon?; end

  # Returns the delimiter of the `pair` as a string. Returns `=>` for a
  # colon delimited `pair` and `:` for a hash rocket delimited `pair`.
  #
  # @param with_spacing [Boolean] whether to include spacing
  # @return [String] the delimiter of the `pair`
  #
  # source://rubocop//lib/rubocop/ast/node/pair_node.rb#35
  def delimiter(with_spacing = T.unsafe(nil)); end

  # Checks whether the `pair` uses a hash rocket delimiter.
  #
  # @return [Boolean] whether this `pair` uses a hash rocket delimiter
  #
  # source://rubocop//lib/rubocop/ast/node/pair_node.rb#19
  def hash_rocket?; end

  # Returns the inverse delimiter of the `pair` as a string.
  #
  # @param with_spacing [Boolean] whether to include spacing
  # @return [String] the inverse delimiter of the `pair`
  #
  # source://rubocop//lib/rubocop/ast/node/pair_node.rb#47
  def inverse_delimiter(with_spacing = T.unsafe(nil)); end

  # Checks whether the value starts on its own line.
  #
  # @return [Boolean] whether the value in the `pair` starts its own line
  #
  # source://rubocop//lib/rubocop/ast/node/pair_node.rb#58
  def value_on_new_line?; end
end

# source://rubocop//lib/rubocop/ast/node/pair_node.rb#13
RuboCop::AST::PairNode::COLON = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/pair_node.rb#11
RuboCop::AST::PairNode::HASH_ROCKET = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/pair_node.rb#14
RuboCop::AST::PairNode::SPACED_COLON = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/pair_node.rb#12
RuboCop::AST::PairNode::SPACED_HASH_ROCKET = T.let(T.unsafe(nil), String)

# Common functionality for nodes that are parameterized:
# `send`, `super`, `zsuper`, `def`, `defs`
#
# source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#7
module RuboCop::AST::ParameterizedNode
  # Checks whether this node has any arguments.
  #
  # @return [Boolean] whether this node has any arguments
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#37
  def arguments?; end

  # Whether the last argument of the node is a block pass,
  # i.e. `&block`.
  #
  # @return [Boolean] whether the last argument of the node is a block pass
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#55
  def block_argument?; end

  # A shorthand for getting the first argument of the node.
  # Equivalent to `arguments.first`.
  #
  # @return [Node, nil] the first argument of the node,
  #   or `nil` if there are no arguments
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#21
  def first_argument; end

  # A shorthand for getting the last argument of the node.
  # Equivalent to `arguments.last`.
  #
  # @return [Node, nil] the last argument of the node,
  #   or `nil` if there are no arguments
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#30
  def last_argument; end

  # Checks whether this node's arguments are wrapped in parentheses.
  #
  # @return [Boolean] whether this node's arguments are
  #   wrapped in parentheses
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#12
  def parenthesized?; end

  # Checks whether any argument of the node is a splat
  # argument, i.e. `*splat`.
  #
  # @return [Boolean] whether the node is a splat argument
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#45
  def rest_argument?; end

  # Checks whether any argument of the node is a splat
  # argument, i.e. `*splat`.
  #
  # @return [Boolean] whether the node is a splat argument
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/parameterized_node.rb#45
  def splat_argument?; end
end

# Common functionality for nodes that are predicates:
# `or`, `and` ...
#
# source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#7
module RuboCop::AST::PredicateOperatorNode
  # Checks whether this is a logical operator.
  #
  # @return [Boolean] whether this is a logical operator
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#23
  def logical_operator?; end

  # Returns the operator as a string.
  #
  # @return [String] the operator
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#16
  def operator; end

  # Checks whether this is a semantic operator.
  #
  # @return [Boolean] whether this is a semantic operator
  #
  # source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#30
  def semantic_operator?; end
end

# source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#8
RuboCop::AST::PredicateOperatorNode::LOGICAL_AND = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#10
RuboCop::AST::PredicateOperatorNode::LOGICAL_OR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#9
RuboCop::AST::PredicateOperatorNode::SEMANTIC_AND = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#11
RuboCop::AST::PredicateOperatorNode::SEMANTIC_OR = T.let(T.unsafe(nil), String)

# A node extension for `irange` and `erange` nodes. This will be used in
# place of a plain node when the builder constructs the AST, making its
# methods available to all `irange` and `erange` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/range_node.rb#8
class RuboCop::AST::RangeNode < ::RuboCop::AST::Node; end

# A node extension for `regexp` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `regexp` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/regexp_node.rb#8
class RuboCop::AST::RegexpNode < ::RuboCop::AST::Node
  # @return [String] a string of regexp content
  #
  # source://rubocop//lib/rubocop/ast/node/regexp_node.rb#29
  def content; end

  # @return [RuboCop::AST::Node] a regopt node
  #
  # source://rubocop//lib/rubocop/ast/node/regexp_node.rb#23
  def regopt; end

  # @return [Regexp] a regexp of this node
  #
  # source://rubocop//lib/rubocop/ast/node/regexp_node.rb#17
  def to_regexp; end
end

# source://rubocop//lib/rubocop/ast/node/regexp_node.rb#9
RuboCop::AST::RegexpNode::OPTIONS = T.let(T.unsafe(nil), Hash)

# A node extension for `resbody` nodes. This will be used in place of a
# plain node when the builder constructs the AST, making its methods
# available to all `resbody` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/resbody_node.rb#8
class RuboCop::AST::ResbodyNode < ::RuboCop::AST::Node
  # Returns the body of the `rescue` clause.
  #
  # @return [Node, nil] The body of the `resbody`.
  #
  # source://rubocop//lib/rubocop/ast/node/resbody_node.rb#12
  def body; end
end

# A node extension for `retry` nodes. This will be used in place of a
# plain node when the builder constructs the AST, making its methods
# available to all `retry` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/retry_node.rb#8
class RuboCop::AST::RetryNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::ParameterizedNode

  # source://rubocop//lib/rubocop/ast/node/retry_node.rb#12
  def arguments; end
end

# A node extension for `send` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `send` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/send_node.rb#8
class RuboCop::AST::SendNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode
end

# This module provides a shorthand method to create a {Node} like
# `Parser::AST::Sexp`.
#
# @see https://www.rubydoc.info/gems/ast/AST/Sexp
#
# source://rubocop//lib/rubocop/ast/sexp.rb#9
module RuboCop::AST::Sexp
  # Creates a {Node} with type `type` and children `children`.
  #
  # source://rubocop//lib/rubocop/ast/sexp.rb#11
  def s(type, *children); end
end

# A node extension for `str`, `dstr`, and `xstr` nodes. This will be used
# in place of a plain node when the builder constructs the AST, making
# its methods available to all `str` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/str_node.rb#8
class RuboCop::AST::StrNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ast/node/str_node.rb#11
  def heredoc?; end
end

# A node extension for `super`- and `zsuper` nodes. This will be used in
# place of a plain node when the builder constructs the AST, making its
# methods available to all `super`- and `zsuper` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/super_node.rb#8
class RuboCop::AST::SuperNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # Custom destructuring method. This can be used to normalize
  # destructuring for different variations of the node.
  #
  # @return [Array] the different parts of the `super` node
  #
  # source://rubocop//lib/rubocop/ast/node/super_node.rb#16
  def node_parts; end
end

# A node extension for `sym` nodes. This will be used in  place of a
# plain node when the builder constructs the AST, making its methods
# available to all `sym` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/symbol_node.rb#8
class RuboCop::AST::SymbolNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::BasicLiteralNode
end

# Provides methods for traversing an AST.
# Does not transform an AST; for that, use Parser::AST::Processor.
# Override methods to perform custom processing. Remember to call `super`
# if you want to recursively process descendant nodes.
#
# source://rubocop//lib/rubocop/ast/traversal.rb#9
module RuboCop::AST::Traversal
  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_alias(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_and(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_arg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_arg_expr(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_args(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_array(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_back_ref(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_begin(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#157
  def on_block(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_block_pass(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_blockarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_break(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_case(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#73
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_cbase(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#83
  def on_class(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_complex(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#67
  def on_const(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#103
  def on_csend(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_cvar(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#95
  def on_def(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#122
  def on_defs(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_dsym(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_eflipflop(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_erange(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_false(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_float(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_for(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_hash(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#132
  def on_if(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_iflipflop(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_int(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_irange(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_ivar(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_kwarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_kwrestarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_kwsplat(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_lambda(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_lvar(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_match_current_line(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_match_with_lvasgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_mlhs(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#144
  def on_module(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_next(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_nil(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_not(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_nth_ref(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#114
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#59
  def on_optarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_or(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_pair(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_postexe(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_preexe(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_rational(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_redo(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_regopt(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_restarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_retry(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_return(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#144
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_self(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#103
  def on_send(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_shadowarg(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#39
  def on_splat(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_str(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_super(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_sym(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_true(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_undef(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#144
  def on_until(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#167
  def on_when(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#144
  def on_while(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_while_post(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_xstr(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#49
  def on_yield(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#34
  def on_zsuper(node); end

  # source://rubocop//lib/rubocop/ast/traversal.rb#10
  def walk(node); end
end

# source://rubocop//lib/rubocop/ast/traversal.rb#25
RuboCop::AST::Traversal::MANY_CHILD_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/traversal.rb#17
RuboCop::AST::Traversal::NO_CHILD_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/traversal.rb#22
RuboCop::AST::Traversal::ONE_CHILD_NODE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/ast/traversal.rb#30
RuboCop::AST::Traversal::SECOND_CHILD_ONLY = T.let(T.unsafe(nil), Array)

# A node extension for `until` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `until` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/until_node.rb#8
class RuboCop::AST::UntilNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # Checks whether the `until` node has a `do` keyword.
  #
  # @return [Boolean] whether the `until` node has a `do` keyword
  #
  # source://rubocop//lib/rubocop/ast/node/until_node.rb#30
  def do?; end

  # Returns the inverse keyword of the `until` node as a string.
  # Returns `while` for `until` nodes and vice versa.
  #
  # @return [String] the inverse keyword of the `until` statement
  #
  # source://rubocop//lib/rubocop/ast/node/until_node.rb#23
  def inverse_keyword; end

  # Returns the keyword of the `until` statement as a string.
  #
  # @return [String] the keyword of the `until` statement
  #
  # source://rubocop//lib/rubocop/ast/node/until_node.rb#15
  def keyword; end
end

# A node extension for `when` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `when` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/when_node.rb#8
class RuboCop::AST::WhenNode < ::RuboCop::AST::Node
  # Returns the body of the `when` node.
  #
  # @return [Node, nil] the body of the `when` node
  #
  # source://rubocop//lib/rubocop/ast/node/when_node.rb#48
  def body; end

  # Returns the index of the `when` branch within the `case` statement.
  #
  # @return [Integer] the index of the `when` branch
  #
  # source://rubocop//lib/rubocop/ast/node/when_node.rb#34
  def branch_index; end

  # Returns an array of all the conditions in the `when` branch.
  #
  # @return [Array<Node>] an array of condition nodes
  #
  # source://rubocop//lib/rubocop/ast/node/when_node.rb#12
  def conditions; end

  # Calls the given block for each condition node in the `when` branch.
  # If no block is given, an `Enumerator` is returned.
  #
  # @return [self] if a block is given
  # @return [Enumerator] if no block is given
  #
  # source://rubocop//lib/rubocop/ast/node/when_node.rb#21
  def each_condition; end

  # Checks whether the `when` node has a `then` keyword.
  #
  # @return [Boolean] whether the `when` node has a `then` keyword
  #
  # source://rubocop//lib/rubocop/ast/node/when_node.rb#41
  def then?; end
end

# A node extension for `while` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `while` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/while_node.rb#8
class RuboCop::AST::WhileNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode

  # Checks whether the `until` node has a `do` keyword.
  #
  # @return [Boolean] whether the `until` node has a `do` keyword
  #
  # source://rubocop//lib/rubocop/ast/node/while_node.rb#30
  def do?; end

  # Returns the inverse keyword of the `while` node as a string.
  # Returns `until` for `while` nodes and vice versa.
  #
  # @return [String] the inverse keyword of the `while` statement
  #
  # source://rubocop//lib/rubocop/ast/node/while_node.rb#23
  def inverse_keyword; end

  # Returns the keyword of the `while` statement as a string.
  #
  # @return [String] the keyword of the `while` statement
  #
  # source://rubocop//lib/rubocop/ast/node/while_node.rb#15
  def keyword; end
end

# A node extension for `yield` nodes. This will be used in place of a plain
# node when the builder constructs the AST, making its methods available
# to all `yield` nodes within RuboCop.
#
# source://rubocop//lib/rubocop/ast/node/yield_node.rb#8
class RuboCop::AST::YieldNode < ::RuboCop::AST::Node
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::MethodDispatchNode

  # Custom destructuring method. This can be used to normalize
  # destructuring for different variations of the node.
  #
  # @return [Array] the different parts of the `send` node
  #
  # source://rubocop//lib/rubocop/ast/node/yield_node.rb#16
  def node_parts; end
end

# The CLI is a class responsible of handling all the command line interface
# logic.
#
# source://rubocop//lib/rubocop/cli.rb#7
class RuboCop::CLI
  include ::RuboCop::Formatter::TextUtil

  # @return [CLI] a new instance of CLI
  #
  # source://rubocop//lib/rubocop/cli.rb#27
  def initialize; end

  # Returns the value of attribute config_store.
  #
  # source://rubocop//lib/rubocop/cli.rb#25
  def config_store; end

  # Returns the value of attribute options.
  #
  # source://rubocop//lib/rubocop/cli.rb#25
  def options; end

  # Entry point for the application logic. Here we
  # do the command line arguments processing and inspect
  # the target files.
  #
  #
  # @api public
  # @param args [Array<String>] command line arguments
  # @return [Integer] UNIX exit code
  #
  # source://rubocop//lib/rubocop/cli.rb#42
  def run(args = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cli.rb#151
  def act_on_options; end

  # source://rubocop//lib/rubocop/cli.rb#199
  def apply_default_formatter; end

  # source://rubocop//lib/rubocop/cli.rb#264
  def config_lines(cop); end

  # source://rubocop//lib/rubocop/cli.rb#260
  def cops_of_department(cops, department); end

  # source://rubocop//lib/rubocop/cli.rb#277
  def display_error_summary(errors); end

  # source://rubocop//lib/rubocop/cli.rb#269
  def display_warning_summary(warnings); end

  # source://rubocop//lib/rubocop/cli.rb#171
  def execute_runner(paths); end

  # source://rubocop//lib/rubocop/cli.rb#69
  def execute_runners(paths); end

  # @raise [Finished]
  #
  # source://rubocop//lib/rubocop/cli.rb#190
  def handle_exiting_options; end

  # source://rubocop//lib/rubocop/cli.rb#105
  def line_length_cop(config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli.rb#93
  def line_length_enabled?(config); end

  # source://rubocop//lib/rubocop/cli.rb#101
  def max_line_length(config); end

  # source://rubocop//lib/rubocop/cli.rb#294
  def maybe_print_corrected_source; end

  # source://rubocop//lib/rubocop/cli.rb#79
  def maybe_run_line_length_cop(paths); end

  # source://rubocop//lib/rubocop/cli.rb#218
  def print_available_cops; end

  # source://rubocop//lib/rubocop/cli.rb#245
  def print_cop_details(cops); end

  # source://rubocop//lib/rubocop/cli.rb#233
  def print_cops_of_department(registry, department, show_all); end

  # source://rubocop//lib/rubocop/cli.rb#135
  def reset_config_and_auto_gen_file; end

  # source://rubocop//lib/rubocop/cli.rb#124
  def run_all_cops_auto_gen_config(line_length_contents, paths); end

  # Do an initial run with only Metrics/LineLength so that cops that depend
  # on Metrics/LineLength:Max get the correct value for that parameter.
  #
  # source://rubocop//lib/rubocop/cli.rb#111
  def run_line_length_cop_auto_gen_config(paths); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli.rb#97
  def same_max_line_length?(config1, config2); end

  # source://rubocop//lib/rubocop/cli.rb#254
  def selected_cops_of_department(cops, department); end

  # source://rubocop//lib/rubocop/cli.rb#142
  def validate_options_vs_config; end
end

# source://rubocop//lib/rubocop/cli.rb#23
class RuboCop::CLI::Finished < ::RuntimeError; end

# source://rubocop//lib/rubocop/cli.rb#10
RuboCop::CLI::PHASE_1 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cli.rb#15
RuboCop::CLI::PHASE_1_DISABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cli.rb#13
RuboCop::CLI::PHASE_1_OVERRIDDEN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cli.rb#11
RuboCop::CLI::PHASE_2 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cli.rb#20
RuboCop::CLI::STATUS_ERROR = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#21
RuboCop::CLI::STATUS_INTERRUPTED = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#19
RuboCop::CLI::STATUS_OFFENSES = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#18
RuboCop::CLI::STATUS_SUCCESS = T.let(T.unsafe(nil), Integer)

# Converts RuboCop objects to and from the serialization format JSON.
#
# source://rubocop//lib/rubocop/cached_data.rb#7
class RuboCop::CachedData
  # @return [CachedData] a new instance of CachedData
  #
  # source://rubocop//lib/rubocop/cached_data.rb#8
  def initialize(filename); end

  # source://rubocop//lib/rubocop/cached_data.rb#12
  def from_json(text); end

  # source://rubocop//lib/rubocop/cached_data.rb#16
  def to_json(offenses); end

  private

  # Restore an offense object loaded from a JSON file.
  #
  # source://rubocop//lib/rubocop/cached_data.rb#45
  def deserialize_offenses(offenses); end

  # source://rubocop//lib/rubocop/cached_data.rb#38
  def message(offense); end

  # source://rubocop//lib/rubocop/cached_data.rb#22
  def serialize_offense(offense); end
end

# and provides a way to check if each cop is enabled at arbitrary line.
#
# source://rubocop//lib/rubocop/comment_config.rb#6
class RuboCop::CommentConfig
  # @return [CommentConfig] a new instance of CommentConfig
  #
  # source://rubocop//lib/rubocop/comment_config.rb#21
  def initialize(processed_source); end

  # source://rubocop//lib/rubocop/comment_config.rb#33
  def cop_disabled_line_ranges; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#25
  def cop_enabled_at_line?(cop, line_number); end

  # source://rubocop//lib/rubocop/comment_config.rb#37
  def extra_enabled_comments; end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#19
  def processed_source; end

  private

  # source://rubocop//lib/rubocop/comment_config.rb#153
  def all_cop_names; end

  # source://rubocop//lib/rubocop/comment_config.rb#57
  def analyze; end

  # source://rubocop//lib/rubocop/comment_config.rb#71
  def analyze_cop(analysis, disabled, line, single_line); end

  # source://rubocop//lib/rubocop/comment_config.rb#88
  def analyze_disabled(analysis, line); end

  # source://rubocop//lib/rubocop/comment_config.rb#98
  def analyze_rest(analysis, line); end

  # source://rubocop//lib/rubocop/comment_config.rb#81
  def analyze_single_line(analysis, line, disabled); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#157
  def comment_only_line?(line_number); end

  # source://rubocop//lib/rubocop/comment_config.rb#106
  def cop_line_ranges(analysis); end

  # source://rubocop//lib/rubocop/comment_config.rb#135
  def directive_parts(comment); end

  # source://rubocop//lib/rubocop/comment_config.rb#124
  def each_directive; end

  # source://rubocop//lib/rubocop/comment_config.rb#112
  def each_mentioned_cop; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#170
  def enable_all?(comment); end

  # source://rubocop//lib/rubocop/comment_config.rb#43
  def extra_enabled_comments_with_names(extras, names); end

  # source://rubocop//lib/rubocop/comment_config.rb#175
  def handle_enable_all(names, extras, comment); end

  # source://rubocop//lib/rubocop/comment_config.rb#187
  def handle_switch(cop_names, names, disabled, extras, comment); end

  # source://rubocop//lib/rubocop/comment_config.rb#163
  def non_comment_token_line_numbers; end

  # source://rubocop//lib/rubocop/comment_config.rb#149
  def qualified_cop_name(cop_name); end
end

# source://rubocop//lib/rubocop/comment_config.rb#13
RuboCop::CommentConfig::COMMENT_DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/comment_config.rb#11
RuboCop::CommentConfig::COPS_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/comment_config.rb#10
RuboCop::CommentConfig::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/comment_config.rb#9
RuboCop::CommentConfig::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/comment_config.rb#17
class RuboCop::CommentConfig::CopAnalysis < ::Struct
  # Returns the value of attribute line_ranges
  #
  # @return [Object] the current value of line_ranges
  def line_ranges; end

  # Sets the attribute line_ranges
  #
  # @param value [Object] the value to set the attribute line_ranges to.
  # @return [Object] the newly set value
  def line_ranges=(_); end

  # Returns the value of attribute start_line_number
  #
  # @return [Object] the current value of start_line_number
  def start_line_number; end

  # Sets the attribute start_line_number
  #
  # @param value [Object] the value to set the attribute start_line_number to.
  # @return [Object] the newly set value
  def start_line_number=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/comment_config.rb#7
RuboCop::CommentConfig::UNNEEDED_DISABLE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config.rb#13
class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder

  # @return [Config] a new instance of Config
  #
  # source://rubocop//lib/rubocop/config.rb#227
  def initialize(hash = T.unsafe(nil), loaded_path = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/config.rb#251
  def [](key); end

  # source://rubocop//lib/rubocop/config.rb#255
  def []=(key, value); end

  # source://rubocop//lib/rubocop/config.rb#319
  def add_excludes_from_higher_level(highest_config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#390
  def allowed_camel_case_file?(file); end

  # Paths specified in configuration files starting with .rubocop are
  # relative to the directory where that file is. Paths in other config files
  # are relative to the current directory. This is so that paths in
  # config/default.yml, for example, are not relative to RuboCop's config
  # directory since that wouldn't work.
  #
  # source://rubocop//lib/rubocop/config.rb#437
  def base_dir_for_path_parameters; end

  # source://rubocop//lib/rubocop/config.rb#242
  def check; end

  # source://rubocop//lib/rubocop/config.rb#259
  def delete(key); end

  # source://rubocop//lib/rubocop/config.rb#331
  def deprecation_check; end

  # source://rubocop//lib/rubocop/config.rb#263
  def each(&block); end

  # source://rubocop//lib/rubocop/config.rb#275
  def each_key(&block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#413
  def file_to_exclude?(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#369
  def file_to_include?(file); end

  # source://rubocop//lib/rubocop/config.rb#346
  def for_all_cops; end

  # source://rubocop//lib/rubocop/config.rb#342
  def for_cop(cop); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#267
  def key?(key); end

  # source://rubocop//lib/rubocop/config.rb#271
  def keys; end

  # Returns the value of attribute loaded_path.
  #
  # source://rubocop//lib/rubocop/config.rb#225
  def loaded_path; end

  # source://rubocop//lib/rubocop/config.rb#303
  def make_excludes_absolute; end

  # source://rubocop//lib/rubocop/config.rb#279
  def map(&block); end

  # source://rubocop//lib/rubocop/config.rb#283
  def merge(other_hash); end

  # source://rubocop//lib/rubocop/config.rb#428
  def path_relative_to_config(path); end

  # source://rubocop//lib/rubocop/config.rb#424
  def patterns_to_exclude; end

  # source://rubocop//lib/rubocop/config.rb#420
  def patterns_to_include; end

  # Returns true if there's a chance that an Include pattern matches hidden
  # files, false if that's definitely not possible.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#405
  def possibly_include_hidden?; end

  # source://rubocop//lib/rubocop/config.rb#299
  def signature; end

  # source://rubocop//lib/rubocop/config.rb#467
  def target_rails_version; end

  # source://rubocop//lib/rubocop/config.rb#447
  def target_ruby_version; end

  # source://rubocop//lib/rubocop/config.rb#287
  def to_h; end

  # source://rubocop//lib/rubocop/config.rb#291
  def to_hash; end

  # source://rubocop//lib/rubocop/config.rb#295
  def to_s; end

  # source://rubocop//lib/rubocop/config.rb#350
  def validate; end

  private

  # source://rubocop//lib/rubocop/config.rb#677
  def bundler_lock_file_path; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config.rb#584
  def check_target_ruby; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#697
  def enable_cop?(qualified_cop_name, cop_options); end

  # source://rubocop//lib/rubocop/config.rb#575
  def obsolete_cops; end

  # source://rubocop//lib/rubocop/config.rb#567
  def obsolete_parameter_message(cop, parameter, alternative); end

  # source://rubocop//lib/rubocop/config.rb#560
  def obsolete_parameters; end

  # source://rubocop//lib/rubocop/config.rb#665
  def read_rails_version_from_bundler_lock_file; end

  # source://rubocop//lib/rubocop/config.rb#633
  def read_ruby_version_from_bundler_lock_file; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config.rb#688
  def reject_mutually_exclusive_defaults; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config.rb#550
  def reject_obsolete_cops_and_parameters; end

  # source://rubocop//lib/rubocop/config.rb#613
  def ruby_version_file; end

  # source://rubocop//lib/rubocop/config.rb#711
  def smart_loaded_path; end

  # source://rubocop//lib/rubocop/config.rb#660
  def target_rails_version_from_bundler_lock_file; end

  # source://rubocop//lib/rubocop/config.rb#602
  def target_ruby_source; end

  # source://rubocop//lib/rubocop/config.rb#628
  def target_ruby_version_from_bundler_lock_file; end

  # source://rubocop//lib/rubocop/config.rb#618
  def target_ruby_version_from_version_file; end

  # source://rubocop//lib/rubocop/config.rb#532
  def validate_enforced_styles(valid_cop_names); end

  # source://rubocop//lib/rubocop/config.rb#514
  def validate_parameter_names(valid_cop_names); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config.rb#507
  def validate_section_presence(name); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config.rb#495
  def validate_syntax_cop; end

  # source://rubocop//lib/rubocop/config.rb#480
  def warn_about_unrecognized_cops(invalid_cop_names); end

  class << self
    # source://rubocop//lib/rubocop/config.rb#238
    def create(hash, path); end
  end
end

# source://rubocop//lib/rubocop/config.rb#17
RuboCop::Config::COMMON_PARAMS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/config.rb#27
RuboCop::Config::DEFAULT_RAILS_VERSION = T.let(T.unsafe(nil), Float)

# 2.2 is the oldest officially supported Ruby version.
#
# source://rubocop//lib/rubocop/config.rb#23
RuboCop::Config::DEFAULT_RUBY_VERSION = T.let(T.unsafe(nil), Float)

# source://rubocop//lib/rubocop/config.rb#19
RuboCop::Config::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/config.rb#24
RuboCop::Config::KNOWN_RUBIES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/config.rb#28
RuboCop::Config::OBSOLETE_COPS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/config.rb#122
RuboCop::Config::OBSOLETE_PARAMETERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/config.rb#25
RuboCop::Config::OBSOLETE_RUBIES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/config.rb#26
RuboCop::Config::RUBY_VERSION_FILENAME = T.let(T.unsafe(nil), String)

# This class represents the configuration of the RuboCop application
# and all its cops. A Config is associated with a YAML configuration
# file from which it was read. Several different Configs can be used
# during a run of the rubocop program, if files in several
# directories are inspected.
#
# source://rubocop//lib/rubocop/config_loader.rb#16
class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder

  class << self
    # source://rubocop//lib/rubocop/config_loader.rb#93
    def add_excludes_from_files(config, config_file); end

    # source://rubocop//lib/rubocop/config_loader.rb#120
    def add_inheritance_from_auto_generated_file; end

    # source://rubocop//lib/rubocop/config_loader.rb#56
    def add_missing_namespaces(path, hash); end

    # Returns the value of attribute auto_gen_config.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def auto_gen_config; end

    # Sets the attribute auto_gen_config
    #
    # @param value the value to set the attribute auto_gen_config to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def auto_gen_config=(_arg0); end

    # Returns the value of attribute auto_gen_config.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def auto_gen_config?; end

    # source://rubocop//lib/rubocop/config_loader.rb#33
    def clear_options; end

    # Returns the path of .rubocop.yml searching upwards in the
    # directory structure starting at the given directory where the
    # inspected file is. If no .rubocop.yml is found there, the
    # user's home directory is checked. If there's no .rubocop.yml
    # there either, the path to the default file is returned.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#77
    def configuration_file_for(target_dir); end

    # source://rubocop//lib/rubocop/config_loader.rb#81
    def configuration_from_file(config_file); end

    # Returns the value of attribute debug.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def debug; end

    # Sets the attribute debug
    #
    # @param value the value to set the attribute debug to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def debug=(_arg0); end

    # Returns the value of attribute debug.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def debug?; end

    # source://rubocop//lib/rubocop/config_loader.rb#103
    def default_configuration; end

    # Sets the attribute default_configuration
    #
    # @param value the value to set the attribute default_configuration to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#27
    def default_configuration=(_arg0); end

    # Returns the value of attribute ignore_parent_exclusion.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def ignore_parent_exclusion; end

    # Sets the attribute ignore_parent_exclusion
    #
    # @param value the value to set the attribute ignore_parent_exclusion to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def ignore_parent_exclusion=(_arg0); end

    # Returns the value of attribute ignore_parent_exclusion.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def ignore_parent_exclusion?; end

    # source://rubocop//lib/rubocop/config_loader.rb#38
    def load_file(file); end

    # Return a recursive merge of two hashes. That is, a normal hash merge,
    # with the addition that any value that is a hash, and occurs in both
    # arguments, will also be merged. And so on.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#68
    def merge(base_hash, derived_hash); end

    # Merges the given configuration with the default one. If
    # AllCops:DisabledByDefault is true, it changes the Enabled params so
    # that only cops from user configuration are enabled.
    # If AllCops::EnabledByDefault is true, it changes the Enabled params
    # so that only cops explicitly disabled in user configuration are
    # disabled.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#116
    def merge_with_default(config, config_file); end

    # Returns the value of attribute options_config.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def options_config; end

    # Sets the attribute options_config
    #
    # @param value the value to set the attribute options_config to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#25
    def options_config=(_arg0); end

    private

    # source://rubocop//lib/rubocop/config_loader.rb#173
    def check_duplication(yaml_code, absolute_path); end

    # source://rubocop//lib/rubocop/config_loader.rb#142
    def existing_configuration(config_file); end

    # source://rubocop//lib/rubocop/config_loader.rb#159
    def load_yaml_configuration(absolute_path); end

    # Read the specified file, or exit with a friendly, concise message on
    # stderr. Care is taken to use the standard OS exit code for a "file not
    # found" error.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#188
    def read_file(absolute_path); end

    # source://rubocop//lib/rubocop/config_loader.rb#155
    def resolver; end

    # source://rubocop//lib/rubocop/config_loader.rb#148
    def write_config_file(file_name, file_string, rubocop_yml_contents); end

    # source://rubocop//lib/rubocop/config_loader.rb#195
    def yaml_safe_load(yaml_code, filename); end
  end
end

# source://rubocop//lib/rubocop/config_loader.rb#20
RuboCop::ConfigLoader::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config_loader.rb#19
RuboCop::ConfigLoader::DEFAULT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config_loader.rb#17
RuboCop::ConfigLoader::DOTFILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config_loader.rb#18
RuboCop::ConfigLoader::RUBOCOP_HOME = T.let(T.unsafe(nil), String)

# A help class for ConfigLoader that handles configuration resolution.
#
# source://rubocop//lib/rubocop/config_loader_resolver.rb#8
class RuboCop::ConfigLoaderResolver
  # Return a recursive merge of two hashes. That is, a normal hash merge,
  # with the addition that any value that is a hash, and occurs in both
  # arguments, will also be merged. And so on.
  #
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#84
  def merge(base_hash, derived_hash, **opts); end

  # Merges the given configuration with the default one. If
  # AllCops:DisabledByDefault is true, it changes the Enabled params so that
  # only cops from user configuration are enabled. If
  # AllCops::EnabledByDefault is true, it changes the Enabled params so that
  # only cops explicitly disabled in user configuration are disabled.
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#58
  def merge_with_default(config, config_file); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#20
  def resolve_inheritance(path, hash, file, debug); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#38
  def resolve_inheritance_from_gems(hash, gems); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#9
  def resolve_requires(path, hash); end

  private

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#138
  def base_configs(path, inherit_from, file); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#125
  def determine_inherit_mode(hash, key); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#102
  def duplicate_setting?(base_hash, derived_hash, key, inherited_file); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#190
  def gem_config_path(gem_name, relative_config_path); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#162
  def handle_disabled_by_default(config, new_default_configuration); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#146
  def inherited_file(path, inherit_from, file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#157
  def remote_file?(uri); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#131
  def should_union?(base_hash, key, inherit_mode); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#186
  def transform(config); end

  # source://rubocop//lib/rubocop/config_loader_resolver.rb#111
  def warn_on_duplicate_setting(base_hash, derived_hash, key, **opts); end
end

# Raised when a RuboCop configuration file is not found.
#
# source://rubocop//lib/rubocop/config_loader.rb#8
class RuboCop::ConfigNotFoundError < ::RuboCop::Error; end

# Handles caching of configurations and association of inspected
# ruby files to configurations.
#
# source://rubocop//lib/rubocop/config_store.rb#6
class RuboCop::ConfigStore
  # @return [ConfigStore] a new instance of ConfigStore
  #
  # source://rubocop//lib/rubocop/config_store.rb#7
  def initialize; end

  # source://rubocop//lib/rubocop/config_store.rb#32
  def for(file_or_dir); end

  # source://rubocop//lib/rubocop/config_store.rb#28
  def force_default_config!; end

  # source://rubocop//lib/rubocop/config_store.rb#22
  def options_config=(options_config); end
end

# source://rubocop//lib/rubocop/cop/util.rb#4
module RuboCop::Cop; end

# This module checks for nodes that should be aligned to the left or right.
# This amount is determined by the instance variable @column_delta.
#
# source://rubocop//lib/rubocop/cop/mixin/alignment.rb#7
module RuboCop::Cop::Alignment
  private

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#27
  def check_alignment(items, base_column = T.unsafe(nil)); end

  # Returns the value of attribute column_delta.
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#12
  def column_delta; end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#14
  def configured_indentation_width; end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#60
  def display_column(range); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#47
  def each_bad_alignment(items, base_column); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#69
  def end_of_line_comment(line); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#19
  def indentation(node); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#23
  def offset(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#65
  def within?(inner, outer); end
end

# source://rubocop//lib/rubocop/cop/mixin/alignment.rb#10
RuboCop::Cop::Alignment::SPACE = T.let(T.unsafe(nil), String)

# This class does auto-correction of nodes that should just be moved to
# the left or to the right, amount being determined by the instance
# variable column_delta.
#
# source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#8
class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#30
    def align_end(processed_source, node, align_to); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#15
    def correct(processed_source, node, column_delta); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#108
    def alignment_column(align_to); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#41
    def autocorrect_line(corrector, line_begin_pos, expr, column_delta, heredoc_ranges); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#65
    def block_comment_within?(expr); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#71
    def calculate_range(expr, line_begin_pos, column_delta); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#94
    def each_line(expr); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#57
    def heredoc_ranges(node); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#83
    def remove(range, corrector); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#102
    def whitespace_range(node); end
  end
end

# Error raised when an unqualified cop name is used that could
# refer to two or more cops under different departments
#
# source://rubocop//lib/rubocop/cop/registry.rb#7
class RuboCop::Cop::AmbiguousCopName < ::RuboCop::Error
  # @return [AmbiguousCopName] a new instance of AmbiguousCopName
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#11
  def initialize(name, origin, badges); end
end

# source://rubocop//lib/rubocop/cop/registry.rb#8
RuboCop::Cop::AmbiguousCopName::MSG = T.let(T.unsafe(nil), String)

# Common code for indenting literal arrays and hashes.
#
# source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#6
module RuboCop::Cop::ArrayHashIndentation
  private

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#48
  def base_column(left_brace, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#40
  def check_expected_style(styles); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#25
  def check_first(first, left_brace, left_parenthesis, offset); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#58
  def detected_styles(actual_column, offset, left_parenthesis, left_brace); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#63
  def detected_styles_for_column(column, left_parenthesis, left_brace); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#9
  def each_argument_node(node, type); end

  # source://rubocop//lib/rubocop/cop/mixin/array_hash_indentation.rb#76
  def incorrect_style_detected(styles, first, left_parenthesis); end
end

# Handles the `MinSize` configuration option for array-based cops
# `Style/SymbolArray` and `Style/WordArray`, which check for use of the
# relevant percent literal syntax such as `%i[...]` and `%w[...]`
#
# source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#8
module RuboCop::Cop::ArrayMinSize
  private

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#19
  def array_style_detected(style, ary_size); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#11
  def below_array_length?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#38
  def largest_brackets_size(style, ary_size); end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#15
  def min_size_config; end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#48
  def smallest_percent_size(style, ary_size); end
end

# Common code for ordinary arrays with [] that can be written with %
# syntax.
#
# source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#7
module RuboCop::Cop::ArraySyntax
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#10
  def bracketed_array_of?(element_type, node); end
end

# This module encapsulates the logic for autocorrect behavior for a cop.
#
# source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#6
module RuboCop::Cop::AutocorrectLogic
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#7
  def autocorrect?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#19
  def autocorrect_enabled?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#11
  def autocorrect_requested?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#15
  def support_autocorrect?; end
end

# Identifier of all cops containing a department and cop name.
#
# All cops are identified by their badge. For example, the badge
# for `RuboCop::Cop::Layout::Tab` is `Layout/Tab`. Badges can be
# parsed as either `Department/CopName` or just `CopName` to allow
# for badge references in source files that omit the department
# for RuboCop to infer.
#
# source://rubocop//lib/rubocop/cop/badge.rb#12
class RuboCop::Cop::Badge
  # @return [Badge] a new instance of Badge
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#41
  def initialize(department, cop_name); end

  # source://rubocop//lib/rubocop/cop/badge.rb#46
  def ==(other); end

  # Returns the value of attribute cop_name.
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#23
  def cop_name; end

  # Returns the value of attribute department.
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#23
  def department; end

  # source://rubocop//lib/rubocop/cop/badge.rb#46
  def eql?(other); end

  # source://rubocop//lib/rubocop/cop/badge.rb#51
  def hash; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#55
  def match?(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#64
  def qualified?; end

  # source://rubocop//lib/rubocop/cop/badge.rb#60
  def to_s; end

  # source://rubocop//lib/rubocop/cop/badge.rb#68
  def with_department(department); end

  class << self
    # source://rubocop//lib/rubocop/cop/badge.rb#25
    def for(class_name); end

    # @raise [InvalidBadge]
    #
    # source://rubocop//lib/rubocop/cop/badge.rb#29
    def parse(identifier); end
  end
end

# Error raised when a badge parse fails.
#
# source://rubocop//lib/rubocop/cop/badge.rb#14
class RuboCop::Cop::Badge::InvalidBadge < ::RuboCop::Error
  # @return [InvalidBadge] a new instance of InvalidBadge
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#18
  def initialize(token); end
end

# source://rubocop//lib/rubocop/cop/badge.rb#15
RuboCop::Cop::Badge::InvalidBadge::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#5
module RuboCop::Cop::Bundler; end

# A Gem's requirements should be listed only once in a Gemfile.
#
# @example
#   # bad
#   gem 'rubocop'
#   gem 'rubocop'
#
#   # bad
#   group :development do
#   gem 'rubocop'
#   end
#
#   group :test do
#   gem 'rubocop'
#   end
#
#   # good
#   group :development, :test do
#   gem 'rubocop'
#   end
#
#   # good
#   gem 'rubocop', groups: [:development, :test]
#
# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#28
class RuboCop::Cop::Bundler::DuplicatedGem < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#50
  def gem_declarations(node0); end

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#34
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#52
  def duplicated_gem_nodes; end

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#59
  def register_offense(node, gem_name, line_of_first_occurrence); end
end

# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#31
RuboCop::Cop::Bundler::DuplicatedGem::MSG = T.let(T.unsafe(nil), String)

# Add a comment describing each gem in your Gemfile.
#
# @example
#   # bad
#
#   gem 'foo'
#
#   # good
#
#   # Helpers for the foo things.
#   gem 'foo'
#
# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#18
class RuboCop::Cop::Bundler::GemComment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::DefNode

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#23
  def gem_declaration?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#25
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#35
  def commented?(node); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#42
  def precede?(node1, node2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#52
  def preceding_comment?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#46
  def preceding_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#57
  def whitelisted_gem?(node); end
end

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#21
RuboCop::Cop::Bundler::GemComment::MSG = T.let(T.unsafe(nil), String)

# The symbol argument `:gemcutter`, `:rubygems`, and `:rubyforge`
# are deprecated. So please change your source to URL string that
# 'https://rubygems.org' if possible, or 'http://rubygems.org' if not.
#
# This autocorrect will replace these symbols with 'https://rubygems.org'.
# Because it is secure, HTTPS request is strongly recommended. And in
# most use cases HTTPS will be fine.
#
# However, it don't replace all `sources` of `http://` with `https://`.
# For example, when specifying an internal gem server using HTTP on the
# intranet, a use case where HTTPS can not be specified was considered.
# Consider using HTTP only if you can not use HTTPS.
#
# @example
#   # bad
#   source :gemcutter
#   source :rubygems
#   source :rubyforge
#
#   # good
#   source 'https://rubygems.org' # strongly recommended
#   source 'http://rubygems.org'
#
# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#28
class RuboCop::Cop::Bundler::InsecureProtocolSource < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#53
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#36
  def insecure_protocol_source?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#41
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#63
  def range(node); end
end

# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#31
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG = T.let(T.unsafe(nil), String)

# Gems should be alphabetically sorted within groups.
#
# @example
#   # bad
#   gem 'rubocop'
#   gem 'rspec'
#
#   # good
#   gem 'rspec'
#   gem 'rubocop'
#
#   # good
#   gem 'rubocop'
#
#   gem 'rspec'
#
#   # good only if TreatCommentsAsGroupSeparators is true
#   # For code quality
#   gem 'rubocop'
#   # For tests
#   gem 'rspec'
#
# source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#27
class RuboCop::Cop::Bundler::OrderedGems < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#50
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#67
  def gem_declarations(node0); end

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#35
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#61
  def previous_declaration(node); end
end

# source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#31
RuboCop::Cop::Bundler::OrderedGems::MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking assignment nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#6
module RuboCop::Cop::CheckAssignment
  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#19
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#29
  def extract_rhs(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#29
    def extract_rhs(node); end
  end
end

# Common functionality for checking length of classes and modules.
#
# source://rubocop//lib/rubocop/cop/mixin/classish_length.rb#6
module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength

  private

  # source://rubocop//lib/rubocop/cop/mixin/classish_length.rb#11
  def code_length(node); end

  # source://rubocop//lib/rubocop/cop/mixin/classish_length.rb#25
  def line_numbers_of_inner_nodes(node, *types); end
end

# Common functionality for checking length of code segments.
#
# source://rubocop//lib/rubocop/cop/mixin/code_length.rb#6
module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax

  private

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#19
  def check_code_length(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#15
  def count_comments?; end

  # Returns true for lines that shall not be included in the count.
  #
  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#33
  def irrelevant_line(source_line); end

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#11
  def max_length; end
end

# Commissioner class is responsible for processing the AST and delegating
# work to the specified cops.
#
# source://rubocop//lib/rubocop/cop/commissioner.rb#7
class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal

  # @return [Commissioner] a new instance of Commissioner
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#14
  def initialize(cops, forces = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#12
  def errors; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#39
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_arg_expr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_back_ref(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_block_pass(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_blockarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_break(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_cbase(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_complex(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_cvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_dsym(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_eflipflop(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_false(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_float(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_iflipflop(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_int(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_irange(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_ivar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_kwarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_kwrestarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_kwsplat(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_lambda(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_lvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_match_current_line(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_match_with_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_mlhs(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_next(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_nil(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_not(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_nth_ref(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_optarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_postexe(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_preexe(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_rational(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_redo(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_regopt(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_restarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_retry(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_self(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_shadowarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_splat(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_sym(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_true(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_undef(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_when(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_while_post(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_xstr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_yield(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#33
  def on_zsuper(node); end

  private

  # There are cops/forces that require their own custom processing.
  # If they define the #investigate method, all input parameters passed
  # to the commissioner will be passed to the cop too in order to do
  # its own processing.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#92
  def invoke_custom_processing(cops_or_forces, processed_source); end

  # TODO: Bad design.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#84
  def prepare(processed_source); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#67
  def remove_irrelevant_cops(filename); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#79
  def reset_callbacks; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#63
  def reset_errors; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#52
  def trigger_responding_cops(callback, node); end

  # Allow blind rescues here, since we're absorbing and packaging or
  # re-raising exceptions that can be raised from within the individual
  # cops' `#investigate` methods.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#105
  def with_cop_error_handling(cop, node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/commissioner.rb#10
class RuboCop::Cop::Commissioner::CopError < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute error
  #
  # @return [Object] the current value of error
  def error; end

  # Sets the attribute error
  #
  # @param value [Object] the value to set the attribute error to.
  # @return [Object] the newly set value
  def error=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This class does condition auto-correction
#
# source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#6
class RuboCop::Cop::ConditionCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#8
    def correct_negative_condition(node); end

    private

    # source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#20
    def negated_condition(node); end
  end
end

# Handles `EnforcedStyle` configuration parameters.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#6
module RuboCop::Cop::ConfigurableEnforcedStyle
  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#74
  def alternative_style; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#82
  def alternative_styles; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#19
  def ambiguous_style_detected(*possibilities); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def conflicting_styles_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#11
  def correct_style_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#52
  def detected_style; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#56
  def detected_style=(style); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def no_acceptable_style!; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#44
  def no_acceptable_style?; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#7
  def opposite_style_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#63
  def style; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#23
  def style_detected(detected); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#93
  def style_parameter_name; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#86
  def supported_styles; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#15
  def unexpected_style_detected(unexpected); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#48
  def unrecognized_style_detected; end
end

# Shared functionality between mixins that enforce naming conventions
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#6
module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#9
  def check_name(node, name, name_range); end

  # A class emitter method is a singleton method in a class/module, where
  # the method has the same name as a class defined in the class/module.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#34
  def class_emitter_method?(node, name); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#19
  def report_opposing_styles(node, name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#27
  def valid_name?(node, name, given_style = T.unsafe(nil)); end
end

# Handles `Max` configuration parameters, especially setting them to an
# appropriate value with --auto-gen-config.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#7
module RuboCop::Cop::ConfigurableMax
  private

  # source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#10
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#18
  def max_parameter_name; end
end

# This module provides functionality for checking if names match the
# configured EnforcedStyle.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#7
module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#10
RuboCop::Cop::ConfigurableNaming::FORMATS = T.let(T.unsafe(nil), Hash)

# This module provides functionality for checking if numbering match the
# configured EnforcedStyle.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#7
module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#10
RuboCop::Cop::ConfigurableNumbering::FORMATS = T.let(T.unsafe(nil), Hash)

# Monkey-patch Cop for tests to provide easy access to messages and
# highlights.
#
# source://rubocop//lib/rubocop/cop/cop.rb#26
class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros

  # @return [Cop] a new instance of Cop
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#94
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/cop.rb#121
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#34
  def config; end

  # source://rubocop//lib/rubocop/cop/cop.rb#160
  def config_to_allow_offenses; end

  # source://rubocop//lib/rubocop/cop/cop.rb#165
  def config_to_allow_offenses=(hash); end

  # source://rubocop//lib/rubocop/cop/cop.rb#109
  def cop_config; end

  # source://rubocop//lib/rubocop/cop/cop.rb#182
  def cop_name; end

  # source://rubocop//lib/rubocop/cop/cop.rb#147
  def correct(node); end

  # Returns the value of attribute corrections.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#34
  def corrections; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#143
  def duplicate_location?(location); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#193
  def excluded_file?(file); end

  # source://rubocop//lib/rubocop/cop/cop.rb#138
  def find_location(node, loc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#105
  def join_force?(_force_class); end

  # source://rubocop//lib/rubocop/cop/cop.rb#116
  def message(_node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/cop.rb#182
  def name; end

  # Returns the value of attribute offenses.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#34
  def offenses; end

  # source://rubocop//lib/rubocop/cop/cop.rb#178
  def parse(source, path = T.unsafe(nil)); end

  # TODO: Bad design.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#35
  def processed_source; end

  # TODO: Bad design.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#35
  def processed_source=(_arg0); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#188
  def relevant_file?(file); end

  # source://rubocop//lib/rubocop/cop/cop.rb#174
  def target_rails_version; end

  # source://rubocop//lib/rubocop/cop/cop.rb#170
  def target_ruby_version; end

  private

  # source://rubocop//lib/rubocop/cop/cop.rb#199
  def annotate(message); end

  # source://rubocop//lib/rubocop/cop/cop.rb#230
  def custom_severity; end

  # source://rubocop//lib/rubocop/cop/cop.rb#226
  def default_severity; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#220
  def enabled_line?(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#205
  def file_name_matches_any?(file, parameter, default_result); end

  class << self
    # source://rubocop//lib/rubocop/cop/cop.rb#43
    def all; end

    # List of cops that should not try to autocorrect at the same
    # time as this cop
    #
    # @api public
    # @return [Array<RuboCop::Cop::Cop>]
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#90
    def autocorrect_incompatible_with; end

    # source://rubocop//lib/rubocop/cop/cop.rb#59
    def badge; end

    # source://rubocop//lib/rubocop/cop/cop.rb#63
    def cop_name; end

    # source://rubocop//lib/rubocop/cop/cop.rb#67
    def department; end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#55
    def inherited(subclass); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#71
    def lint?; end

    # Returns true if the cop name or the cop namespace matches any of the
    # given names.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#77
    def match?(given_names); end

    # source://rubocop//lib/rubocop/cop/cop.rb#51
    def non_rails; end

    # source://rubocop//lib/rubocop/cop/cop.rb#47
    def qualified_cop_name(name, origin); end

    # Returns the value of attribute registry.
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#40
    def registry; end
  end
end

# This class takes a source buffer and rewrite its source
# based on the different correction rules supplied.
#
# Important!
# The nodes modified by the corrections should be part of the
# AST of the source_buffer.
#
# source://rubocop//lib/rubocop/cop/corrector.rb#11
class RuboCop::Cop::Corrector
  # @example
  #
  #   class AndOrCorrector
  #   def initialize(node)
  #   @node = node
  #   end
  #
  #   def call(corrector)
  #   replacement = (@node.type == :and ? '&&' : '||')
  #   corrector.replace(@node.loc.operator, replacement)
  #   end
  #   end
  #
  #   corrections = [AndOrCorrector.new(node)]
  #   corrector = Corrector.new(source_buffer, corrections)
  # @param source_buffer [Parser::Source::Buffer]
  # @param corrections [Array(#call)] Array of Objects that respond to #call. They will receive the
  #   corrector itself and should use its method to modify the source.
  # @return [Corrector] a new instance of Corrector
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#33
  def initialize(source_buffer, corrections = T.unsafe(nil)); end

  # Returns the value of attribute corrections.
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#53
  def corrections; end

  # Returns the value of attribute diagnostics.
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#53
  def diagnostics; end

  # Inserts new code after the given source range.
  #
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#100
  def insert_after(range, content); end

  # Inserts new code before the given source range.
  #
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#86
  def insert_before(range, content); end

  # Removes the source range.
  #
  # @param range [Parser::Source::Range]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#77
  def remove(range); end

  # Removes `size` characters from the beginning of the given range.
  # If `size` is greater than the size of `range`, the removed region can
  # overrun the end of `range`.
  #
  # @param range [Parser::Source::Range]
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#132
  def remove_leading(range, size); end

  # Removes `size` characters prior to the source range.
  #
  # @param range [Parser::Source::Range]
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#118
  def remove_preceding(range, size); end

  # Removes `size` characters from the end of the given range.
  # If `size` is greater than the size of `range`, the removed region can
  # overrun the beginning of `range`.
  #
  # @param range [Parser::Source::Range]
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#146
  def remove_trailing(range, size); end

  # Replaces the code of the source range `range` with `content`.
  #
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#109
  def replace(range, content); end

  # Does the actual rewrite and returns string corresponding to
  # the rewritten source.
  #
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#59
  def rewrite; end

  private

  # source://rubocop//lib/rubocop/cop/corrector.rb#157
  def validate_range(range); end
end

# Common functionality for checking def nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/def_node.rb#6
module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#28
  def non_public_modifier?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#13
  def non_public?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#18
  def preceding_non_public_modifier?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#24
  def stripped_source_upto(index); end
end

# source://rubocop//lib/rubocop/cop/mixin/def_node.rb#9
RuboCop::Cop::DefNode::NON_PUBLIC_MODIFIERS = T.let(T.unsafe(nil), Array)

# Common functionality for checking documentation.
#
# source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#6
module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#12
  def constant_definition?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#14
  def documentation_comment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#45
  def interpreter_directive_comment?(comment); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#35
  def precede?(node1, node2); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#28
  def preceding_comment?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#39
  def preceding_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#49
  def rubocop_directive_comment?(comment); end
end

# Common functionality for dealing with duplication.
#
# source://rubocop//lib/rubocop/cop/mixin/duplication.rb#6
module RuboCop::Cop::Duplication
  private

  # Returns the consecutive duplicates, leaving out the first instance of
  # the duplicated elements.
  #
  # @param collection [Array] an array to return consecutive duplicates for
  # @return [Array] the consecutive duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#31
  def consecutive_duplicates(collection); end

  # Returns all duplicates, including the first instance of the duplicated
  # elements.
  #
  # @param collection [Array] an array to return duplicates for
  # @return [Array] all the duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#22
  def duplicates(collection); end

  # Whether the `collection` contains any duplicates.
  #
  # @param collection [Array] an array to check for duplicates
  # @return [Boolean] whether the array contains any duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#13
  def duplicates?(collection); end

  # Returns a hash of grouped duplicates. The key will be the first
  # instance of the element, and  the value an `array` of the initial
  # element and all duplicate instances.
  #
  # @param collection [Array] an array to group duplicates for
  # @return [Array] the grouped duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#41
  def grouped_duplicates(collection); end
end

# This class auto-corrects `#each` enumeration to `for` iteration.
#
# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#6
class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::NodePattern::Macros

  # @return [EachToForCorrector] a new instance of EachToForCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#13
  def initialize(block_node); end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#19
  def call(corrector); end

  private

  # Returns the value of attribute argument_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#25
  def argument_node; end

  # Returns the value of attribute block_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#25
  def block_node; end

  # Returns the value of attribute collection_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#25
  def collection_node; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#27
  def correction; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#38
  def offending_range; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#46
  def replacement_range(end_pos); end
end

# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#11
RuboCop::Cop::EachToForCorrector::CORRECTION_WITHOUT_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#9
RuboCop::Cop::EachToForCorrector::CORRECTION_WITH_ARGUMENTS = T.let(T.unsafe(nil), String)

# This class does empty line auto-correction
#
# source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#6
class RuboCop::Cop::EmptyLineCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#8
    def correct(node); end

    # source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#20
    def insert_before(node); end
  end
end

# Common code for empty parameter cops.
#
# source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#6
module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#11
  def empty_arguments?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#15
  def check(node); end
end

# Functions for checking the alignment of the `end` keyword.
#
# source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#6
module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#42
  def add_offense_for_misalignment(node, align_with); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#19
  def check_end_kw_alignment(node, align_ranges); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#15
  def check_end_kw_in_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#62
  def line_break_before_keyword?(whole_expression, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#35
  def matching_ranges(end_loc, align_ranges); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#52
  def style_parameter_name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#56
  def variable_alignment?(whole_expression, rhs, end_alignment_style); end
end

# source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#10
RuboCop::Cop::EndKeywordAlignment::MSG = T.let(T.unsafe(nil), String)

# Common functionality for enforcing a specific superclass
#
# source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#6
module RuboCop::Cop::EnforceSuperclass
  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#17
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#23
  def on_send(node); end

  class << self
    # @private
    #
    # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#7
    def included(base); end
  end
end

# Common functionality for checking for a line break before the first
# element in a multi-line collection.
#
# source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#7
module RuboCop::Cop::FirstElementLineBreak
  private

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#23
  def check_children_line_break(node, children, start = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#10
  def check_method_line_break(node, children); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#37
  def first_by_line(nodes); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#41
  def last_by_line(nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#18
  def method_uses_parens?(node, limit); end
end

# This class auto-corrects `for` iteration to `#each` enumeration.
#
# source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#6
class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::NodePattern::Macros

  # @return [ForToEachCorrector] a new instance of ForToEachCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#11
  def initialize(for_node); end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#17
  def call(corrector); end

  private

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#54
  def collection_end; end

  # Returns the value of attribute collection_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def collection_node; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#30
  def collection_source; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#25
  def correction; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#42
  def end_position; end

  # Returns the value of attribute for_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def for_node; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#50
  def keyword_begin; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#62
  def offending_range; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#66
  def replacement_range(end_pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#38
  def requires_parentheses?; end

  # Returns the value of attribute variable_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def variable_node; end
end

# source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#9
RuboCop::Cop::ForToEachCorrector::CORRECTION = T.let(T.unsafe(nil), String)

# A scaffold for concrete forces.
#
# source://rubocop//lib/rubocop/cop/force.rb#6
class RuboCop::Cop::Force
  # @return [Force] a new instance of Force
  #
  # source://rubocop//lib/rubocop/cop/force.rb#21
  def initialize(cops); end

  # Returns the value of attribute cops.
  #
  # source://rubocop//lib/rubocop/cop/force.rb#7
  def cops; end

  # source://rubocop//lib/rubocop/cop/force.rb#37
  def investigate(_processed_source); end

  # source://rubocop//lib/rubocop/cop/force.rb#25
  def name; end

  # source://rubocop//lib/rubocop/cop/force.rb#29
  def run_hook(method_name, *args); end

  class << self
    # source://rubocop//lib/rubocop/cop/force.rb#9
    def all; end

    # source://rubocop//lib/rubocop/cop/force.rb#17
    def force_name; end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/force.rb#13
    def inherited(subclass); end
  end
end

# Common functionality for dealing with frozen string literals.
#
# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#6
module RuboCop::Cop::FrozenStringLiteral
  private

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#13
  def frozen_string_literal_comment_exists?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#21
  def frozen_string_literals_enabled?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#43
  def leading_comment_lines; end

  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#13
    def frozen_string_literal_comment_exists?; end
  end
end

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#9
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#10
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_ENABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#11
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#5
module RuboCop::Cop::Gemspec; end

# An attribute assignment method calls should be listed only once
# in a gemspec.
#
# Assigning to an attribute with the same name using `spec.foo =` will be
# an unintended usage. On the other hand, duplication of methods such
# as `spec.requirements`, `spec.add_runtime_dependency`, and others are
# permitted because it is the intended use of appending values.
#
# @example
#   # bad
#   Gem::Specification.new do |spec|
#   spec.name = 'rubocop'
#   spec.name = 'rubocop2'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.name = 'rubocop'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.requirements << 'libmagick, v6.0'
#   spec.requirements << 'A good graphics card'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_runtime_dependency('parallel', '~> 1.10')
#   spec.add_runtime_dependency('parser', '>= 2.3.3.1', '< 3.0')
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#37
class RuboCop::Cop::Gemspec::DuplicatedAssignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#52
  def assignment_method_declarations(node0); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#43
  def gem_specification(node0); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#57
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#79
  def assignment_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#83
  def duplicated_assignment_method_nodes; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#73
  def match_block_variable_name?(receiver_name); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#90
  def register_offense(node, assignment, line_of_first_occurrence); end
end

# source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#40
RuboCop::Cop::Gemspec::DuplicatedAssignment::MSG = T.let(T.unsafe(nil), String)

# Dependencies in the gemspec should be alphabetically sorted.
#
# @example
#   # bad
#   spec.add_dependency 'rubocop'
#   spec.add_dependency 'rspec'
#
#   # good
#   spec.add_dependency 'rspec'
#   spec.add_dependency 'rubocop'
#
#   # good
#   spec.add_dependency 'rubocop'
#
#   spec.add_dependency 'rspec'
#
#   # bad
#   spec.add_development_dependency 'rubocop'
#   spec.add_development_dependency 'rspec'
#
#   # good
#   spec.add_development_dependency 'rspec'
#   spec.add_development_dependency 'rubocop'
#
#   # good
#   spec.add_development_dependency 'rubocop'
#
#   spec.add_development_dependency 'rspec'
#
#   # bad
#   spec.add_runtime_dependency 'rubocop'
#   spec.add_runtime_dependency 'rspec'
#
#   # good
#   spec.add_runtime_dependency 'rspec'
#   spec.add_runtime_dependency 'rubocop'
#
#   # good
#   spec.add_runtime_dependency 'rubocop'
#
#   spec.add_runtime_dependency 'rspec'
#
#   # good only if TreatCommentsAsGroupSeparators is true
#   # For code quality
#   spec.add_dependency 'rubocop'
#   # For tests
#   spec.add_dependency 'rspec'
#
# source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#53
class RuboCop::Cop::Gemspec::OrderedDependencies < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#80
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#101
  def dependency_declarations(node0); end

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#62
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#97
  def get_dependency_name(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#91
  def previous_declaration(node); end
end

# source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#57
RuboCop::Cop::Gemspec::OrderedDependencies::MSG = T.let(T.unsafe(nil), String)

# Checks that `required_ruby_version` of gemspec and `TargetRubyVersion`
# of .rubocop.yml are equal.
# Thereby, RuboCop to perform static analysis working on the version
# required by gemspec.
#
# @example
#   # When `TargetRubyVersion` of .rubocop.yml is `2.3`.
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.2.0'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.4.0'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.3.0'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.3'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = ['>= 2.3.0', '< 2.5.0']
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#38
class RuboCop::Cop::Gemspec::RequiredRubyVersion < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#48
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#44
  def required_ruby_version(node0); end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#64
  def extract_ruby_version(required_ruby_version); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#74
  def message(required_ruby_version, target_ruby_version); end
end

# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#39
RuboCop::Cop::Gemspec::RequiredRubyVersion::MSG = T.let(T.unsafe(nil), String)

# Source and spec generator for new cops
#
# This generator will take a cop name and generate a source file
# and spec file when given a valid qualified cop name.
#
# source://rubocop//lib/rubocop/cop/generator.rb#9
class RuboCop::Cop::Generator
  # @raise [ArgumentError]
  # @return [Generator] a new instance of Generator
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#106
  def initialize(name, github_user, output: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator.rb#130
  def inject_config(config_file_path: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator.rb#123
  def inject_require(root_file_path: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator.rb#142
  def todo; end

  # source://rubocop//lib/rubocop/cop/generator.rb#115
  def write_source; end

  # source://rubocop//lib/rubocop/cop/generator.rb#119
  def write_spec; end

  private

  # Returns the value of attribute badge.
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#154
  def badge; end

  # source://rubocop//lib/rubocop/cop/generator.rb#210
  def bump_minor_version; end

  # source://rubocop//lib/rubocop/cop/generator.rb#177
  def generate(template); end

  # source://rubocop//lib/rubocop/cop/generator.rb#169
  def generated_source; end

  # source://rubocop//lib/rubocop/cop/generator.rb#173
  def generated_spec; end

  # Returns the value of attribute github_user.
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#154
  def github_user; end

  # Returns the value of attribute output.
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#154
  def output; end

  # source://rubocop//lib/rubocop/cop/generator.rb#201
  def snake_case(camel_case_string); end

  # source://rubocop//lib/rubocop/cop/generator.rb#191
  def source_path; end

  # source://rubocop//lib/rubocop/cop/generator.rb#181
  def spec_path; end

  # source://rubocop//lib/rubocop/cop/generator.rb#156
  def write_unless_file_exists(path, contents); end
end

# source://rubocop//lib/rubocop/cop/generator.rb#101
RuboCop::Cop::Generator::CONFIGURATION_ADDED_MESSAGE = T.let(T.unsafe(nil), String)

# A class that injects a require directive into the root RuboCop file.
# It looks for other directives that require files in the same (cop)
# namespace and injects the provided one in alpha
#
# source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#9
class RuboCop::Cop::Generator::ConfigurationInjector
  # @return [ConfigurationInjector] a new instance of ConfigurationInjector
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#18
  def initialize(configuration_file_path:, badge:, version_added:); end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#25
  def inject; end

  private

  # Returns the value of attribute badge.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#36
  def badge; end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#38
  def configuration_entries; end

  # Returns the value of attribute configuration_file_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#36
  def configuration_file_path; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#55
  def cop_name_line?(yaml); end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#46
  def find_target_line; end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#42
  def new_configuration_entry; end

  # Returns the value of attribute output.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#36
  def output; end

  # Returns the value of attribute version_added.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#36
  def version_added; end
end

# source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#10
RuboCop::Cop::Generator::ConfigurationInjector::TEMPLATE = T.let(T.unsafe(nil), String)

# A class that injects a require directive into the root RuboCop file.
# It looks for other directives that require files in the same (cop)
# namespace and injects the provided one in alpha
#
# source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#9
class RuboCop::Cop::Generator::RequireFileInjector
  # @return [RequireFileInjector] a new instance of RequireFileInjector
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#12
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#19
  def inject; end

  private

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#67
  def injectable_require_directive; end

  # Returns the value of attribute output.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def output; end

  # Returns the value of attribute require_entries.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def require_entries; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#31
  def require_exists?; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#71
  def require_path; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#61
  def require_path_fragments(require_directove); end

  # Returns the value of attribute root_file_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def root_file_path; end

  # Returns the value of attribute source_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def source_path; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#42
  def target_line; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#37
  def updated_directives; end
end

# source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#10
RuboCop::Cop::Generator::RequireFileInjector::REQUIRE_PATH = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/generator.rb#10
RuboCop::Cop::Generator::SOURCE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/generator.rb#75
RuboCop::Cop::Generator::SPEC_TEMPLATE = T.let(T.unsafe(nil), String)

# Common functionality for checking hash alignment.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#6
module RuboCop::Cop::HashAlignment; end

# Handles calculation of deltas when the enforced style is 'key'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#8
class RuboCop::Cop::HashAlignment::KeyAlignment
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#9
  def checkable_layout?(_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#20
  def deltas(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#13
  def deltas_for_first_pair(first_pair, _node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#34
  def separator_delta(pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#45
  def value_delta(pair); end
end

# Handles calculation of deltas when the enforced style is 'separator'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#120
class RuboCop::Cop::HashAlignment::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#123
  def deltas_for_first_pair(*_nodes); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#133
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#129
  def key_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#137
  def value_delta(first_pair, current_pair); end
end

# Handles calculation of deltas when the enforced style is 'table'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#83
class RuboCop::Cop::HashAlignment::TableAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#86
  def deltas_for_first_pair(first_pair, node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#104
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#100
  def key_delta(first_pair, current_pair); end

  # Returns the value of attribute max_key_width.
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#98
  def max_key_width; end

  # Sets the attribute max_key_width
  #
  # @param value the value to set the attribute max_key_width to.
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#98
  def max_key_width=(_arg0); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#109
  def value_delta(first_pair, current_pair); end
end

# Common functionality for checking alignment of hash values.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#56
module RuboCop::Cop::HashAlignment::ValueAlignment
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#57
  def checkable_layout?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#61
  def deltas(first_pair, current_pair); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment.rb#73
  def separator_delta(first_pair, current_pair, key_delta); end
end

# Common functionality for working with heredoc strings.
#
# source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#6
module RuboCop::Cop::Heredoc
  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_dstr(node); end

  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#17
  def on_heredoc(_node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_xstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#23
  def delimiter_string(node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#27
  def heredoc_type(node); end
end

# source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#7
RuboCop::Cop::Heredoc::OPENING_DELIMITER = T.let(T.unsafe(nil), Regexp)

# This module encapsulates the ability to ignore certain methods when
# parsing.
#
# source://rubocop//lib/rubocop/cop/mixin/ignored_methods.rb#7
module RuboCop::Cop::IgnoredMethods
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/ignored_methods.rb#10
  def ignored_method?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/ignored_methods.rb#14
  def ignored_methods; end
end

# Handles adding and checking ignored nodes.
#
# source://rubocop//lib/rubocop/cop/ignored_node.rb#6
module RuboCop::Cop::IgnoredNode
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#7
  def ignore_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#26
  def ignored_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#11
  def part_of_ignored_node?(node); end

  private

  # source://rubocop//lib/rubocop/cop/ignored_node.rb#33
  def ignored_nodes; end
end

# This module encapsulates the ability to ignore certain lines when
# parsing.
#
# source://rubocop//lib/rubocop/cop/mixin/ignored_pattern.rb#7
module RuboCop::Cop::IgnoredPattern
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/ignored_pattern.rb#10
  def ignored_line?(line); end

  # source://rubocop//lib/rubocop/cop/mixin/ignored_pattern.rb#24
  def ignored_patterns; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/ignored_pattern.rb#20
  def matches_ignored_pattern?(line); end
end

# Common functionality for checking integer nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#6
module RuboCop::Cop::IntegerNode
  private

  # source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#9
  def integer_part(node); end
end

# This class auto-corrects lambda literal to method notation.
#
# source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#6
class RuboCop::Cop::LambdaLiteralToMethodCorrector
  # @return [LambdaLiteralToMethodCorrector] a new instance of LambdaLiteralToMethodCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#7
  def initialize(block_node); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#13
  def call(corrector); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#115
  def arg_to_unparenthesized_call?; end

  # Returns the value of attribute arguments.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def arguments; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#99
  def arguments_begin_pos; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#95
  def arguments_end_pos; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#107
  def block_begin; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#103
  def block_end; end

  # Returns the value of attribute block_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def block_node; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#56
  def insert_arguments(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#40
  def insert_separating_space(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#85
  def lambda_arg_string; end

  # Returns the value of attribute method.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def method; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#89
  def needs_separating_space?; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#50
  def remove_arguments(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#63
  def remove_leading_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#71
  def remove_trailing_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#33
  def remove_unparenthesized_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#76
  def replace_delimiters(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#46
  def replace_selector(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#111
  def selector_end; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#131
  def separating_space?; end
end

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#5
module RuboCop::Cop::Layout; end

# Modifiers should be indented as deep as method definitions, or as deep
# as the class/module keyword, depending on configuration.
#
# @example EnforcedStyle: indent (default)
#   # bad
#   class Plumbus
#   private
#   def smooth; end
#   end
#
#   # good
#   class Plumbus
#   private
#   def smooth; end
#   end
# @example EnforcedStyle: outdent
#   # bad
#   class Plumbus
#   private
#   def smooth; end
#   end
#
#   # good
#   class Plumbus
#   private
#   def smooth; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#34
class RuboCop::Cop::Layout::AccessModifierIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#60
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#56
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#41
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#51
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#46
  def on_sclass(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#66
  def check_body(body, node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#76
  def check_modifier(send_node, end_range); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#97
  def expected_indent_offset; end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#93
  def message(node); end

  # An offset that is not expected, but correct if the configuration is
  # changed.
  #
  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#103
  def unexpected_indent_offset; end
end

# source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#39
RuboCop::Cop::Layout::AccessModifierIndentation::MSG = T.let(T.unsafe(nil), String)

# Here we check if the elements of a multi-line array literal are
# aligned.
#
# @example
#   # bad
#   a = [1, 2, 3,
#   4, 5, 6]
#   array = ['run',
#   'forrest',
#   'run']
#
#   # good
#   a = [1, 2, 3,
#   4, 5, 6]
#   a = ['run',
#   'forrest',
#   'run']
#
# source://rubocop//lib/rubocop/cop/layout/align_array.rb#23
class RuboCop::Cop::Layout::AlignArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/align_array.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_array.rb#29
  def on_array(node); end
end

# source://rubocop//lib/rubocop/cop/layout/align_array.rb#26
RuboCop::Cop::Layout::AlignArray::MSG = T.let(T.unsafe(nil), String)

# Check that the keys, separators, and values of a multi-line hash
# literal are aligned according to configuration. The configuration
# options are:
#
#   - key (left align keys, one space before hash rockets and values)
#   - separator (align hash rockets and colons, right align keys)
#   - table (left align keys, hash rockets, and values)
#
# The treatment of hashes passed as the last argument to a method call
# can also be configured. The options are:
#
#   - always_inspect
#   - always_ignore
#   - ignore_implicit (without curly braces)
#   - ignore_explicit (with curly braces)
#
# @example EnforcedLastArgumentHashStyle: ignore_explicit
#   # Ignore only explicit hashes.
#
#   # bad
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
# @example EnforcedHashRocketStyle: separator
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#   {
#   :foo => bar,
#   :ba  => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba => baz
#   }
# @example EnforcedHashRocketStyle: table
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba  => baz
#   }
# @example EnforcedColonStyle: key (default)
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#   {
#   foo: bar,
#   ba:  baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba: baz
#   }
# @example EnforcedColonStyle: separator
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba: baz
#   }
# @example EnforcedColonStyle: table
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba:  baz
#   }
# @example EnforcedLastArgumentHashStyle: always_inspect (default)
#   # Inspect both implicit and explicit hashes.
#
#   # bad
#   do_something(foo: 1,
#   bar: 2)
#
#   # bad
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something(
#   foo: 1,
#   bar: 2
#   )
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something({
#   foo: 1,
#   bar: 2
#   })
# @example EnforcedLastArgumentHashStyle: always_ignore
#   # Ignore both implicit and explicit hashes.
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
# @example EnforcedLastArgumentHashStyle: ignore_implicit
#   # Ignore only implicit hashes.
#
#   # bad
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
# @example EnforcedHashRocketStyle: key (default)
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#   {
#   :foo => bar,
#   :ba  => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba => baz
#   }
#
# source://rubocop//lib/rubocop/cop/layout/align_hash.rb#176
class RuboCop::Cop::Layout::AlignHash < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::HashAlignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#207
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#197
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#183
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#183
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#183
  def on_yield(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#300
  def adjust(corrector, delta, range); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#252
  def alignment_for(pair); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#265
  def alignment_for_colons; end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#260
  def alignment_for_hash_rockets; end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#230
  def check_pairs(node); end

  # Returns the value of attribute column_deltas.
  #
  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#224
  def column_deltas; end

  # Sets the attribute column_deltas
  #
  # @param value the value to set the attribute column_deltas to.
  #
  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#224
  def column_deltas=(_arg0); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#274
  def correct_key_value(key_delta, key, value, separator); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#270
  def correct_no_value(key_delta, key); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#226
  def double_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#309
  def good_alignment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#243
  def ignore_hash_argument?(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_hash.rb#291
  def new_alignment(key); end
end

# source://rubocop//lib/rubocop/cop/layout/align_hash.rb#180
RuboCop::Cop::Layout::AlignHash::MSG = T.let(T.unsafe(nil), String)

# Here we check if the parameters on a multi-line method call or
# definition are aligned.
#
# @example EnforcedStyle: with_first_parameter (default)
#   # good
#
#   foo :bar,
#   :baz
#
#   # bad
#
#   foo :bar,
#   :baz
# @example EnforcedStyle: with_fixed_indentation
#   # good
#
#   foo :bar,
#   :baz
#
#   # bad
#
#   foo :bar,
#   :baz
#
# source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#30
class RuboCop::Cop::Layout::AlignParameters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#49
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#39
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#39
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#39
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#39
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#70
  def base_column(node, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#66
  def fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#55
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#81
  def target_method_lineno(node); end
end

# source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#33
RuboCop::Cop::Layout::AlignParameters::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/align_parameters.rb#36
RuboCop::Cop::Layout::AlignParameters::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the end keywords are aligned properly for do
# end blocks.
#
# Three modes are supported through the `EnforcedStyleAlignWith`
# configuration parameter:
#
# `start_of_block` : the `end` shall be aligned with the
# start of the line where the `do` appeared.
#
# `start_of_line` : the `end` shall be aligned with the
# start of the line where the expression started.
#
# `either` (which is the default) : the `end` is allowed to be in either
# location. The autofixer will default to `start_of_line`.
#
# @example EnforcedStyleAlignWith: either (default)
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   variable = lambda do |i|
#   i
#   end
# @example EnforcedStyleAlignWith: start_of_block
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   foo.bar
#   .each do
#   baz
#   end
# @example EnforcedStyleAlignWith: start_of_line
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   foo.bar
#   .each do
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#64
class RuboCop::Cop::Layout::BlockAlignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#87
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#70
  def block_end_align_target?(node = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#79
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#83
  def style_parameter_name; end

  private

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#233
  def add_space_before(loc, delta); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#209
  def alt_start_msg(start_loc, source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#112
  def block_end_align_target(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#132
  def check_block_alignment(start_node, block_node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#181
  def compute_do_source_line_column(node, end_loc); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#225
  def compute_start_col(ancestor_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#127
  def disqualified_parent?(parent, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#122
  def end_align_target?(node, parent); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#169
  def format_message(start_loc, end_loc, do_source_line_column, error_source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#220
  def format_source_line_column(source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#201
  def loc_to_source_line_column(loc); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#152
  def register_offense(block_node, start_loc, end_loc, do_source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#237
  def remove_space_before(end_pos, delta); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#102
  def start_for_block_node(block_node); end
end

# source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#68
RuboCop::Cop::Layout::BlockAlignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the end statement of a do..end block
# is on its own line.
#
# @example
#   # bad
#   blah do |i|
#   foo(i) end
#
#   # good
#   blah do |i|
#   foo(i)
#   end
#
#   # bad
#   blah { |i|
#   foo(i) }
#
#   # good
#   blah { |i|
#   foo(i)
#   }
#
# source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#27
class RuboCop::Cop::Layout::BlockEndNewline < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#33
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#55
  def delimiter_range(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#51
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#30
RuboCop::Cop::Layout::BlockEndNewline::MSG = T.let(T.unsafe(nil), String)

# This cop checks how the *when*s of a *case* expression
# are indented in relation to its *case* or *end* keyword.
#
# It will register a separate offense for each misaligned *when*.
#
# @example
#   # If Layout/EndAlignment is set to keyword style (default)
#   # *case* and *end* should always be aligned to same depth,
#   # and therefore *when* should always be aligned to both -
#   # regardless of configuration.
#
#   # bad for all styles
#   case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   # good for all styles
#   case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
# @example EnforcedStyle: case (default)
#   # if EndAlignment is set to other style such as
#   # start_of_line (as shown below), then *when* alignment
#   # configuration does have an effect.
#
#   # bad
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   # good
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
# @example EnforcedStyle: end
#   # bad
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   # good
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
# source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#70
class RuboCop::Cop::Layout::CaseIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#85
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#77
  def on_case(case_node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#135
  def base_column(case_node, base); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#97
  def check_when(when_node); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#116
  def incorrect_style(when_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#108
  def indent_one_step?; end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#112
  def indentation_width; end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#129
  def message(base); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#149
  def replacement(node); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#142
  def whitespace_range(node); end
end

# source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#75
RuboCop::Cop::Layout::CaseIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks if the code style follows the ExpectedOrder configuration:
#
# `Categories` allows us to map macro names into a category.
#
# Consider an example of code style that covers the following order:
# - Module inclusion (include, prepend, extend)
# - Constants
# - Associations (has_one, has_many)
# - Public attribute macros (attr_accessor, attr_writer, attr_reader)
# - Other macros (validates, validate)
# - Public class methods
# - Initializer
# - Public instance methods
# - Protected attribute macros (attr_accessor, attr_writer, attr_reader)
# - Protected instance methods
# - Private attribute macros (attr_accessor, attr_writer, attr_reader)
# - Private instance methods
#
# You can configure the following order:
#
# ```yaml
#  Layout/ClassStructure:
#    ExpectedOrder:
#      - module_inclusion
#      - constants
#      - association
#      - public_attribute_macros
#      - public_delegate
#      - macros
#      - public_class_methods
#      - initializer
#      - public_methods
#      - protected_attribute_macros
#      - protected_methods
#      - private_attribute_macros
#      - private_delegate
#      - private_methods
# ```
#
# Instead of putting all literals in the expected order, is also
# possible to group categories of macros. Visibility levels are handled
# automatically.
#
# ```yaml
#  Layout/ClassStructure:
#    Categories:
#      association:
#        - has_many
#        - has_one
#      attribute_macros:
#        - attr_accessor
#        - attr_reader
#        - attr_writer
#      macros:
#        - validates
#        - validate
#      module_inclusion:
#        - include
#        - prepend
#        - extend
# ```
#
# @example
#   # bad
#   # Expect extend be before constant
#   class Person < ApplicationRecord
#   has_many :orders
#   ANSWER = 42
#
#   extend SomeModule
#   include AnotherModule
#   end
#
#   # good
#   class Person
#   # extend and include go first
#   extend SomeModule
#   include AnotherModule
#
#   # inner classes
#   CustomError = Class.new(StandardError)
#
#   # constants are next
#   SOME_CONSTANT = 20
#
#   # afterwards we have public attribute macros
#   attr_reader :name
#
#   # followed by other macros (if any)
#   validates :name
#
#   # then we have public delegate macros
#   delegate :to_s, to: :name
#
#   # public class methods are next in line
#   def self.some_method
#   end
#
#   # initialization goes between class methods and instance methods
#   def initialize
#   end
#
#   # followed by other public instance methods
#   def some_method
#   end
#
#   # protected attribute macros and methods go next
#   protected
#
#   attr_reader :protected_name
#
#   def some_protected_method
#   end
#
#   # private attribute macros, delegate macros and methods
#   # are grouped near the end
#   private
#
#   attr_reader :private_name
#
#   delegate :some_private_delegate, to: :name
#
#   def some_private_method
#   end
#   end
# @see https://github.com/rubocop-hq/ruby-style-guide#consistent-classes
#
# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#133
class RuboCop::Cop::Layout::ClassStructure < ::RuboCop::Cop::Cop
  # Autocorrect by swapping between two nodes autocorrecting them
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#165
  def autocorrect(node); end

  # Validates code style on class declaration.
  # Add offense when find a node out of expected order.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#151
  def on_class(class_node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#145
  def visibility_block?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#303
  def begin_pos_with_comment(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#322
  def buffer; end

  # Setting categories hash allow you to group methods in group to match
  # in the {expected_order}.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#334
  def categories; end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#225
  def class_elements(class_node); end

  # Classifies a node to match with something in the {expected_order}
  #
  # @param node to be analysed
  # @return String when the node type is a `:block` then
  #   {classify} recursively with the first children
  # @return String when the node type is a `:send` then {find_category}
  #   by method name
  # @return String otherwise trying to {humanize_node} of the current node
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#190
  def classify(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#298
  def end_position_for(node); end

  # Load expected order from `ExpectedOrder` config.
  # Define new terms in the expected order by adding new {categories}.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#328
  def expected_order; end

  # Categorize a node according to the {expected_order}
  # Try to match {categories} values against the node's method_name given
  # also its visibility.
  #
  # @param node to be analysed.
  # @return [String] with the key category or the `method_name` as string
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#208
  def find_category(node); end

  # Navigate to find the last protected method
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#254
  def find_visibility_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#247
  def find_visibility_start(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#274
  def humanize_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#236
  def ignore?(classification); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#270
  def left_siblings_of(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#242
  def node_visibility(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#266
  def right_siblings_of(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#262
  def siblings_of(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#284
  def source_range_with_comment(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#318
  def start_line_position(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#216
  def walk_over_nested_class_definition(class_node); end
end

# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#134
RuboCop::Cop::Layout::ClassStructure::HUMANIZED_NODE_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#142
RuboCop::Cop::Layout::ClassStructure::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#141
RuboCop::Cop::Layout::ClassStructure::VISIBILITY_SCOPES = T.let(T.unsafe(nil), Array)

# Checks the indentation of here document closings.
#
# @example
#
#   # bad
#   class Foo
#   def bar
#   <<~SQL
#   'Hi'
#   SQL
#   end
#   end
#
#   # good
#   class Foo
#   def bar
#   <<~SQL
#   'Hi'
#   SQL
#   end
#   end
#
#   # bad
#
#   # heredoc contents is before closing heredoc.
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
#   # good
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
#   # good
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#49
class RuboCop::Cop::Layout::ClosingHeredocIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Heredoc

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#65
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#57
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#77
  def argument_indentation_correct?(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#85
  def closing_indentation(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#104
  def find_node_used_heredoc_argument(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#93
  def heredoc_closing(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#89
  def heredoc_opening(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#120
  def indent_level(source_line); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#97
  def indented_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#112
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#73
  def opening_indentation(node); end
end

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#53
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#54
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG_ARG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#52
RuboCop::Cop::Layout::ClosingHeredocIndentation::SIMPLE_HEREDOC = T.let(T.unsafe(nil), String)

# This cop checks the indentation of hanging closing parentheses in
# method calls, method definitions, and grouped expressions. A hanging
# closing parenthesis means `)` preceded by a line break.
#
# @example
#
#   # bad
#   some_method(
#   a,
#   b
#   )
#
#   some_method(
#   a, b
#   )
#
#   some_method(a, b, c
#   )
#
#   some_method(a,
#   b,
#   c
#   )
#
#   some_method(a,
#   x: 1,
#   y: 2
#   )
#
#   # Scenario 1: When First Parameter Is On Its Own Line
#
#   # good: when first param is on a new line, right paren is *always*
#   #       outdented by IndentationWidth
#   some_method(
#   a,
#   b
#   )
#
#   # good
#   some_method(
#   a, b
#   )
#
#   # Scenario 2: When First Parameter Is On The Same Line
#
#   # good: when all other params are also on the same line, outdent
#   #       right paren by IndentationWidth
#   some_method(a, b, c
#   )
#
#   # good: when all other params are on multiple lines, but are lined
#   #       up, align right paren with left paren
#   some_method(a,
#   b,
#   c
#   )
#
#   # good: when other params are not lined up on multiple lines, outdent
#   #       right paren by IndentationWidth
#   some_method(a,
#   x: 1,
#   y: 2
#   )
#
# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#71
class RuboCop::Cop::Layout::ClosingParenthesisIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#92
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#83
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#78
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#87
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#87
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#78
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#159
  def all_elements_aligned?(elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#98
  def check(node, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#106
  def check_for_elements(node, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#125
  def check_for_no_elements(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#173
  def correct_column_candidates(node, left_paren); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#145
  def expected_column(left_paren, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#166
  def first_argument_line(elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#193
  def indentation_width; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#197
  def line_break_after_left_paren?(left_paren, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#181
  def message(correct_column, left_paren, right_paren); end
end

# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#76
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#74
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

# This cop checks the indentation of comments.
#
# @example
#   # bad
#   # comment here
#   def method_name
#   end
#
#   # comment here
#   a = 'hello'
#
#   # yet another comment
#   if true
#   true
#   end
#
#   # good
#   # comment here
#   def method_name
#   end
#
#   # comment here
#   a = 'hello'
#
#   # yet another comment
#   if true
#   true
#   end
#
# source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#35
class RuboCop::Cop::Layout::CommentIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#45
  def autocorrect(comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#41
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#77
  def autocorrect_one(comment); end

  # Corrects all comment lines that occur immediately before the given
  # comment and have the same indentation. This is to avoid a long chain
  # of correcting, saving the file, parsing and inspecting again, and
  # then correcting one more line, and so on.
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#57
  def autocorrect_preceding_comments(comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#81
  def check(comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#123
  def correct_indentation(next_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#134
  def less_indented?(line); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#118
  def line_after_comment(comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#105
  def message(column, correct_comment_indentation); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#113
  def own_line_comment?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#72
  def should_correct?(comment, column, line_no); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#138
  def two_alternatives?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#38
RuboCop::Cop::Layout::CommentIndentation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for conditions that are not on the same line as
# if/while/until.
#
# @example
#
#   # bad
#
#   if
#   some_condition
#   do_something
#   end
# @example
#
#   # good
#
#   if some_condition
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/condition_position.rb#25
class RuboCop::Cop::Layout::ConditionPosition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#28
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#38
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#34
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#44
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#50
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/layout/condition_position.rb#26
RuboCop::Cop::Layout::ConditionPosition::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the end keywords of method definitions are
# aligned properly.
#
# Two modes are supported through the EnforcedStyleAlignWith configuration
# parameter. If it's set to `start_of_line` (which is the default), the
# `end` shall be aligned with the start of the line where the `def`
# keyword is. If it's set to `def`, the `end` shall be aligned with the
# `def` keyword.
#
# @example EnforcedStyleAlignWith: start_of_line (default)
#   # bad
#
#   private def foo
#   end
#
#   # good
#
#   private def foo
#   end
# @example EnforcedStyleAlignWith: def
#   # bad
#
#   private def foo
#   end
#
#   # good
#
#   private def foo
#   end
#
# source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#36
class RuboCop::Cop::Layout::DefEndAlignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#64
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#42
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#42
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#47
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#40
RuboCop::Cop::Layout::DefEndAlignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks the . position in multi-line method calls.
#
# @example EnforcedStyle: leading (default)
#   # bad
#   something.
#   method
#
#   # good
#   something
#   .method
# @example EnforcedStyle: trailing
#   # bad
#   something
#   .method
#
#   # good
#   something.
#   method
#
# source://rubocop//lib/rubocop/cop/layout/dot_position.rb#25
class RuboCop::Cop::Layout::DotPosition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#39
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#28
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#28
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#99
  def ampersand_dot?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#87
  def correct_dot_position_style?(dot_line, selector_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#83
  def line_between?(first_line, second_line); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#54
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#65
  def proper_dot_position?(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#94
  def selector_range(node); end
end

# This cop checks the alignment of else keywords. Normally they should
# be aligned with an if/unless/while/until/begin/def keyword, but there
# are special cases when they should follow the same rules as the
# alignment of end.
#
# @example
#   # bad
#   if something
#   code
#   else
#   code
#   end
#
#   # bad
#   if something
#   code
#   elsif something
#   code
#   end
#
#   # good
#   if something
#   code
#   else
#   code
#   end
#
# source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#32
class RuboCop::Cop::Layout::ElseAlignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#62
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#56
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#39
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#50
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#93
  def base_for_method_definition(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#73
  def base_range_of_if(node, base); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#82
  def base_range_of_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#118
  def check_alignment(base_range, else_range); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#102
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#68
  def check_nested(node, base); end
end

# source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#37
RuboCop::Cop::Layout::ElseAlignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks empty comment.
#
# @example
#   # bad
#
#   #
#   class Foo
#   end
#
#   # good
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
# @example AllowBorderComment: true (default)
#   # good
#
#   def foo
#   end
#
#   #################
#
#   def bar
#   end
# @example AllowBorderComment: false
#   # bad
#
#   def foo
#   end
#
#   #################
#
#   def bar
#   end
# @example AllowMarginComment: true (default)
#   # good
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
# @example AllowMarginComment: false
#   # bad
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#63
class RuboCop::Cop::Layout::EmptyComment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#88
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#68
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#136
  def allow_border_comment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#140
  def allow_margin_comment?; end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#132
  def comment_text(comment); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#105
  def concat_consecutive_comments(comments); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#144
  def current_token(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#122
  def empty_comment_only?(comment_text); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#152
  def previous_token(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#66
RuboCop::Cop::Layout::EmptyComment::MSG = T.let(T.unsafe(nil), String)

# This cop enforces empty line after guard clause
#
# @example
#
#   # bad
#   def foo
#   return if need_return?
#   bar
#   end
#
#   # good
#   def foo
#   return if need_return?
#
#   bar
#   end
#
#   # good
#   def foo
#   return if something?
#   return if something_different?
#
#   bar
#   end
#
#   # also good
#   def foo
#   if something?
#   do_something
#   return if need_return?
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#38
class RuboCop::Cop::Layout::EmptyLineAfterGuardClause < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#60
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#44
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#81
  def contains_guard_clause?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#74
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#124
  def heredoc_line(node, heredoc_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#120
  def last_argument(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#110
  def last_argument_is_heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#85
  def next_line_empty?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#89
  def next_line_rescue_or_ensure?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#103
  def next_sibling_empty_or_guard_clause?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#94
  def next_sibling_parent_empty_or_else?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#132
  def offense_location(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#42
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::END_OF_HEREDOC_LINE = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#41
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::MSG = T.let(T.unsafe(nil), String)

# Checks for a newline after the final magic comment.
#
# @example
#   # good
#   # frozen_string_literal: true
#
#   # Some documentation for Person
#   class Person
#   # Some code
#   end
#
#   # bad
#   # frozen_string_literal: true
#   # Some documentation for Person
#   class Person
#   # Some code
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#23
class RuboCop::Cop::Layout::EmptyLineAfterMagicComment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#39
  def autocorrect(token); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#28
  def investigate(source); end

  private

  # Find the last magic comment in the source file.
  #
  # Take all comments that precede the first line of code, select the
  # magic comments, and return the last magic comment in the file.
  #
  # @return [Parser::Source::Comment] if magic comments exist before code
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#54
  def last_magic_comment(source); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#26
RuboCop::Cop::Layout::EmptyLineAfterMagicComment::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether method definitions are
# separated by one empty line.
#
# `NumberOfEmptyLines` can be an integer (default is 1) or
# an array (e.g. [1, 2]) to specify a minimum and maximum
# number of empty lines permitted.
#
# `AllowAdjacentOneLineDefs` configures whether adjacent
# one-line method definitions are considered an offense.
#
# @example
#
#   # bad
#   def a
#   end
#   def b
#   end
# @example
#
#   # good
#   def a
#   end
#
#   def b
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#32
class RuboCop::Cop::Layout::EmptyLineBetweenDefs < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#62
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#53
  def check_defs(nodes); end

  # We operate on `begin` nodes, instead of using `OnMethodDef`,
  # so that we can walk over pairs of consecutive nodes and
  # efficiently access a node's predecessor; #prev_node ends up
  # doing a linear scan over siblings, so we don't want to call
  # it on each def.
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#46
  def on_begin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#141
  def autocorrect_insert_lines(newline_pos, count); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#133
  def autocorrect_remove_lines(newline_pos, count); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#96
  def blank_lines_between?(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#101
  def blank_lines_count_between(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#129
  def def_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#81
  def def_node?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#125
  def def_start(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#119
  def lines_between_defs(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#109
  def maximum_empty_lines; end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#105
  def minimum_empty_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#87
  def multiple_blank_lines_groups?(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#113
  def prev_node(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#37
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#35
RuboCop::Cop::Layout::EmptyLineBetweenDefs::MSG = T.let(T.unsafe(nil), String)

# This cop checks for two or more consecutive blank lines.
#
# @example
#
#   # bad - It has two empty lines.
#   some_method
#   # one empty line
#   # two empty lines
#   some_method
#
#   # good
#   some_method
#   # one empty line
#   some_method
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#23
class RuboCop::Cop::Layout::EmptyLines < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#42
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#29
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#48
  def each_extra_empty_line(lines); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#66
  def exceeds_line_offset?(line_diff); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#70
  def previous_and_current_lines_empty?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#27
RuboCop::Cop::Layout::EmptyLines::LINE_OFFSET = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#26
RuboCop::Cop::Layout::EmptyLines::MSG = T.let(T.unsafe(nil), String)

# Access modifiers should be surrounded by blank lines.
#
# @example
#
#   # bad
#   class Foo
#   def bar; end
#   private
#   def baz; end
#   end
#
#   # good
#   class Foo
#   def bar; end
#
#   private
#
#   def baz; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#25
class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # @return [EmptyLinesAroundAccessModifier] a new instance of EmptyLinesAroundAccessModifier
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#32
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#73
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#61
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#38
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#49
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#54
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#65
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#121
  def block_start?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#127
  def body_end?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#115
  def class_def?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#110
  def empty_lines_around?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#133
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#104
  def next_line_empty?(last_send_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#95
  def previous_line_empty?(send_line); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#89
  def previous_line_ignoring_comments(processed_source, send_line); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#28
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#29
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_AND_AFTER = T.let(T.unsafe(nil), String)

# This cop checks if empty lines exist around the arguments
# of a method invocation.
#
# @example
#   # bad
#   do_something(
#   foo
#
#   )
#
#   process(bar,
#
#   baz: qux,
#   thud: fred)
#
#   some_method(
#
#   [1,2,3],
#   x: y
#   )
#
#   # good
#   do_something(
#   foo
#   )
#
#   process(bar,
#   baz: qux,
#   thud: fred)
#
#   some_method(
#   [1,2,3],
#   x: y
#   )
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#41
class RuboCop::Cop::Layout::EmptyLinesAroundArguments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#53
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#46
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#46
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#61
  def empty_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#67
  def extra_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#89
  def inner_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#80
  def line_numbers(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#93
  def outer_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#74
  def processed_lines(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#44
RuboCop::Cop::Layout::EmptyLinesAroundArguments::MSG = T.let(T.unsafe(nil), String)

# This cop checks if empty lines exist around the bodies of begin-end
# blocks.
#
# @example
#
#   # good
#
#   begin
#   # ...
#   end
#
#   # bad
#
#   begin
#
#   # ...
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#24
class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#29
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#39
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#27
RuboCop::Cop::Layout::EmptyLinesAroundBeginBody::KIND = T.let(T.unsafe(nil), String)

# This cop checks if empty lines around the bodies of blocks match
# the configuration.
#
# @example EnforcedStyle: empty_lines
#   # good
#
#   foo do |bar|
#
#   # ...
#
#   end
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   foo do |bar|
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#24
class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#29
  def on_block(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#27
RuboCop::Cop::Layout::EmptyLinesAroundBlockBody::KIND = T.let(T.unsafe(nil), String)

# Common functionality for checking if presence/absence of empty lines
# around some kind of body matches the configuration.
#
# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#8
module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#21
  def constant_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#22
  def empty_line_required?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#24
  def check(node, body, adjusted_first_line: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#79
  def check_beginning(style, first_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#65
  def check_both(style, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#106
  def check_deferred_empty_line(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#41
  def check_empty_lines_except_namespace(body, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#49
  def check_empty_lines_special(body, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#83
  def check_ending(style, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#98
  def check_line(style, line, msg); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#87
  def check_source(style, line_no, desc); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#159
  def deferred_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#132
  def first_child_requires_empty_line?(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#140
  def first_empty_line_required_child(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#155
  def message(type, desc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#122
  def namespace?(body, with_one_child: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#148
  def previous_line_ignoring_comments(send_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#163
  def valid_body_style?(body); end
end

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#16
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_DEFERRED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#13
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_EXTRA = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#15
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_MISSING = T.let(T.unsafe(nil), String)

# This cop checks if empty lines around the bodies of classes match
# the configuration.
#
# @example EnforcedStyle: empty_lines
#   # good
#
#   class Foo
#
#   def bar
#   # ...
#   end
#
#   end
# @example EnforcedStyle: empty_lines_except_namespace
#   # good
#
#   class Foo
#   class Bar
#
#   # ...
#
#   end
#   end
# @example EnforcedStyle: empty_lines_special
#   # good
#   class Foo
#
#   def bar; end
#
#   end
# @example Enforcedstyle: beginning_only
#   # good
#
#   class Foo
#
#   def bar
#   # ...
#   end
#   end
# @example Enforcedstyle: ending_only
#   # good
#
#   class Foo
#   def bar
#   # ...
#   end
#
#   end
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   class Foo
#   def bar
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#67
class RuboCop::Cop::Layout::EmptyLinesAroundClassBody < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#85
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#72
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#80
  def on_sclass(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#70
RuboCop::Cop::Layout::EmptyLinesAroundClassBody::KIND = T.let(T.unsafe(nil), String)

# This cop checks if empty lines exist around the bodies of `begin`
# sections. This cop doesn't check empty lines at `begin` body
# beginning/end and around method definition body.
# `Style/EmptyLinesAroundBeginBody` or `Style/EmptyLinesAroundMethodBody`
# can be used for this purpose.
#
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue
#   do_something2
#   else
#   do_something3
#   ensure
#   do_something4
#   end
#
#   # good
#
#   def foo
#   do_something
#   rescue
#   do_something2
#   end
#
#   # bad
#
#   begin
#   do_something
#
#   rescue
#
#   do_something2
#
#   else
#
#   do_something3
#
#   ensure
#
#   do_something4
#   end
#
#   # bad
#
#   def foo
#   do_something
#
#   rescue
#
#   do_something2
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#61
class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#76
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#66
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#66
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#71
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#82
  def check_body(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#105
  def keyword_locations(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#126
  def keyword_locations_in_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#118
  def keyword_locations_in_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#97
  def message(location, keyword); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#101
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#64
RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords::MSG = T.let(T.unsafe(nil), String)

# This cop checks if empty lines exist around the bodies of methods.
#
# @example
#
#   # good
#
#   def foo
#   # ...
#   end
#
#   # bad
#
#   def bar
#
#   # ...
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#23
class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#28
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#28
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#39
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#26
RuboCop::Cop::Layout::EmptyLinesAroundMethodBody::KIND = T.let(T.unsafe(nil), String)

# This cop checks if empty lines around the bodies of modules match
# the configuration.
#
# @example EnforcedStyle: empty_lines
#   # good
#
#   module Foo
#
#   def bar
#   # ...
#   end
#
#   end
# @example EnforcedStyle: empty_lines_except_namespace
#   # good
#
#   module Foo
#   module Bar
#
#   # ...
#
#   end
#   end
# @example EnforcedStyle: empty_lines_special
#   # good
#   module Foo
#
#   def bar; end
#
#   end
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   module Foo
#   def bar
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#47
class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#57
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#52
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#50
RuboCop::Cop::Layout::EmptyLinesAroundModuleBody::KIND = T.let(T.unsafe(nil), String)

# This cop checks whether the end keywords are aligned properly.
#
# Three modes are supported through the `EnforcedStyleAlignWith`
# configuration parameter:
#
# If it's set to `keyword` (which is the default), the `end`
# shall be aligned with the start of the keyword (if, class, etc.).
#
# If it's set to `variable` the `end` shall be aligned with the
# left-hand-side of the variable assignment, if there is one.
#
# If it's set to `start_of_line`, the `end` shall be aligned with the
# start of the line where the matching keyword appears.
#
# @example EnforcedStyleAlignWith: keyword (default)
#   # bad
#
#   variable = if true
#   end
#
#   # good
#
#   variable = if true
#   end
#
#   variable =
#   if true
#   end
# @example EnforcedStyleAlignWith: variable
#   # bad
#
#   variable = if true
#   end
#
#   # good
#
#   variable = if true
#   end
#
#   variable =
#   if true
#   end
# @example EnforcedStyleAlignWith: start_of_line
#   # bad
#
#   variable = if true
#   end
#
#   puts(if true
#   end)
#
#   # good
#
#   variable = if true
#   end
#
#   puts(if true
#   end)
#
#   variable =
#   if true
#   end
#
# source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#70
class RuboCop::Cop::Layout::EndAlignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#103
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#95
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#75
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#83
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#79
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#91
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#87
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#152
  def alignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#162
  def alignment_node_for_variable_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#133
  def asgn_variable_align_with(outer_node, inner_node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#122
  def check_asgn_alignment(outer_node, inner_node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#111
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#143
  def check_other_alignment(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#177
  def start_line_range(node); end
end

# This cop checks for Windows-style line endings in the source code.
#
# @example EnforcedStyle: native (default)
#   # The `native` style means that CR+LF (Carriage Return + Line Feed) is
#   # enforced on Windows, and LF is enforced on other platforms.
#
#   # bad
#   puts 'Hello' # Return character is LF on Windows.
#   puts 'Hello' # Return character is CR+LF on other than Windows.
#
#   # good
#   puts 'Hello' # Return character is CR+LF on Windows.
#   puts 'Hello' # Return character is LF on other than Windows.
# @example EnforcedStyle: lf
#   # The `lf` style means that LF (Line Feed) is enforced on
#   # all platforms.
#
#   # bad
#   puts 'Hello' # Return character is CR+LF on all platfoms.
#
#   # good
#   puts 'Hello' # Return character is LF on all platfoms.
# @example EnforcedStyle: crlf
#   # The `crlf` style means that CR+LF (Carriage Return + Line Feed) is
#   # enforced on all platforms.
#
#   # bad
#   puts 'Hello' # Return character is LF on all platfoms.
#
#   # good
#   puts 'Hello' # Return character is CR+LF on all platfoms.
#
# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#40
class RuboCop::Cop::Layout::EndOfLine < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#47
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#73
  def offense_message(line); end

  # If there is no LF on the last line, we don't care if there's no CR.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#69
  def unimportant_missing_cr?(index, last_line, line); end
end

# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#44
RuboCop::Cop::Layout::EndOfLine::MSG_DETECTED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#45
RuboCop::Cop::Layout::EndOfLine::MSG_MISSING = T.let(T.unsafe(nil), String)

# This cop checks for extra/unnecessary whitespace.
#
# @example
#
#   # good if AllowForAlignment is true
#   name      = "RuboCop"
#   # Some comment and an empty line
#
#   website  += "/rubocop-hq/rubocop" unless cond
#   puts        "rubocop"          if     debug
#
#   # bad for any configuration
#   set_app("RuboCop")
#   website  = "https://github.com/rubocop-hq/rubocop"
#
#   # good only if AllowBeforeTrailingComments is true
#   object.method(arg)  # this is a comment
#
#   # good even if AllowBeforeTrailingComments is false or not set
#   object.method(arg) # this is a comment
#
#   # good with either AllowBeforeTrailingComments or AllowForAlignment
#   object.method(arg)         # this is a comment
#   another_object.method(arg) # this is another comment
#   some_object.method(arg)    # this is some comment
#
# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#33
class RuboCop::Cop::Layout::ExtraSpacing < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#56
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#41
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#225
  def align_column(asgn_token); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#200
  def align_equal_sign(corrector, token, align_to); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#190
  def align_equal_signs(range, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#166
  def aligned_comments?(comment_token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#136
  def aligned_tok?(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#177
  def aligned_with_next_comment?(index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#173
  def aligned_with_previous_comment?(index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#240
  def allow_for_trailing_comments?; end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#68
  def assignment_tokens; end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#92
  def check_assignment(token); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#111
  def check_other(token1, token2, ast); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#79
  def check_tokens(ast, token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#182
  def comment_column(index); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#212
  def contiguous_assignment_lines(range); end

  # @yield [range_between(start_pos, end_pos)]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#124
  def extra_space_range(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#186
  def force_equal_sign_alignment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#144
  def ignored_range?(ast, start_pos); end

  # Returns an array of ranges that should not be reported. It's the
  # extra spaces between the keys and values in a multiline hash,
  # since those are handled by the Style/AlignHash cop.
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#155
  def ignored_ranges(ast); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#234
  def remove_optarg_equals(asgn_tokens, processed_source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#107
  def should_aligned_with_preceding_line?(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#148
  def unary_plus_non_offense?(range); end
end

# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#38
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNALIGNED_ASGN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#37
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# This cop checks for a line break before the first element in a
# multi-line array.
#
# @example
#
#   # bad
#   [ :a,
#   :b]
#
#   # good
#   [
#   :a,
#   :b]
#
# source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#20
class RuboCop::Cop::Layout::FirstArrayElementLineBreak < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FirstElementLineBreak

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#32
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#26
  def on_array(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#38
  def assignment_on_same_line?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#23
RuboCop::Cop::Layout::FirstArrayElementLineBreak::MSG = T.let(T.unsafe(nil), String)

# This cop checks for a line break before the first element in a
# multi-line hash.
#
# @example
#
#   # bad
#   { a: 1,
#   b: 2}
#
#   # good
#   {
#   a: 1,
#   b: 2 }
#
# source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#19
class RuboCop::Cop::Layout::FirstHashElementLineBreak < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FirstElementLineBreak

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#25
  def on_hash(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#22
RuboCop::Cop::Layout::FirstHashElementLineBreak::MSG = T.let(T.unsafe(nil), String)

# This cop checks for a line break before the first argument in a
# multi-line method call.
#
# @example
#
#   # bad
#   method(foo, bar,
#   baz)
#
#   # good
#   method(
#   foo, bar,
#   baz)
#
#   # ignored
#   method foo, bar,
#   baz
#
# source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#23
class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FirstElementLineBreak

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#48
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#29
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#26
RuboCop::Cop::Layout::FirstMethodArgumentLineBreak::MSG = T.let(T.unsafe(nil), String)

# This cop checks for a line break before the first parameter in a
# multi-line method parameter definition.
#
# @example
#
#   # bad
#   def method(foo, bar,
#   baz)
#   do_something
#   end
#
#   # good
#   def method(
#   foo, bar,
#   baz)
#   do_something
#   end
#
#   # ignored
#   def method foo,
#   bar
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#29
class RuboCop::Cop::Layout::FirstMethodParameterLineBreak < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FirstElementLineBreak

  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#35
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#35
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#32
RuboCop::Cop::Layout::FirstMethodParameterLineBreak::MSG = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the first parameter in a method call.
# Parameters after the first one are checked by Layout/AlignParameters,
# not by this cop.
#
# @example
#
#   # bad
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: consistent
#   # The first parameter should always be indented one step more than the
#   # preceding line.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: consistent_relative_to_receiver
#   # The first parameter should always be indented one level relative to
#   # the parent that is receiving the parameter
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_params
# @example EnforcedStyle: special_for_inner_method_call
#   # The first parameter should normally be indented one step more than
#   # the preceding line, but if it's a parameter for a method call that
#   # is itself a parameter in a method call, then the inner parameter
#   # should be indented relative to the inner method.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: special_for_inner_method_call_in_parentheses (default)
#   # Same as `special_for_inner_method_call` except that the special rule
#   # only applies if the outer method call encloses its arguments in
#   # parentheses.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
#
# source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#142
class RuboCop::Cop::Layout::FirstParameterIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#159
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#204
  def eligible_method_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#150
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#150
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#181
  def base_indentation(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#208
  def base_range(send_node, arg_node); end

  # Returns the column of the given range. For single line ranges, this
  # is simple. For ranges with line breaks, we look a the last code line.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#215
  def column_of(range); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#165
  def message(arg_node); end

  # Takes the line number of a given code line and returns a string
  # containing the previous line that's not a comment line or a blank
  # line.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#227
  def previous_code_line(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#189
  def special_inner_call_indentation?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#148
RuboCop::Cop::Layout::FirstParameterIndentation::MSG = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the first element in an array literal
# where the opening bracket and the first element are on separate lines.
# The other elements' indentations are handled by the AlignArray cop.
#
# By default, array literals that are arguments in a method call with
# parentheses, and where the opening square bracket of the array is on the
# same line as the opening parenthesis of the method call, shall have
# their first element indented one step (two spaces) more than the
# position inside the opening parenthesis.
#
# Other array literals shall have their first element indented one step
# more than the start of the line where the opening square bracket is.
#
# This default style is called 'special_inside_parentheses'. Alternative
# styles are 'consistent' and 'align_brackets'. Here are examples:
#
# @example EnforcedStyle: special_inside_parentheses (default)
#   # The `special_inside_parentheses` style enforces that the first
#   # element in an array literal where the opening bracket and first
#   # element are on seprate lines is indented one step (two spaces) more
#   # than the position inside the opening parenthesis.
#
#   #bad
#   array = [
#   :value
#   ]
#   and_in_a_method_call([
#   :no_difference
#   ])
#
#   #good
#   array = [
#   :value
#   ]
#   but_in_a_method_call([
#   :its_like_this
#   ])
# @example EnforcedStyle: consistent
#   # The `consistent` style enforces that the first element in an array
#   # literal where the opening bracket and the first element are on
#   # seprate lines is indented the same as an array literal which is not
#   # defined inside a method call.
#
#   #bad
#   # consistent
#   array = [
#   :value
#   ]
#   but_in_a_method_call([
#   :its_like_this
#   ])
#
#   #good
#   array = [
#   :value
#   ]
#   and_in_a_method_call([
#   :no_difference
#   ])
# @example EnforcedStyle: align_brackets
#   # The `align_brackets` style enforces that the opening and closing
#   # brackets are indented to the same position.
#
#   #bad
#   # align_brackets
#   and_now_for_something = [
#   :completely_different
#   ]
#
#   #good
#   # align_brackets
#   and_now_for_something = [
#   :completely_different
#   ]
#
# source://rubocop//lib/rubocop/cop/layout/indent_array.rb#82
class RuboCop::Cop::Layout::IndentArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#101
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#90
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#94
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#94
  def on_send(node); end

  private

  # Returns the description of what the correct indentation is based on.
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#147
  def base_description(left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#107
  def brace_alignment_style; end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#111
  def check(array_node, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#126
  def check_right_bracket(right_bracket, left_bracket, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_array.rb#157
  def message(base_description); end
end

# source://rubocop//lib/rubocop/cop/layout/indent_array.rb#87
RuboCop::Cop::Layout::IndentArray::MSG = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the first line of the
# right-hand-side of a multi-line assignment.
#
# The indentation of the remaining lines can be corrected with
# other cops such as `IndentationConsistency` and `EndAlignment`.
#
# @example
#   # bad
#   value =
#   if foo
#   'bar'
#   end
#
#   # good
#   value =
#   if foo
#   'bar'
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indent_assignment.rb#24
class RuboCop::Cop::Layout::IndentAssignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/layout/indent_assignment.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_assignment.rb#31
  def check_assignment(node, rhs); end
end

# source://rubocop//lib/rubocop/cop/layout/indent_assignment.rb#28
RuboCop::Cop::Layout::IndentAssignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the first key in a hash literal
# where the opening brace and the first key are on separate lines. The
# other keys' indentations are handled by the AlignHash cop.
#
# By default, Hash literals that are arguments in a method call with
# parentheses, and where the opening curly brace of the hash is on the
# same line as the opening parenthesis of the method call, shall have
# their first key indented one step (two spaces) more than the position
# inside the opening parenthesis.
#
# Other hash literals shall have their first key indented one step more
# than the start of the line where the opening curly brace is.
#
# This default style is called 'special_inside_parentheses'. Alternative
# styles are 'consistent' and 'align_braces'. Here are examples:
#
# @example EnforcedStyle: special_inside_parentheses (default)
#   # The `special_inside_parentheses` style enforces that the first key
#   # in a hash literal where the opening brace and the first key are on
#   # separate lines is indented one step (two spaces) more than the
#   # position inside the opening parentheses.
#
#   # bad
#   hash = {
#   key: :value
#   }
#   and_in_a_method_call({
#   no: :difference
#   })
#
#   # good
#   special_inside_parentheses
#   hash = {
#   key: :value
#   }
#   but_in_a_method_call({
#   its_like: :this
#   })
# @example EnforcedStyle: consistent
#   # The `consistent` style enforces that the first key in a hash
#   # literal where the opening brace and the first key are on
#   # separate lines is indented the same as a hash literal which is not
#   # defined inside a method call.
#
#   # bad
#   hash = {
#   key: :value
#   }
#   but_in_a_method_call({
#   its_like: :this
#   })
#
#   # good
#   hash = {
#   key: :value
#   }
#   and_in_a_method_call({
#   no: :difference
#   })
# @example EnforcedStyle: align_braces
#   # The `align_brackets` style enforces that the opening and closing
#   # braces are indented to the same position.
#
#   # bad
#   and_now_for_something = {
#   completely: :different
#   }
#
#   # good
#   and_now_for_something = {
#   completely: :different
#   }
#
# source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#80
class RuboCop::Cop::Layout::IndentHash < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#99
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#92
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#88
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#92
  def on_send(node); end

  private

  # Returns the description of what the correct indentation is based on.
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#164
  def base_description(left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#105
  def brace_alignment_style; end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#109
  def check(hash_node, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#155
  def check_based_on_longest_key(hash_node, left_brace, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#129
  def check_right_brace(right_brace, left_brace, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#174
  def message(base_description); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#149
  def separator_style?(first_pair); end
end

# source://rubocop//lib/rubocop/cop/layout/indent_hash.rb#85
RuboCop::Cop::Layout::IndentHash::MSG = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the here document bodies. The bodies
# are indented one step.
# In Ruby 2.3 or newer, squiggly heredocs (`<<~`) should be used. If you
# use the older rubies, you should introduce some library to your project
# (e.g. ActiveSupport, Powerpack or Unindent).
# Note: When `Metrics/LineLength`'s `AllowHeredoc` is false (not default),
#       this cop does not add any offenses for long here documents to
#       avoid `Metrics/LineLength`'s offenses.
#
# @example EnforcedStyle: auto_detection (default)
#   # bad
#   <<-RUBY
#   something
#   RUBY
#
#   # good
#   # When using Ruby 2.3 or higher.
#   <<~RUBY
#   something
#   RUBY
#
#   # good
#   # When using Ruby 2.2 or lower and enabled Rails department.
#   # The following is possible to enable Rails department by
#   # adding for example:
#   #
#   # Rails:
#   #   Enabled: true
#   #
#   <<-RUBY.strip_heredoc
#   something
#   RUBY
# @example EnforcedStyle: squiggly
#   # good
#   # When EnforcedStyle is squiggly, bad code is auto-corrected to the
#   # following code.
#   <<~RUBY
#   something
#   RUBY
# @example EnforcedStyle: active_support
#   # good
#   # When EnforcedStyle is active_support, bad code is auto-corrected to
#   # the following code.
#   <<-RUBY.strip_heredoc
#   something
#   RUBY
# @example EnforcedStyle: powerpack
#   # good
#   # When EnforcedStyle is powerpack, bad code is auto-corrected to
#   # the following code.
#   <<-RUBY.strip_indent
#   something
#   RUBY
# @example EnforcedStyle: unindent
#   # good
#   # When EnforcedStyle is unindent, bad code is auto-corrected to
#   # the following code.
#   <<-RUBY.unindent
#   something
#   RUBY
#
# source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#71
class RuboCop::Cop::Layout::IndentHeredoc < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SafeMode

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#107
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#89
  def on_heredoc(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#217
  def adjust_minus(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#212
  def adjust_squiggly(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#262
  def base_indent_level(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#231
  def check_style!; end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#223
  def correct_by_library(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#200
  def correct_by_squiggly(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#284
  def heredoc_body(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#288
  def heredoc_end(node); end

  # Returns '~', '-' or nil
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#276
  def heredoc_indent_type(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#268
  def indent_level(str); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#280
  def indentation_width; end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#244
  def indented_body(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#251
  def indented_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#145
  def library_message(indentation_width, method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#176
  def line_too_long?(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#188
  def longest_line(lines); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#196
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#131
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#153
  def ruby23_message(indentation_width, current_indent_type); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#161
  def ruby23_type_message(indentation_width, current_indent_type); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#169
  def ruby23_width_message(indentation_width); end

  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#120
  def style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#192
  def unlimited_heredoc_length?; end
end

# source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#81
RuboCop::Cop::Layout::IndentHeredoc::LIBRARY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#76
RuboCop::Cop::Layout::IndentHeredoc::RUBY23_TYPE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#79
RuboCop::Cop::Layout::IndentHeredoc::RUBY23_WIDTH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/indent_heredoc.rb#83
RuboCop::Cop::Layout::IndentHeredoc::STRIP_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks for inconsistent indentation.
#
# The difference between `rails` and `normal` is that the `rails` style
# prescribes that in classes and modules the `protected` and `private`
# modifier keywords shall be indented the same as public methods and that
# protected and private members shall be indented one step more than the
# modifiers. Other than that, both styles mean that entities on the same
# logical depth shall have the same indentation.
#
# @example EnforcedStyle: normal (default)
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
# @example EnforcedStyle: rails
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#120
class RuboCop::Cop::Layout::IndentationConsistency < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#134
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#126
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#130
  def on_kwbegin(node); end

  private

  # Not all nodes define `bare_access_modifier?` (for example,
  # `RuboCop::AST::DefNode` does not), so we must check `send_type?` first
  # to avoid a NoMethodError.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#143
  def bare_access_modifier?(node); end

  # Returns an integer representing the correct indentation, or nil to
  # indicate that the correct indentation is that of the first child that
  # is not an access modifier.
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#150
  def base_column_for_normal_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#168
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#176
  def check_normal_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#183
  def check_rails_style(node); end
end

# source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#124
RuboCop::Cop::Layout::IndentationConsistency::MSG = T.let(T.unsafe(nil), String)

# This cop checks for indentation that doesn't use the specified number
# of spaces.
#
# See also the IndentationConsistency cop which is the companion to this
# one.
#
# @example
#   # bad
#   class A
#   def test
#   puts 'hello'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   end
#   end
# @example IgnoredPatterns: ['^\s*module']
#   # bad
#   module A
#   class B
#   def test
#   puts 'hello'
#   end
#   end
#   end
#
#   # good
#   module A
#   class B
#   def test
#   puts 'hello'
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#45
class RuboCop::Cop::Layout::IndentationWidth < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#57
  def access_modifier?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#161
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#81
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#145
  def on_case(case_node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#98
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#109
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#128
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#128
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#154
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#73
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#93
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#61
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#103
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#109
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#135
  def on_until(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#135
  def on_while(node, base = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#220
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#240
  def check_if(node, body, else_clause, base_loc); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#253
  def check_indentation(base_loc, body_node, style = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#167
  def check_members(base, members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#193
  def check_members_for_rails_style(members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#352
  def configured_indentation_width; end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#200
  def each_member(members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#216
  def indentation_consistency_style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#309
  def indentation_to_check?(base_loc, body_node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#356
  def leftmost_modifier_of(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#288
  def message(configured_indentation_width, indentation, name); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#335
  def offending_range(body_node, indentation); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#263
  def offense(body_node, indentation, style); end

  # Returns true if the given node is within another node that has
  # already been marked for auto-correction by this cop.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#299
  def other_offense_in_same_range?(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#183
  def select_check_member(member); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#320
  def skip_check?(base_loc, body_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#212
  def special_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#343
  def starts_with_access_modifier?(body_node); end
end

# source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#52
RuboCop::Cop::Layout::IndentationWidth::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#55
RuboCop::Cop::Layout::IndentationWidth::SPECIAL_MODIFIERS = T.let(T.unsafe(nil), Array)

# This cop checks for indentation of the first non-blank non-comment
# line in a file.
#
# @example
#   # bad
#   class A
#   def foo; end
#   end
#
#   # good
#   class A
#   def foo; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#20
class RuboCop::Cop::Layout::InitialIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#31
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#25
  def investigate(_processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#37
  def first_token; end

  # @yield [range_between(space_range.begin_pos, token.begin_pos)]
  #
  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#41
  def space_before(token); end
end

# source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#23
RuboCop::Cop::Layout::InitialIndentation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for unnecessary leading blank lines at the beginning
# of a file.
#
# @example
#
#   # bad
#   # (start of file)
#
#   class Foo
#   end
#
#   # bad
#   # (start of file)
#
#   # a comment
#
#   # good
#   # (start of file)
#   class Foo
#   end
#
#   # good
#   # (start of file)
#   # a comment
#
# source://rubocop//lib/rubocop/cop/layout/leading_blank_lines.rb#30
class RuboCop::Cop::Layout::LeadingBlankLines < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/leading_blank_lines.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/leading_blank_lines.rb#33
  def investigate(processed_source); end
end

# source://rubocop//lib/rubocop/cop/layout/leading_blank_lines.rb#31
RuboCop::Cop::Layout::LeadingBlankLines::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether comments have a leading space after the
# `#` denoting the start of the comment. The leading space is not
# required for some RDoc special syntax, like `#++`, `#--`,
# `#:nodoc`, `=begin`- and `=end` comments, "shebang" directives,
# or rackup options.
#
# @example
#
#   # bad
#   #Some comment
#
#   # good
#   # Some comment
#
# source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#19
class RuboCop::Cop::Layout::LeadingCommentSpace < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#33
  def autocorrect(comment); end

  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#24
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#42
  def allowed_on_first_line?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#54
  def rackup_config_file?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#50
  def rackup_options?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#46
  def shebang?(comment); end
end

# source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#22
RuboCop::Cop::Layout::LeadingCommentSpace::MSG = T.let(T.unsafe(nil), String)

# This cop checks that the closing brace in an array literal is either
# on the same line as the last array element or on a new line.
#
# When using the `symmetrical` (default) style:
#
# If an array's opening brace is on the same line as the first element
# of the array, then the closing brace should be on the same line as
# the last element of the array.
#
# If an array's opening brace is on the line above the first element
# of the array, then the closing brace should be on the line below
# the last element of the array.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line array literal must be on the line
# after the last element of the array.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line array literal must be on the same
# line as the last element of the array.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   [ :a,
#   :b
#   ]
#
#   # bad
#   [
#   :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b ]
#
#   # good
#   [
#   :a,
#   :b
#   ]
# @example EnforcedStyle: new_line
#   # bad
#   [
#   :a,
#   :b ]
#
#   # bad
#   [ :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b
#   ]
#
#   # good
#   [
#   :a,
#   :b
#   ]
# @example EnforcedStyle: same_line
#   # bad
#   [ :a,
#   :b
#   ]
#
#   # bad
#   [
#   :a,
#   :b
#   ]
#
#   # good
#   [
#   :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b ]
#
# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineArrayBraceLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout

  # source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#112
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#108
  def on_array(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#102
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#105
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#98
RuboCop::Cop::Layout::MultilineArrayBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#94
RuboCop::Cop::Layout::MultilineArrayBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# This cop checks whether the multiline assignments have a newline
# after the assignment operator.
#
# @example EnforcedStyle: new_line (default)
#   # bad
#   foo = if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   begin
#   compute
#   rescue => e
#   nil
#   end
# @example EnforcedStyle: same_line
#   # good
#   foo = if expression
#   'bar'
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#34
class RuboCop::Cop::Layout::MultilineAssignmentLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#75
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#45
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#54
  def check_by_enforced_style(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#63
  def check_new_line_offense(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#69
  def check_same_line_offense(node, rhs); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#89
  def supported_types; end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#39
RuboCop::Cop::Layout::MultilineAssignmentLayout::NEW_LINE_OFFENSE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#42
RuboCop::Cop::Layout::MultilineAssignmentLayout::SAME_LINE_OFFENSE = T.let(T.unsafe(nil), String)

# This cop checks whether the multiline do end blocks have a newline
# after the start of the block. Additionally, it checks whether the block
# arguments, if any, are on the same line as the start of the block.
#
# @example
#   # bad
#   blah do |i| foo(i)
#   bar(i)
#   end
#
#   # bad
#   blah do
#   |i| foo(i)
#   bar(i)
#   end
#
#   # good
#   blah do |i|
#   foo(i)
#   bar(i)
#   end
#
#   # bad
#   blah { |i| foo(i)
#   bar(i)
#   }
#
#   # good
#   blah { |i|
#   foo(i)
#   bar(i)
#   }
#
# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#38
class RuboCop::Cop::Layout::MultilineBlockLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#46
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#82
  def add_offense_for_expression(node, expr, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#77
  def args_on_beginning_line?(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#89
  def autocorrect_arguments(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#99
  def autocorrect_body(corrector, node, block_body); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#112
  def block_arg_string(args); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#43
RuboCop::Cop::Layout::MultilineBlockLayout::ARG_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#41
RuboCop::Cop::Layout::MultilineBlockLayout::MSG = T.let(T.unsafe(nil), String)

# This cop checks that the closing brace in a hash literal is either
# on the same line as the last hash element, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a hash's opening brace is on the same line as the first element
# of the hash, then the closing brace should be on the same line as
# the last element of the hash.
#
# If a hash's opening brace is on the line above the first element
# of the hash, then the closing brace should be on the line below
# the last element of the hash.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line hash literal must be on the line
# after the last element of the hash.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line hash literal must be on the same
# line as the last element of the hash.
#
# @example EnforcedStyle: symmetrical (default)
#
#   # bad
#   { a: 1,
#   b: 2
#   }
#   # bad
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2 }
#
#   # good
#   {
#   a: 1,
#   b: 2
#   }
# @example EnforcedStyle: new_line
#   # bad
#   {
#   a: 1,
#   b: 2 }
#
#   # bad
#   { a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2
#   }
#
#   # good
#   {
#   a: 1,
#   b: 2
#   }
# @example EnforcedStyle: same_line
#   # bad
#   { a: 1,
#   b: 2
#   }
#
#   # bad
#   {
#   a: 1,
#   b: 2
#   }
#
#   # good
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2 }
#
# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineHashBraceLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout

  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#116
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#112
  def on_hash(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#108
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#102
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#105
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#98
RuboCop::Cop::Layout::MultilineHashBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#94
RuboCop::Cop::Layout::MultilineHashBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# This cop checks that the closing brace in a method call is either
# on the same line as the last method argument, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a method call's opening brace is on the same line as the first
# argument of the call, then the closing brace should be on the same
# line as the last argument of the call.
#
# If an method call's opening brace is on the line above the first
# argument of the call, then the closing brace should be on the line
# below the last argument of the call.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line method call must be on the line
# after the last argument of the call.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line method call must be on the same
# line as the last argument of the call.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   foo(a,
#   b
#   )
#
#   # bad
#   foo(
#   a,
#   b)
#
#   # good
#   foo(a,
#   b)
#
#   # good
#   foo(
#   a,
#   b
#   )
# @example EnforcedStyle: new_line
#   # bad
#   foo(
#   a,
#   b)
#
#   # bad
#   foo(a,
#   b)
#
#   # good
#   foo(a,
#   b
#   )
#
#   # good
#   foo(
#   a,
#   b
#   )
# @example EnforcedStyle: same_line
#   # bad
#   foo(a,
#   b
#   )
#
#   # bad
#   foo(
#   a,
#   b
#   )
#
#   # good
#   foo(
#   a,
#   b)
#
#   # good
#   foo(a,
#   b)
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#112
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#108
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#118
  def children(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#122
  def ignored_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#126
  def single_line_ignoring_receiver?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#102
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#105
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#98
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#94
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the method name part in method calls
# that span more than one line.
#
# @example EnforcedStyle: aligned (default)
#   # bad
#   while myvariable
#   .b
#   # do something
#   end
#
#   # good
#   while myvariable
#   .b
#   # do something
#   end
#
#   # good
#   Thing.a
#   .b
#   .c
# @example EnforcedStyle: indented
#   # good
#   while myvariable
#   .b
#
#   # do something
#   end
# @example EnforcedStyle: indented_relative_to_receiver
#   # good
#   while myvariable
#   .a
#   .b
#
#   # do something
#   end
#
#   # good
#   myvariable = Thing
#   .a
#   .b
#   .c
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#49
class RuboCop::Cop::Layout::MultilineMethodCallIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#64
  def autocorrect(node); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#54
  def validate_config; end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#119
  def align_with_base_message(rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#135
  def alignment_base(node, rhs, given_style); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#123
  def base_source; end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#88
  def extra_indentation(given_style); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#96
  def message(node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#127
  def no_base_message(lhs, rhs, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#74
  def offending_range(node, lhs, rhs, given_style); end

  # @yield [operation_rhs.first_argument]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#203
  def operation_rhs(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#215
  def operator_rhs?(node, receiver); end

  # a
  #   .b
  #   .c
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#181
  def receiver_alignment_base(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#114
  def relative_to_receiver_message(rhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#70
  def relevant_node?(send_node); end

  # a.b
  #  .c
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#169
  def semantic_alignment_base(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#189
  def semantic_alignment_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#110
  def should_align_with_base?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#106
  def should_indent_relative_to_receiver?; end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#147
  def syntactic_alignment_base(lhs, rhs); end
end

# This cop checks that the closing brace in a method definition is either
# on the same line as the last method parameter, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a method definition's opening brace is on the same line as the
# first parameter of the definition, then the closing brace should be
# on the same line as the last parameter of the definition.
#
# If an method definition's opening brace is on the line above the first
# parameter of the definition, then the closing brace should be on the
# line below the last parameter of the definition.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line method definition must be on the line
# after the last parameter of the definition.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line method definition must be on the same
# line as the last parameter of the definition.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   def foo(a,
#   b
#   )
#   end
#
#   # bad
#   def foo(
#   a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b)
#   end
#
#   # good
#   def foo(
#   a,
#   b
#   )
#   end
# @example EnforcedStyle: new_line
#   # bad
#   def foo(
#   a,
#   b)
#   end
#
#   # bad
#   def foo(a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b
#   )
#   end
# @example EnforcedStyle: same_line
#   # bad
#   def foo(a,
#   b
#   )
#   end
#
#   # bad
#   def foo(
#   a,
#   b
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b)
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#103
class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#125
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#120
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#120
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#114
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#117
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#110
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# This cop checks the indentation of the right hand side operand in
# binary operations that span more than one line.
#
# @example EnforcedStyle: aligned (default)
#   # bad
#   if a +
#   b
#   something
#   end
#
#   # good
#   if a +
#   b
#   something
#   end
# @example EnforcedStyle: indented
#   # bad
#   if a +
#   b
#   something
#   end
#
#   # good
#   if a +
#   b
#   something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#35
class RuboCop::Cop::Layout::MultilineOperationIndentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#57
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#40
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#44
  def on_or(node); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#48
  def validate_config; end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#69
  def check_and_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#101
  def message(node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#75
  def offending_range(node, lhs, rhs, given_style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#63
  def relevant_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#88
  def should_align?(node, rhs, given_style); end
end

# This cop checks whether the rescue and ensure keywords are aligned
# properly.
#
# @example
#
#   # bad
#   begin
#   something
#   rescue
#   puts 'error'
#   end
#
#   # good
#   begin
#   something
#   rescue
#   puts 'error'
#   end
#
# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#24
class RuboCop::Cop::Layout::RescueEnsureAlignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#54
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#38
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#34
  def on_resbody(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#148
  def access_modifier_node(node); end

  # We will use ancestor or wrapper with access modifier.
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#114
  def alignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#97
  def alignment_source(node, starting_loc); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#129
  def ancestor_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#140
  def assignment_node(node); end

  # Check alignment of node with rescue or ensure modifiers.
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#67
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#85
  def format_message(alignment_node, alignment_loc, kw_loc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#160
  def modifier?(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#166
  def whitespace_range(node); end
end

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#30
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#32
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#27
RuboCop::Cop::Layout::RescueEnsureAlignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#31
RuboCop::Cop::Layout::RescueEnsureAlignment::RUBY_2_5_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# Checks for colon (:) not followed by some kind of space.
# N.B. this cop does not handle spaces after a ternary operator, which are
# instead handled by Layout/SpaceAroundOperators.
#
# @example
#   # bad
#   def f(a:, b:2); {a:3}; end
#
#   # good
#   def f(a:, b: 2); {a: 3}; end
#
# source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#16
class RuboCop::Cop::Layout::SpaceAfterColon < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#35
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#27
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#19
  def on_pair(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#41
  def followed_by_space?(colon); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#17
RuboCop::Cop::Layout::SpaceAfterColon::MSG = T.let(T.unsafe(nil), String)

# Checks for comma (,) not followed by some kind of space.
#
# @example
#
#   # bad
#   [1,2]
#   { foo:bar,}
#
#   # good
#   [1, 2]
#   { foo:bar, }
#
# source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#17
class RuboCop::Cop::Layout::SpaceAfterComma < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SpaceAfterPunctuation

  # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#20
  def autocorrect(comma); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#29
  def kind(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#24
  def space_style_before_rcurly; end
end

# Checks for space between a method name and a left parenthesis in defs.
#
# @example
#
#   # bad
#   def func (x) end
#   def method= (y) end
#
#   # good
#   def func(x) end
#   def method=(y) end
#
# source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#17
class RuboCop::Cop::Layout::SpaceAfterMethodName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#36
  def autocorrect(pos_before_left_paren); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#20
RuboCop::Cop::Layout::SpaceAfterMethodName::MSG = T.let(T.unsafe(nil), String)

# This cop checks for space after `!`.
#
# @example
#   # bad
#   ! something
#
#   # good
#   !something
#
# source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#14
class RuboCop::Cop::Layout::SpaceAfterNot < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#29
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#19
  def on_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#25
  def whitespace_after_operator?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#17
RuboCop::Cop::Layout::SpaceAfterNot::MSG = T.let(T.unsafe(nil), String)

# Checks for semicolon (;) not followed by some kind of space.
#
# @example
#   # bad
#   x = 1;y = 2
#
#   # good
#   x = 1; y = 2
#
# source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#14
class RuboCop::Cop::Layout::SpaceAfterSemicolon < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SpaceAfterPunctuation

  # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#17
  def autocorrect(semicolon); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#26
  def kind(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#21
  def space_style_before_rcurly; end
end

# Checks the spacing inside and after block parameters pipes.
#
# @example EnforcedStyleInsidePipes: no_space (default)
#   # bad
#   {}.each { | x,  y |puts x }
#   ->( x,  y ) { puts x }
#
#   # good
#   {}.each { |x, y| puts x }
#   ->(x, y) { puts x }
# @example EnforcedStyleInsidePipes: space
#   # bad
#   {}.each { |x,  y| puts x }
#   ->(x,  y) { puts x }
#
#   # good
#   {}.each { | x, y | puts x }
#   ->( x, y ) { puts x }
#
# source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#25
class RuboCop::Cop::Layout::SpaceAroundBlockParameters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # @param target [RuboCop::AST::Node, Parser::Source::Range]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#40
  def autocorrect(target); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#29
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#84
  def check_after_closing_pipe(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#137
  def check_arg(arg); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#117
  def check_closing_pipe_space(args, closing_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#131
  def check_each_arg(args); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#70
  def check_inside_pipes(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#155
  def check_no_space(space_begin_pos, space_end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#92
  def check_no_space_style_inside_pipes(args, opening_pipe, closing_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#107
  def check_opening_pipe_space(args, opening_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#148
  def check_space(space_begin_pos, space_end_pos, range, msg, node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#102
  def check_space_style_inside_pipes(args, opening_pipe, closing_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#127
  def last_end_pos_inside_pipes(pos); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#58
  def pipes(arguments); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#62
  def pipes?(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#66
  def style_parameter_name; end
end

# Checks that the equals signs in parameter default assignments
# have or don't have surrounding space depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # bad
#   def some_method(arg1=:default, arg2=nil, arg3=[])
#   # do something...
#   end
#
#   # good
#   def some_method(arg1 = :default, arg2 = nil, arg3 = [])
#   # do something...
#   end
# @example EnforcedStyle: no_space
#   # bad
#   def some_method(arg1 = :default, arg2 = nil, arg3 = [])
#   # do something...
#   end
#
#   # good
#   def some_method(arg1=:default, arg2=nil, arg3=[])
#   # do something...
#   end
#
# source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#30
class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#43
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#37
  def on_optarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#52
  def check_optarg(arg, equals, value); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#65
  def incorrect_style_detected(arg, value, space_on_both_sides, no_surrounding_space); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#86
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#82
  def no_surrounding_space?(arg, equals); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#78
  def space_on_both_sides?(arg, equals); end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#35
RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault::MSG = T.let(T.unsafe(nil), String)

# Checks the spacing around the keywords.
#
# @example
#
#   # bad
#   something 'test'do|x|
#   end
#
#   while(something)
#   end
#
#   something = 123if test
#
#   # good
#   something 'test' do |x|
#   end
#
#   while (something)
#   end
#
#   something = 123 if test
#
# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#27
class RuboCop::Cop::Layout::SpaceAroundKeyword < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#130
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#38
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#42
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#46
  def on_break(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#50
  def on_case(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#126
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#54
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#58
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#62
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#66
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#70
  def on_next(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#74
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#78
  def on_postexe(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#82
  def on_preexe(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#86
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#90
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#94
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#98
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#102
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#110
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#114
  def on_when(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#118
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#122
  def on_yield(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#106
  def on_zsuper(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#207
  def accept_left_parenthesis?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#211
  def accept_left_square_bracket?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#200
  def accepted_opening_delimiter?(range, char); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#140
  def check(node, locations, begin_keyword = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#155
  def check_begin(node, range, begin_keyword); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#161
  def check_end(node, range, begin_keyword); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#171
  def check_keyword(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#167
  def do?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#177
  def offense(range, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#219
  def preceded_by_operator?(node, _range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#215
  def safe_navigation_call?(range, pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#190
  def space_after_missing?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#183
  def space_before_missing?(range); end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#33
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_PAREN = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#35
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#31
RuboCop::Cop::Layout::SpaceAroundKeyword::DO = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#29
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#28
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#32
RuboCop::Cop::Layout::SpaceAroundKeyword::SAFE_NAVIGATION = T.let(T.unsafe(nil), String)

# Checks that operators have space around them, except for **
# which should not have surrounding space.
#
# @example
#   # bad
#   total = 3*4
#   "apple"+"juice"
#   my_number = 38/4
#   a ** b
#
#   # good
#   total = 3 * 4
#   "apple" + "juice"
#   my_number = 38 / 4
#   a**b
#
# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#21
class RuboCop::Cop::Layout::SpaceAroundOperators < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#92
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_binary(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#71
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#40
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#71
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#63
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#32
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#47
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#55
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#71
  def on_special_asgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#152
  def align_hash_cop_config; end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#116
  def check_operator(operator, right_operand); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#142
  def excess_leading_space?(operator, with_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#147
  def excess_trailing_space?(right_operand, with_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#156
  def hash_table_style?; end

  # @yield [msg]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#125
  def offense(operator, with_space, right_operand); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#130
  def offense_message(operator, with_space, right_operand); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#111
  def operator_with_regular_syntax?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#106
  def regular_operator?(send_node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#28
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#26
RuboCop::Cop::Layout::SpaceAroundOperators::EXCESSIVE_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#25
RuboCop::Cop::Layout::SpaceAroundOperators::IRREGULAR_METHODS = T.let(T.unsafe(nil), Array)

# Checks that block braces have or don't have a space before the opening
# brace depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # bad
#   foo.map{ |a|
#   a.bar.to_s
#   }
#
#   # good
#   foo.map { |a|
#   a.bar.to_s
#   }
# @example EnforcedStyle: no_space
#   # bad
#   foo.map { |a|
#   a.bar.to_s
#   }
#
#   # good
#   foo.map{ |a|
#   a.bar.to_s
#   }
#
# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#30
class RuboCop::Cop::Layout::SpaceBeforeBlockBraces < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#56
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#41
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#67
  def check_empty(left_brace, space_plus_brace, used_style); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#82
  def check_non_empty(left_brace, space_plus_brace, used_style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#113
  def empty_braces?(loc); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#96
  def space_detected(left_brace, space_plus_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#90
  def space_missing(left_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#104
  def style_for_empty_braces; end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#37
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#35
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::DETECTED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#34
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::MISSING_MSG = T.let(T.unsafe(nil), String)

# Checks for comma (,) preceded by space.
#
# @example
#   # bad
#   [1 , 2 , 3]
#   a(1 , 2)
#   each { |a , b| }
#
#   # good
#   [1, 2, 3]
#   a(1, 2)
#   each { |a, b| }
#
# source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#18
class RuboCop::Cop::Layout::SpaceBeforeComma < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation

  # source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#21
  def autocorrect(space); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#25
  def kind(token); end
end

# This cop checks for missing space between a token and a comment on the
# same line.
#
# @example
#   # bad
#   1 + 1# this operation does ...
#
#   # good
#   1 + 1 # this operation does ...
#
# source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#15
class RuboCop::Cop::Layout::SpaceBeforeComment < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#29
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#18
  def investigate(processed_source); end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#16
RuboCop::Cop::Layout::SpaceBeforeComment::MSG = T.let(T.unsafe(nil), String)

# Checks that exactly one space is used between a method name and the
# first argument for method calls without parentheses.
#
# Alternatively, extra spaces can be added to align the argument with
# something on a preceding or following line, if the AllowForAlignment
# config parameter is true.
#
# @example
#   # bad
#   something  x
#   something   y, z
#   something'hello'
#
#   # good
#   something x
#   something y, z
#   something 'hello'
#
# source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#24
class RuboCop::Cop::Layout::SpaceBeforeFirstArg < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#45
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#31
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#31
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#55
  def expect_params_after_method_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#51
  def regular_method_call_with_arguments?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#28
RuboCop::Cop::Layout::SpaceBeforeFirstArg::MSG = T.let(T.unsafe(nil), String)

# Checks for semicolon (;) preceded by space.
#
# @example
#   # bad
#   x = 1 ; y = 2
#
#   # good
#   x = 1; y = 2
#
# source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#14
class RuboCop::Cop::Layout::SpaceBeforeSemicolon < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation

  # source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#17
  def autocorrect(space); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#21
  def kind(token); end
end

# This cop checks for spaces between `->` and opening parameter
# parenthesis (`(`) in lambda literals.
#
# @example EnforcedStyle: require_no_space (default)
#   # bad
#   a = -> (x, y) { x + y }
#
#   # good
#   a = ->(x, y) { x + y }
# @example EnforcedStyle: require_space
#   # bad
#   a = ->(x, y) { x + y }
#
#   # good
#   a = -> (x, y) { x + y }
#
# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#22
class RuboCop::Cop::Layout::SpaceInLambdaLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#46
  def autocorrect(lambda_node); end

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#32
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#74
  def args?(lambda_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#70
  def arrow_form?(lambda_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#61
  def arrow_lambda_with_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#65
  def lambda_node?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#85
  def range_of_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#79
  def space_after_arrow?(lambda_node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#26
RuboCop::Cop::Layout::SpaceInLambdaLiteral::ARROW = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#29
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_NO_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#27
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_SPACE = T.let(T.unsafe(nil), String)

# Checks that brackets used for array literals have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: space
#   # The `space` style enforces that array literals have
#   # surrounding space.
#
#   # bad
#   array = [a, b, c, d]
#
#   # good
#   array = [ a, b, c, d ]
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that array literals have
#   # no surrounding space.
#
#   # bad
#   array = [ a, b, c, d ]
#
#   # good
#   array = [a, b, c, d]
# @example EnforcedStyle: compact
#   # The `compact` style normally requires a space inside
#   # array brackets, with the exception that successive left
#   # or right brackets are collapsed together in nested arrays.
#
#   # bad
#   array = [ a, [ b, c ] ]
#   array = [
#   [ a ],
#   [ b, c ]
#   ]
#
#   # good
#   array = [ a, [ b, c ]]
#   array = [[ a ],
#   [ b, c ]]
# @example EnforcedStyleForEmptyBrackets: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty array brackets do not contain spaces.
#
#   # bad
#   foo = [ ]
#   bar = [     ]
#
#   # good
#   foo = []
#   bar = []
# @example EnforcedStyleForEmptyBrackets: space
#   # The `space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty array brackets contain exactly one space.
#
#   # bad
#   foo = []
#   bar = [    ]
#
#   # good
#   foo = [ ]
#   bar = [ ]
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#70
class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#91
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#77
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#111
  def array_brackets(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#211
  def compact_corrections(corrector, node, left, right); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#203
  def compact_offense(node, token, side: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#163
  def compact_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#123
  def empty_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#131
  def end_has_own_line?(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#138
  def index_for(node, token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#146
  def issue_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#115
  def left_array_bracket(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#142
  def line_and_column_for(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#188
  def multi_dimensional_array?(node, token, side: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#197
  def next_to_bracket?(token, side: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#159
  def next_to_comment?(node, token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#127
  def next_to_newline?(node, token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#178
  def qualifies_for_compact?(node, token, side: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#119
  def right_array_bracket(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#75
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#74
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::MSG = T.let(T.unsafe(nil), String)

# Checks for unnecessary additional spaces inside array percent literals
# (i.e. %i/%w).
#
# @example
#
#   # bad
#   %w(foo  bar  baz)
#   # good
#   %i(foo bar baz)
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#15
class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#23
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#27
  def on_percent_literal(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#43
  def each_unnecessary_space_match(node, &blk); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#19
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#20
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = T.let(T.unsafe(nil), Regexp)

# Checks that block braces have or don't have surrounding space inside
# them on configuration. For blocks taking parameters, it checks that the
# left brace has or doesn't have trailing space depending on
# configuration.
#
# @example EnforcedStyle: space (default)
#   # The `space` style enforces that block braces have
#   # surrounding space.
#
#   # bad
#   some_array.each {puts e}
#
#   # good
#   some_array.each { puts e }
# @example EnforcedStyle: no_space
#   # The `no_space` style enforces that block braces don't
#   # have surrounding space.
#
#   # bad
#   some_array.each { puts e }
#
#   # good
#   some_array.each {puts e}
# @example EnforcedStyleForEmptyBraces: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBraces style enforces that
#   # block braces don't have a space in between when empty.
#
#   # bad
#   some_array.each {   }
#   some_array.each {  }
#   some_array.each { }
#
#   # good
#   some_array.each {}
# @example EnforcedStyleForEmptyBraces: space
#   # The `space` EnforcedStyleForEmptyBraces style enforces that
#   # block braces have at least a space in between when empty.
#
#   # bad
#   some_array.each {}
#
#   # good
#   some_array.each { }
#   some_array.each {  }
#   some_array.each {   }
# @example SpaceBeforeBlockParameters: true (default)
#   # The SpaceBeforeBlockParameters style set to `true` enforces that
#   # there is a space between `{` and `|`. Overrides `EnforcedStyle`
#   # if there is a conflict.
#
#   # bad
#   [1, 2, 3].each {|n| n * 2 }
#
#   # good
#   [1, 2, 3].each { |n| n * 2 }
# @example SpaceBeforeBlockParameters: false
#   # The SpaceBeforeBlockParameters style set to `false` enforces that
#   # there is no space between `{` and `|`. Overrides `EnforcedStyle`
#   # if there is a conflict.
#
#   # bad
#   [1, 2, 3].each { |n| n * 2 }
#
#   # good
#   [1, 2, 3].each {|n| n * 2 }
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#79
class RuboCop::Cop::Layout::SpaceInsideBlockBraces < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#93
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#84
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#122
  def adjacent_braces(left_brace, right_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#129
  def braces_with_contents_inside(node, inner); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#106
  def check_inside(node, left_brace, right_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#136
  def check_left_brace(inner, left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#144
  def check_right_brace(inner, right_brace, single_line); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#198
  def no_space(begin_pos, end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#153
  def no_space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#214
  def offense(begin_pos, end_pos, msg, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#187
  def pipe?(args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#206
  def space(begin_pos, end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#171
  def space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#191
  def space_inside_right_brace(right_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#219
  def style_for_empty_braces; end
end

# Checks that braces used for hash literals have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # The `space` style enforces that hash literals have
#   # surrounding space.
#
#   # bad
#   h = {a: 1, b: 2}
#
#   # good
#   h = { a: 1, b: 2 }
# @example EnforcedStyle: no_space
#   # The `no_space` style enforces that hash literals have
#   # no surrounding space.
#
#   # bad
#   h = { a: 1, b: 2 }
#
#   # good
#   h = {a: 1, b: 2}
# @example EnforcedStyle: compact
#   # The `compact` style normally requires a space inside
#   # hash braces, with the exception that successive left
#   # braces or right braces are collapsed together in nested hashes.
#
#   # bad
#   h = { a: { b: 2 } }
#   foo = { { a: 1 } => { b: { c: 2 } } }
#
#   # good
#   h = { a: { b: 2 }}
#   foo = {{ a: 1 } => { b: { c: 2 }}}
# @example EnforcedStyleForEmptyBraces: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBraces style enforces that
#   # empty hash braces do not contain spaces.
#
#   # bad
#   foo = { }
#   bar = {    }
#
#   # good
#   foo = {}
#   bar = {}
# @example EnforcedStyleForEmptyBraces: space
#   # The `space` EnforcedStyleForEmptyBraces style enforces that
#   # empty hash braces contain space.
#
#   # bad
#   foo = {}
#
#   # good
#   foo = { }
#   foo = {  }
#   foo = {     }
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#66
class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#84
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#73
  def on_hash(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#158
  def ambiguous_or_unexpected_style_detected(style, is_match); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#114
  def check(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#130
  def expect_space?(token1, token2); end

  # @yield [begin_index, end_index]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#103
  def hash_literal_with_braces(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#143
  def incorrect_style_detected(token1, token2, expect_space, is_empty_braces); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#171
  def message(brace, is_empty_braces, expect_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#166
  def offense?(token1, expect_space); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#197
  def range_of_space_to_the_left(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#189
  def range_of_space_to_the_right(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#181
  def space_range(token_range); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#71
RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces::MSG = T.let(T.unsafe(nil), String)

# Checks for spaces inside ordinary round parentheses.
#
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that parentheses do not have spaces.
#
#   # bad
#   f( 3)
#   g = (a + 3 )
#
#   # good
#   f(3)
#   g = (a + 3)
# @example EnforcedStyle: space
#   # The `space` style enforces that parentheses have a space at the
#   # beginning and end.
#   # Note: Empty parentheses should not have spaces.
#
#   # bad
#   f(3)
#   g = (a + 3)
#   y( )
#
#   # good
#   f( 3 )
#   g = ( a + 3 )
#   y()
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#34
class RuboCop::Cop::Layout::SpaceInsideParens < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#56
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#42
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#100
  def can_be_ignored?(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#68
  def each_extraneous_space(tokens); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#81
  def each_missing_space(tokens); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#96
  def parens?(token1, token2); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#39
RuboCop::Cop::Layout::SpaceInsideParens::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#40
RuboCop::Cop::Layout::SpaceInsideParens::MSG_SPACE = T.let(T.unsafe(nil), String)

# Checks for unnecessary additional spaces inside the delimiters of
# %i/%w/%x literals.
#
# @example
#
#   # good
#   %i(foo bar baz)
#
#   # bad
#   %w( foo bar baz )
#
#   # bad
#   %x(  ls -l )
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#19
class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#39
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#27
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#35
  def on_percent_literal(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#31
  def on_xstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#49
  def add_offenses_for_unnecessary_spaces(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#57
  def regex_matches(node, &blk); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#24
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::BEGIN_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#25
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::END_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#23
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::MSG = T.let(T.unsafe(nil), String)

# Checks for spaces inside range literals.
#
# @example
#   # bad
#   1 .. 3
#
#   # good
#   1..3
#
#   # bad
#   'a' .. 'z'
#
#   # good
#   'a'..'z'
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#20
class RuboCop::Cop::Layout::SpaceInsideRangeLiteral < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#27
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#23
  def on_irange(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#48
  def check(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#21
RuboCop::Cop::Layout::SpaceInsideRangeLiteral::MSG = T.let(T.unsafe(nil), String)

# Checks that reference brackets have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that reference brackets have
#   # no surrounding space.
#
#   # bad
#   hash[ :key ]
#   array[ index ]
#
#   # good
#   hash[:key]
#   array[index]
# @example EnforcedStyle: space
#   # The `space` style enforces that reference brackets have
#   # surrounding space.
#
#   # bad
#   hash[:key]
#   array[index]
#
#   # good
#   hash[ :key ]
#   array[ index ]
# @example EnforcedStyleForEmptyBrackets: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty reference brackets do not contain spaces.
#
#   # bad
#   foo[ ]
#   foo[     ]
#
#   # good
#   foo[]
# @example EnforcedStyleForEmptyBrackets: space
#   # The `space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty reference brackets contain exactly one space.
#
#   # bad
#   foo[]
#   foo[    ]
#
#   # good
#   foo[ ]
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#56
class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#86
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#65
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#110
  def bracket_method?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#127
  def closing_bracket(tokens, opening_bracket); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#145
  def empty_config; end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#115
  def left_ref_bracket(node, tokens); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#140
  def previous_token(current_token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#104
  def reference_brackets(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#63
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::BRACKET_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#61
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#60
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::MSG = T.let(T.unsafe(nil), String)

# This cop checks for whitespace within string interpolations.
#
# @example EnforcedStyle: no_space (default)
#   # bad
#   var = "This is the #{ space } example"
#
#   # good
#   var = "This is the #{no_space} example"
# @example EnforcedStyle: space
#   # bad
#   var = "This is the #{no_space} example"
#
#   # good
#   var = "This is the #{ space } example"
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#21
class RuboCop::Cop::Layout::SpaceInsideStringInterpolation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#28
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#46
  def each_style_violation(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#59
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#63
  def space_on_any_side?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#71
  def space_on_each_side?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#25
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::NO_SPACE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#26
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::SPACE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for tabs inside the source code.
#
# @example
#   # bad
#   # This example uses a tab to indent bar.
#   def foo
#   bar
#   end
#
#   # good
#   # This example uses spaces to indent bar.
#   def foo
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/layout/tab.rb#23
class RuboCop::Cop::Layout::Tab < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/tab.rb#48
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/tab.rb#29
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/tab.rb#58
  def in_string_literal?(ranges, line, col); end

  # source://rubocop//lib/rubocop/cop/layout/tab.rb#68
  def string_literal_ranges(ast); end
end

# source://rubocop//lib/rubocop/cop/layout/tab.rb#27
RuboCop::Cop::Layout::Tab::MSG = T.let(T.unsafe(nil), String)

# This cop looks for trailing blank lines and a final newline in the
# source code.
#
# @example EnforcedStyle: final_blank_line
#   # `final_blank_line` looks for one blank line followed by a new line
#   # at the end of files.
#
#   # bad
#   class Foo; end
#   # EOF
#
#   # bad
#   class Foo; end # EOF
#
#   # good
#   class Foo; end
#
#   # EOF
# @example EnforcedStyle: final_newline (default)
#   # `final_newline` looks for one newline at the end of files.
#
#   # bad
#   class Foo; end
#
#   # EOF
#
#   # bad
#   class Foo; end # EOF
#
#   # good
#   class Foo; end
#   # EOF
#
# source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#40
class RuboCop::Cop::Layout::TrailingBlankLines < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#64
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#44
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#84
  def ends_in_end?(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#94
  def message(wanted_blank_lines, blank_lines); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_blank_lines.rb#72
  def offense_detected(buffer, wanted_blank_lines, blank_lines, whitespace_at_end); end
end

# This cop looks for trailing whitespace in the source code.
#
# @example
#   # The line in this example contains spaces after the 0.
#   # bad
#   x = 0
#
#   # The line in this example ends directly after the 0.
#   # good
#   x = 0
#
# source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#17
class RuboCop::Cop::Layout::TrailingWhitespace < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#36
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#22
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#50
  def extract_heredoc_ranges(ast); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#46
  def inside_heredoc?(heredoc_ranges, line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#42
  def skip_heredoc?; end
end

# source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#20
RuboCop::Cop::Layout::TrailingWhitespace::MSG = T.let(T.unsafe(nil), String)

# This class handles autocorrection for code that needs to be moved
# to new lines.
#
# source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#7
class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#28
    def break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#15
    def correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#37
    def move_comment(eol_comment:, node:, corrector:); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#48
    def remove_semicolon(node, corrector); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#54
    def semicolon(node); end
  end
end

# source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#5
module RuboCop::Cop::Lint; end

# This cop checks for ambiguous block association with method
# when param passed without parentheses.
#
# @example
#
#   # bad
#   some_method a { |val| puts val }
# @example
#
#   # good
#   # With parentheses, there's no ambiguity.
#   some_method(a) { |val| puts val }
#
#   # good
#   # Operator methods require no disambiguation
#   foo == bar { |b| b.baz }
#
#   # good
#   # Lambda arguments require no disambiguation
#   foo = ->(bar) { bar.baz }
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#27
class RuboCop::Cop::Lint::AmbiguousBlockAssociation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#32
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#32
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#49
  def allowed_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#44
  def ambiguous_block_association?(send_node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#53
  def message(send_node); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#28
RuboCop::Cop::Lint::AmbiguousBlockAssociation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for ambiguous operators in the first argument of a
# method invocation without parentheses.
#
# @example
#
#   # bad
#
#   # The `*` is interpreted as a splat operator but it could possibly be
#   # a `*` method invocation (i.e. `do_something.*(some_array)`).
#   do_something *some_array
# @example
#
#   # good
#
#   # With parentheses, there's no ambiguity.
#   do_something(*some_array)
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#23
class RuboCop::Cop::Lint::AmbiguousOperator < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ParserDiagnostic

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#47
  def alternative_message(diagnostic); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#43
  def relevant_diagnostic?(diagnostic); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#26
RuboCop::Cop::Lint::AmbiguousOperator::AMBIGUITIES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#36
RuboCop::Cop::Lint::AmbiguousOperator::MSG_FORMAT = T.let(T.unsafe(nil), String)

# This cop checks for ambiguous regexp literals in the first argument of
# a method invocation without parentheses.
#
# @example
#
#   # bad
#
#   # This is interpreted as a method invocation with a regexp literal,
#   # but it could possibly be `/` method invocations.
#   # (i.e. `do_something./(pattern)./(i)`)
#   do_something /pattern/i
# @example
#
#   # good
#
#   # With parentheses, there's no ambiguity.
#   do_something(/pattern/i)
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#24
class RuboCop::Cop::Lint::AmbiguousRegexpLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ParserDiagnostic

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#37
  def alternative_message(_diagnostic); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#33
  def relevant_diagnostic?(diagnostic); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#27
RuboCop::Cop::Lint::AmbiguousRegexpLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop checks for assignments in the conditions of
# if/while/until.
#
# @example
#
#   # bad
#
#   if some_var = true
#   do_something
#   end
# @example
#
#   # good
#
#   if some_var == true
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#24
class RuboCop::Cop::Lint::AssignmentInCondition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SafeAssignment

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#36
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#36
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#36
  def on_while(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#59
  def allowed_construct?(asgn_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#63
  def conditional_assignment?(asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#51
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#67
  def skip_children?(asgn_node); end

  # each_node/visit_descendants_with_types with :skip_children
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#74
  def traverse_node(node, types, &block); end
end

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#34
RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#31
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#27
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

# `BigDecimal.new()` is deprecated since BigDecimal 1.3.3.
# This cop identifies places where `BigDecimal.new()`
# can be replaced by `BigDecimal()`.
#
# @example
#   # bad
#   BigDecimal.new(123.456, 3)
#
#   # good
#   BigDecimal(123.456, 3)
#
# source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#17
class RuboCop::Cop::Lint::BigDecimalNew < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#21
  def big_decimal_new(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#26
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#18
RuboCop::Cop::Lint::BigDecimalNew::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `:true` and `:false` symbols.
# In most cases it would be a typo.
#
# @example
#
#   # bad
#   :true
#
#   # good
#   true
# @example
#
#   # bad
#   :false
#
#   # good
#   false
#
# source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#24
class RuboCop::Cop::Lint::BooleanSymbol < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#28
  def boolean_symbol?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#30
  def on_sym(node); end
end

# source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#25
RuboCop::Cop::Lint::BooleanSymbol::MSG = T.let(T.unsafe(nil), String)

# This cop checks for circular argument references in optional keyword
# arguments and optional ordinal arguments.
#
# This cop mirrors a warning produced by MRI since 2.2.
#
# @example
#
#   # bad
#
#   def bake(pie: pie)
#   pie.heat_up
#   end
# @example
#
#   # good
#
#   def bake(pie:)
#   pie.refrigerate
#   end
# @example
#
#   # good
#
#   def bake(pie: self.pie)
#   pie.feed_to(user)
#   end
# @example
#
#   # bad
#
#   def cook(dry_ingredients = dry_ingredients)
#   dry_ingredients.reduce(&:+)
#   end
# @example
#
#   # good
#
#   def cook(dry_ingredients = self.dry_ingredients)
#   dry_ingredients.combine
#   end
#
# source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#50
class RuboCop::Cop::Lint::CircularArgumentReference < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#53
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#57
  def on_optarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#63
  def check_for_circular_argument_references(arg_name, arg_value); end
end

# source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#51
RuboCop::Cop::Lint::CircularArgumentReference::MSG = T.let(T.unsafe(nil), String)

# This cop checks for calls to debugger or pry.
#
# @example
#
#   # bad (ok during development)
#
#   # using pry
#   def some_method
#   binding.pry
#   do_something
#   end
# @example
#
#   # bad (ok during development)
#
#   # using byebug
#   def some_method
#   byebug
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/debugger.rb#35
class RuboCop::Cop::Lint::Debugger < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#55
  def binding_irb_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#45
  def debugger_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#38
  def kernel?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#61
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#59
  def pry_rescue?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#73
  def binding_irb?(node); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#69
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/lint/debugger.rb#36
RuboCop::Cop::Lint::Debugger::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of the deprecated class method usages.
#
# @example
#
#   # bad
#
#   File.exists?(some_path)
#   Dir.exists?(some_path)
#   iterator?
# @example
#
#   # good
#
#   File.exist?(some_path)
#   Dir.exist?(some_path)
#   block_given?
#
# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#23
class RuboCop::Cop::Lint::DeprecatedClassMethods < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#72
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#63
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#83
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#92
  def deprecated_method(data); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#100
  def method_call(class_constant, method); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#96
  def replacement_method(data); end
end

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#52
RuboCop::Cop::Lint::DeprecatedClassMethods::DEPRECATED_METHODS_OBJECT = T.let(T.unsafe(nil), Array)

# Inner class to DeprecatedClassMethods.
# This class exists to add abstraction and clean naming to the
# objects that are going to be operated on.
#
# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#27
class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp

  # @return [DeprecatedClassMethod] a new instance of DeprecatedClassMethod
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#32
  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  # Returns the value of attribute class_constant.
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#30
  def class_constant; end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#38
  def class_nodes; end

  # Returns the value of attribute deprecated_method.
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#30
  def deprecated_method; end

  # Returns the value of attribute replacement_method.
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#30
  def replacement_method; end
end

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#51
RuboCop::Cop::Lint::DeprecatedClassMethods::MSG = T.let(T.unsafe(nil), String)

# This cop checks constructors for disjunctive assignments that should
# be plain assignments.
#
# So far, this cop is only concerned with disjunctive assignment of
# instance variables.
#
# In ruby, an instance variable is nil until a value is assigned, so the
# disjunction is unnecessary. A plain assignment has the same effect.
#
# @example
#   # bad
#   def initialize
#   @x ||= 1
#   end
#
#   # good
#   def initialize
#   @x = 1
#   end
#
# source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#25
class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#28
  def on_def(node); end

  private

  # @param node [DefNode] a constructor definition
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#35
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#41
  def check_body(body); end

  # @param lines [Array] the logical lines of the constructor
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#53
  def check_body_lines(lines); end

  # Add an offense if the LHS of the given disjunctive assignment is
  # an instance variable.
  #
  # For now, we only care about assignments to instance variables.
  #
  # @param node [Node] a disjunctive assignment
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#74
  def check_disjunctive_assignment(node); end
end

# source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#26
RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor::MSG = T.let(T.unsafe(nil), String)

# This cop checks that there are no repeated conditions
# used in case 'when' expressions.
#
# @example
#
#   # bad
#
#   case x
#   when 'first'
#   do_something
#   when 'first'
#   do_something_else
#   end
# @example
#
#   # good
#
#   case x
#   when 'first'
#   do_something
#   when 'second'
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#30
class RuboCop::Cop::Lint::DuplicateCaseCondition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#33
  def on_case(case_node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#47
  def repeated_condition?(previous, condition); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#31
RuboCop::Cop::Lint::DuplicateCaseCondition::MSG = T.let(T.unsafe(nil), String)

# This cop checks for duplicated instance (or singleton) method
# definitions.
#
# @example
#
#   # bad
#
#   def foo
#   1
#   end
#
#   def foo
#   2
#   end
# @example
#
#   # bad
#
#   def foo
#   1
#   end
#
#   alias foo bar
# @example
#
#   # good
#
#   def foo
#   1
#   end
#
#   def bar
#   2
#   end
# @example
#
#   # good
#
#   def foo
#   1
#   end
#
#   alias bar foo
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#52
class RuboCop::Cop::Lint::DuplicateMethods < ::RuboCop::Cop::Cop
  # @return [DuplicateMethods] a new instance of DuplicateMethods
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#56
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#96
  def alias_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#100
  def attr?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#84
  def method_alias?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#88
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#61
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#71
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#106
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#104
  def sym_name(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#120
  def check_const_receiver(node, name, const_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#127
  def check_self_receiver(node, name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#179
  def found_attr(node, args, readable: T.unsafe(nil), writable: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#139
  def found_instance_method(node, name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#149
  def found_method(node, method_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#189
  def lookup_constant(node, const_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#134
  def message_for_dup(node, method_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#165
  def on_attr(node, attr_name, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#223
  def possible_dsl?(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#209
  def qualified_name(enclosing, namespace, mod_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#233
  def source_location(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#53
RuboCop::Cop::Lint::DuplicateMethods::MSG = T.let(T.unsafe(nil), String)

# This cop checks for duplicated keys in hash literals.
#
# This cop mirrors a warning in Ruby 2.2.
#
# @example
#
#   # bad
#
#   hash = { food: 'apple', food: 'orange' }
# @example
#
#   # good
#
#   hash = { food: 'apple', other_food: 'orange' }
#
# source://rubocop//lib/rubocop/cop/lint/duplicated_key.rb#21
class RuboCop::Cop::Lint::DuplicatedKey < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Duplication

  # source://rubocop//lib/rubocop/cop/lint/duplicated_key.rb#26
  def on_hash(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicated_key.rb#24
RuboCop::Cop::Lint::DuplicatedKey::MSG = T.let(T.unsafe(nil), String)

# This cop checks if each_with_object is called with an immutable
# argument. Since the argument is the object that the given block shall
# make calls on to build something based on the enumerable that
# each_with_object iterates over, an immutable argument makes no sense.
# It's definitely a bug.
#
# @example
#
#   # bad
#
#   sum = numbers.each_with_object(0) { |e, a| a += e }
# @example
#
#   # good
#
#   num = 0
#   sum = numbers.each_with_object(num) { |e, a| a += e }
#
# source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#24
class RuboCop::Cop::Lint::EachWithObjectArgument < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#27
  def each_with_object?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#31
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#31
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#25
RuboCop::Cop::Lint::EachWithObjectArgument::MSG = T.let(T.unsafe(nil), String)

# This cop checks for odd else block layout - like
# having an expression on the same line as the else keyword,
# which is usually a mistake.
#
# @example
#
#   # bad
#
#   if something
#   # ...
#   else do_this
#   do_that
#   end
# @example
#
#   # good
#
#   if something
#   # ...
#   else
#   do_this
#   do_that
#   end
#
# source://rubocop//lib/rubocop/cop/lint/else_layout.rb#30
class RuboCop::Cop::Lint::ElseLayout < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#33
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#41
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#51
  def check_else(node); end
end

# source://rubocop//lib/rubocop/cop/lint/else_layout.rb#31
RuboCop::Cop::Lint::ElseLayout::MSG = T.let(T.unsafe(nil), String)

# This cop checks for empty `ensure` blocks
#
# @example
#
#   # bad
#
#   def some_method
#   do_something
#   ensure
#   end
# @example
#
#   # bad
#
#   begin
#   do_something
#   ensure
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   ensure
#   do_something_else
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   ensure
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#45
class RuboCop::Cop::Lint::EmptyEnsure < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#52
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#48
  def on_ensure(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#46
RuboCop::Cop::Lint::EmptyEnsure::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the presence of empty expressions.
#
# @example
#
#   # bad
#
#   foo = ()
#   if ()
#   bar
#   end
# @example
#
#   # good
#
#   foo = (some_expression)
#   if (some_expression)
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#25
class RuboCop::Cop::Lint::EmptyExpression < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#28
  def on_begin(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#36
  def empty_expression?(begin_node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#26
RuboCop::Cop::Lint::EmptyExpression::MSG = T.let(T.unsafe(nil), String)

# This cop checks for empty interpolation.
#
# @example
#
#   # bad
#
#   "result is #{}"
# @example
#
#   # good
#
#   "result is #{some_result}"
#
# source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#19
class RuboCop::Cop::Lint::EmptyInterpolation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#28
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#22
  def on_dstr(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#20
RuboCop::Cop::Lint::EmptyInterpolation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the presence of `when` branches without a body.
#
# @example
#
#   # bad
#
#   case foo
#   when bar then 1
#   when baz then # nothing
#   end
# @example
#
#   # good
#
#   case foo
#   when bar then 1
#   when baz then 2
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_when.rb#25
class RuboCop::Cop::Lint::EmptyWhen < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/empty_when.rb#28
  def on_case(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_when.rb#26
RuboCop::Cop::Lint::EmptyWhen::MSG = T.let(T.unsafe(nil), String)

# This cop checks for END blocks in method definitions.
#
# @example
#
#   # bad
#
#   def some_method
#   END { do_something }
#   end
# @example
#
#   # good
#
#   def some_method
#   at_exit { do_something }
#   end
# @example
#
#   # good
#
#   # outside defs
#   END { do_something }
#
# source://rubocop//lib/rubocop/cop/lint/end_in_method.rb#30
class RuboCop::Cop::Lint::EndInMethod < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/end_in_method.rb#33
  def on_postexe(node); end
end

# source://rubocop//lib/rubocop/cop/lint/end_in_method.rb#31
RuboCop::Cop::Lint::EndInMethod::MSG = T.let(T.unsafe(nil), String)

# This cop checks for *return* from an *ensure* block.
# Explicit return from an ensure block alters the control flow
# as the return will take precedence over any exception being raised,
# and the exception will be silently thrown away as if it were rescued.
#
# @example
#
#   # bad
#
#   begin
#   do_something
#   ensure
#   do_something_else
#   return
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   ensure
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#31
class RuboCop::Cop::Lint::EnsureReturn < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#34
  def on_ensure(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#32
RuboCop::Cop::Lint::EnsureReturn::MSG = T.let(T.unsafe(nil), String)

# This cop emulates the following Ruby warnings in Ruby 2.6.
#
# % cat example.rb
# ERB.new('hi', nil, '-', '@output_buffer')
# % ruby -rerb example.rb
# example.rb:1: warning: Passing safe_level with the 2nd argument of
# ERB.new is deprecated. Do not use it, and specify other arguments as
# keyword arguments.
# example.rb:1: warning: Passing trim_mode with the 3rd argument of
# ERB.new is deprecated. Use keyword argument like
# ERB.new(str, trim_mode:...) instead.
# example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new
# is deprecated. Use keyword argument like ERB.new(str, eoutvar: ...)
# instead.
#
# Now non-keyword arguments other than first one are softly deprecated
# and will be removed when Ruby 2.5 becomes EOL.
# `ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0.
# Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`.
# This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can
# be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`.
#
# @example
#   # Target codes supports Ruby 2.6 and higher only
#   # bad
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # good
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#
#   # Target codes supports Ruby 2.5 and lower only
#   # good
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # Target codes supports Ruby 2.6, 2.5 and lower
#   # bad
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # good
#   # Ruby standard library style
#   # https://github.com/ruby/ruby/commit/3406c5d
#   if ERB.instance_method(:initialize).parameters.assoc(:key) # Ruby 2.6+
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#   else
#   ERB.new(str, nil, '-', '@output_buffer')
#   end
#
#   # good
#   # Use `RUBY_VERSION` style
#   if RUBY_VERSION >= '2.6'
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#   else
#   ERB.new(str, nil, '-', '@output_buffer')
#   end
#
# source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#62
class RuboCop::Cop::Lint::ErbNewArguments < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRubyVersion

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#100
  def correct_arguments?(arguments); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#79
  def erb_new_with_non_keyword_arguments(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#84
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#67
RuboCop::Cop::Lint::ErbNewArguments::MESSAGES = T.let(T.unsafe(nil), Array)

# This cop looks for uses of flip-flop operator.
# flip-flop operator is deprecated since Ruby 2.6.0.
#
# @example
#   # bad
#   (1..20).each do |x|
#   puts x if (x == 5) .. (x == 10)
#   end
#
#   # good
#   (1..20).each do |x|
#   puts x if (x >= 5) && (x <= 10)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#19
class RuboCop::Cop::Lint::FlipFlop < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#26
  def on_eflipflop(node); end

  # source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#22
  def on_iflipflop(node); end
end

# source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#20
RuboCop::Cop::Lint::FlipFlop::MSG = T.let(T.unsafe(nil), String)

# This cop identifies Float literals which are, like, really really really
# really really really really really big. Too big. No-one needs Floats
# that big. If you need a float that big, something is wrong with you.
#
# @example
#
#   # bad
#
#   float = 3.0e400
# @example
#
#   # good
#
#   float = 42.9
#
# source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#21
class RuboCop::Cop::Lint::FloatOutOfRange < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#24
  def on_float(node); end
end

# source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#22
RuboCop::Cop::Lint::FloatOutOfRange::MSG = T.let(T.unsafe(nil), String)

# This lint sees if there is a mismatch between the number of
# expected fields for format/sprintf/#% and what is actually
# passed as arguments.
#
# @example
#
#   # bad
#
#   format('A value: %s and another: %i', a_value)
# @example
#
#   # good
#
#   format('A value: %s and another: %i', a_value, another)
#
# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#21
class RuboCop::Cop::Lint::FormatParameterMismatch < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#36
  def on_send(node); end

  private

  # number of arguments required for the format sequence
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#154
  def arguments_count(format); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#64
  def called_on_string?(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#115
  def count_format_matches(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#97
  def count_matches(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#119
  def count_percent_matches(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#107
  def countable_format?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#111
  def countable_percent?(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#132
  def expected_fields_count(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#158
  def format?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#124
  def format_method?(name, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#93
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#56
  def matched_arguments_count?(expected, passed); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#147
  def max_digit_dollar_num(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#179
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#73
  def method_with_format_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#77
  def named_mode?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#44
  def offending_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#166
  def percent?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#87
  def splat_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#162
  def sprintf?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#32
RuboCop::Cop::Lint::FormatParameterMismatch::DIGIT_DOLLAR_FLAG = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#25
RuboCop::Cop::Lint::FormatParameterMismatch::FIELD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#28
RuboCop::Cop::Lint::FormatParameterMismatch::KERNEL = T.let(T.unsafe(nil), String)

# http://rubular.com/r/CvpbxkcTzy
#
# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#23
RuboCop::Cop::Lint::FormatParameterMismatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#27
RuboCop::Cop::Lint::FormatParameterMismatch::NAMED_FIELD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#34
RuboCop::Cop::Lint::FormatParameterMismatch::NAMED_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#30
RuboCop::Cop::Lint::FormatParameterMismatch::PERCENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#31
RuboCop::Cop::Lint::FormatParameterMismatch::PERCENT_PERCENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#29
RuboCop::Cop::Lint::FormatParameterMismatch::SHOVEL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#33
RuboCop::Cop::Lint::FormatParameterMismatch::STRING_TYPES = T.let(T.unsafe(nil), Array)

# This cop checks for *rescue* blocks with no body.
#
# @example
#
#   # bad
#
#   def some_method
#   do_something
#   rescue
#   # do nothing
#   end
# @example
#
#   # bad
#
#   begin
#   do_something
#   rescue
#   # do nothing
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   rescue
#   handle_exception
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue
#   handle_exception
#   end
#
# source://rubocop//lib/rubocop/cop/lint/handle_exceptions.rb#47
class RuboCop::Cop::Lint::HandleExceptions < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/handle_exceptions.rb#50
  def on_resbody(node); end
end

# source://rubocop//lib/rubocop/cop/lint/handle_exceptions.rb#48
RuboCop::Cop::Lint::HandleExceptions::MSG = T.let(T.unsafe(nil), String)

# This cop checks for implicit string concatenation of string literals
# which are on the same line.
#
# @example
#
#   # bad
#
#   array = ['Item 1' 'Item 2']
# @example
#
#   # good
#
#   array = ['Item 1Item 2']
#   array = ['Item 1' + 'Item 2']
#   array = [
#   'Item 1' \
#   'Item 2'
#   ]
#
# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#25
class RuboCop::Cop::Lint::ImplicitStringConcatenation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#33
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#83
  def display_str(node); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#50
  def each_bad_cons(node); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#65
  def ending_delimiter(str); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#91
  def str_content(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#74
  def string_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#79
  def string_literals?(node1, node2); end
end

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#28
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_ARRAY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#30
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#26
RuboCop::Cop::Lint::ImplicitStringConcatenation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `private` or `protected` access modifiers which are
# applied to a singleton method. These access modifiers do not make
# singleton methods private/protected. `private_class_method` can be
# used for that.
#
# @example
#
#   # bad
#
#   class C
#   private
#
#   def self.method
#   puts 'hi'
#   end
#   end
# @example
#
#   # good
#
#   class C
#   def self.method
#   puts 'hi'
#   end
#
#   private_class_method :method
#   end
# @example
#
#   # good
#
#   class C
#   class << self
#   private
#
#   def method
#   puts 'hi'
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#48
class RuboCop::Cop::Lint::IneffectiveAccessModifier < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#60
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#64
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#56
  def private_class_methods(node0); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#115
  def access_modifier?(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#70
  def check_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#119
  def correct_visibility?(node, modifier, ignored_methods); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#88
  def format_message(modifier); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#100
  def ineffective_modifier(node, ignored_methods, modifier = T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#82
  def private_class_method_names(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#51
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PRIVATE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#53
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PROTECTED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#49
RuboCop::Cop::Lint::IneffectiveAccessModifier::MSG = T.let(T.unsafe(nil), String)

# This cop looks for error classes inheriting from `Exception`
# and its standard library subclasses, excluding subclasses of
# `StandardError`. It is configurable to suggest using either
# `RuntimeError` (default) or `StandardError` instead.
#
# @example EnforcedStyle: runtime_error (default)
#   # bad
#
#   class C < Exception; end
#
#   # good
#
#   class C < RuntimeError; end
# @example EnforcedStyle: standard_error
#   # bad
#
#   class C < Exception; end
#
#   # good
#
#   class C < StandardError; end
#
# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#28
class RuboCop::Cop::Lint::InheritException < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#50
  def on_class(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#70
  def illegal_class_name?(class_node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#66
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#74
  def preferred_base_class; end
end

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#36
RuboCop::Cop::Lint::InheritException::ILLEGAL_CLASSES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#31
RuboCop::Cop::Lint::InheritException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#32
RuboCop::Cop::Lint::InheritException::PREFERRED_BASE_CLASS = T.let(T.unsafe(nil), Hash)

# This cop checks for interpolation in a single quoted string.
#
# @example
#
#   # bad
#
#   foo = 'something with #{interpolation} inside'
# @example
#
#   # good
#
#   foo = "something with #{interpolation} inside"
#
# source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#19
class RuboCop::Cop::Lint::InterpolationCheck < ::RuboCop::Cop::Cop
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#33
  def heredoc?(node); end

  # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#23
  def on_str(node); end
end

# source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#20
RuboCop::Cop::Lint::InterpolationCheck::MSG = T.let(T.unsafe(nil), String)

# This cop checks for literals used as the conditions or as
# operands in and/or expressions serving as the conditions of
# if/while/until.
#
# @example
#
#   # bad
#
#   if 20
#   do_something
#   end
# @example
#
#   # bad
#
#   if some_var && true
#   do_something
#   end
# @example
#
#   # good
#
#   if some_var && some_condition
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#33
class RuboCop::Cop::Lint::LiteralAsCondition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#74
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#56
  def on_case(case_node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#36
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#68
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#48
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#52
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#40
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#44
  def on_while_post(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#89
  def basic_literal?(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#119
  def check_case(case_node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#80
  def check_for_literal(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#101
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#128
  def condition(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#111
  def handle_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#97
  def primitive_array?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#34
RuboCop::Cop::Lint::LiteralAsCondition::MSG = T.let(T.unsafe(nil), String)

# This cop checks for interpolated literals.
#
# @example
#
#   # bad
#
#   "result is #{10}"
# @example
#
#   # good
#
#   "result is 10"
#
# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#19
class RuboCop::Cop::Lint::LiteralInInterpolation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#25
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#51
  def autocorrected_value(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#66
  def autocorrected_value_for_symbol(node); end

  # Does node print its own source when converted to a string?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#74
  def prints_as_self?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#45
  def special_keyword?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#23
RuboCop::Cop::Lint::LiteralInInterpolation::COMPOSITE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#22
RuboCop::Cop::Lint::LiteralInInterpolation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of *begin...end while/until something*.
#
# @example
#
#   # bad
#
#   # using while
#   begin
#   do_something
#   end while some_condition
# @example
#
#   # bad
#
#   # using until
#   begin
#   do_something
#   end until some_condition
# @example
#
#   # good
#
#   # using while
#   while some_condition
#   do_something
#   end
# @example
#
#   # good
#
#   # using until
#   until some_condition
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/loop.rb#43
class RuboCop::Cop::Lint::Loop < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/loop.rb#51
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#47
  def on_while_post(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#57
  def register_offense(node); end
end

# source://rubocop//lib/rubocop/cop/lint/loop.rb#44
RuboCop::Cop::Lint::Loop::MSG = T.let(T.unsafe(nil), String)

# cop disables on wide ranges of code, that latter contributors to
# a file wouldn't be aware of.
#
# @example
#   # Lint/MissingCopEnableDirective:
#   #   MaximumRangeSize: .inf
#
#   # good
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # rubocop:enable Layout/SpaceAroundOperators
#   # y = 1
#   # EOF
#
#   # bad
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # EOF
# @example
#   # Lint/MissingCopEnableDirective:
#   #   MaximumRangeSize: 2
#
#   # good
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # With the previous, there are 2 lines on which cop is disabled.
#   # rubocop:enable Layout/SpaceAroundOperators
#
#   # bad
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   x += 1
#   # Including this, that's 3 lines on which the cop is disabled.
#   # rubocop:enable Layout/SpaceAroundOperators
#
# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#45
class RuboCop::Cop::Lint::MissingCopEnableDirective < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#53
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#73
  def message(max_range:, cop:); end
end

# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#48
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#50
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG_BOUND = T.let(T.unsafe(nil), String)

# In math and Python, we can use `x < y < z` style comparison to compare
# multiple value. However, we can't use the comparison in Ruby. However,
# the comparison is not syntax error. This cop checks the bad usage of
# comparison operators.
#
# @example
#
#   # bad
#
#   x < y < z
#   10 <= x <= 20
# @example
#
#   # good
#
#   x < y && y < z
#   10 <= x && x <= 20
#
# source://rubocop//lib/rubocop/cop/lint/multiple_compare.rb#24
class RuboCop::Cop::Lint::MultipleCompare < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/multiple_compare.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/multiple_compare.rb#27
  def multiple_compare?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/multiple_compare.rb#31
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/multiple_compare.rb#25
RuboCop::Cop::Lint::MultipleCompare::MSG = T.let(T.unsafe(nil), String)

# This cop checks for nested method definitions.
#
# @example
#
#   # bad
#
#   # `bar` definition actually produces methods in the same scope
#   # as the outer `foo` method. Furthermore, the `bar` method
#   # will be redefined every time `foo` is invoked.
#   def foo
#   def bar
#   end
#   end
# @example
#
#   # good
#
#   def foo
#   bar = -> { puts 'hello' }
#   bar.call
#   end
# @example
#
#   # good
#
#   def foo
#   self.class_eval do
#   def bar
#   end
#   end
#   end
#
#   def foo
#   self.module_exec do
#   def bar
#   end
#   end
#   end
# @example
#
#   # good
#
#   def foo
#   class << self
#   def bar
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#57
class RuboCop::Cop::Lint::NestedMethodDefinition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#98
  def class_or_module_or_struct_new_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#90
  def eval_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#94
  def exec_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#61
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#61
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#70
  def find_nested_defs(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#85
  def scoping_method_call?(child); end
end

# source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#58
RuboCop::Cop::Lint::NestedMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# This cop checks for nested percent literals.
#
# @example
#
#   # bad
#
#   # The percent literal for nested_attributes is parsed as four tokens,
#   # yielding the array [:name, :content, :"%i[incorrectly", :"nested]"].
#   attributes = {
#   valid_attributes: %i[name content],
#   nested_attributes: %i[name content %i[incorrectly nested]]
#   }
#
# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#18
class RuboCop::Cop::Lint::NestedPercentLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#32
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#36
  def on_percent_literal(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#42
  def contains_percent_literals?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#21
RuboCop::Cop::Lint::NestedPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# The array of regular expressions representing percent literals that,
# if found within a percent literal expression, will cause a
# NestedPercentLiteral violation to be emitted.
#
# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#27
RuboCop::Cop::Lint::NestedPercentLiteral::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#28
RuboCop::Cop::Lint::NestedPercentLiteral::REGEXES = T.let(T.unsafe(nil), Array)

# Don't omit the accumulator when calling `next` in a `reduce` block.
#
# @example
#
#   # bad
#
#   result = (1..4).reduce(0) do |acc, i|
#   next if i.odd?
#   acc + i
#   end
# @example
#
#   # good
#
#   result = (1..4).reduce(0) do |acc, i|
#   next acc if i.odd?
#   acc + i
#   end
#
# source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#25
class RuboCop::Cop::Lint::NextWithoutAccumulator < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#32
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#28
  def on_body_of_reduce(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#44
  def parent_block_node(node); end
end

# source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#26
RuboCop::Cop::Lint::NextWithoutAccumulator::MSG = T.let(T.unsafe(nil), String)

# This cop checks for non-local exits from iterators without a return
# value. It registers an offense under these conditions:
#
#  - No value is returned,
#  - the block is preceded by a method chain,
#  - the block has arguments,
#  - the method which receives the block is not `define_method`
#    or `define_singleton_method`,
#  - the return is not contained in an inner scope, e.g. a lambda or a
#    method definition.
#
# @example
#
#   class ItemApi
#   rescue_from ValidationError do |e| # non-iteration block with arg
#   return { message: 'validation error' } unless e.errors # allowed
#   error_array = e.errors.map do |error| # block with method chain
#   return if error.suppress? # warned
#   return "#{error.param}: invalid" unless error.message # allowed
#   "#{error.param}: #{error.message}"
#   end
#   { message: 'validation error', errors: error_array }
#   end
#
#   def update_items
#   transaction do # block without arguments
#   return unless update_necessary? # allowed
#   find_each do |item| # block without method chain
#   return if item.stock == 0 # false-negative...
#   item.update!(foobar: true)
#   end
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#41
class RuboCop::Cop::Lint::NonLocalExitFromIterator < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#78
  def chained_send?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#79
  def define_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#46
  def on_return(return_node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#74
  def return_value?(return_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#70
  def scoped_node?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#42
RuboCop::Cop::Lint::NonLocalExitFromIterator::MSG = T.let(T.unsafe(nil), String)

# This cop warns the usage of unsafe number conversions. Unsafe
# number conversion can cause unexpected error if auto type conversion
# fails. Cop prefer parsing with number class instead.
#
# @example
#
#   # bad
#
#   '10'.to_i
#   '10.2'.to_f
#   '10'.to_c
#
#   # good
#
#   Integer('10', 10)
#   Float('10.2')
#   Complex('10')
#
# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#23
class RuboCop::Cop::Lint::NumberConversion < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#38
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#34
  def to_method(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#52
  def correct_method(node, receiver); end
end

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#24
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHOD_CLASS_MAPPING = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#29
RuboCop::Cop::Lint::NumberConversion::MSG = T.let(T.unsafe(nil), String)

# Checks the proper ordering of magic comments and whether
# a magic comment is not placed before a shebang.
#
# @example
#   # bad
#
#   # frozen_string_literal: true
#   # encoding: ascii
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:UTF-8>]
#
#   # good
#
#   # encoding: ascii
#   # frozen_string_literal: true
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]
#
#   # good
#
#   #!/usr/bin/env ruby
#   # encoding: ascii
#   # frozen_string_literal: true
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]
#
# source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#30
class RuboCop::Cop::Lint::OrderedMagicComments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FrozenStringLiteral

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#49
  def autocorrect(_node); end

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#36
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#64
  def magic_comment_lines; end

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#80
  def magic_comments; end
end

# source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#33
RuboCop::Cop::Lint::OrderedMagicComments::MSG = T.let(T.unsafe(nil), String)

# Checks for space between the name of a called method and a left
# parenthesis.
#
# @example
#
#   # bad
#
#   puts (x + y)
# @example
#
#   # good
#
#   puts(x + y)
#
# source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#20
class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#25
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#25
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#58
  def space_range(expr, space_length); end

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#42
  def spaces_before_left_parenthesis(node); end
end

# source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#23
RuboCop::Cop::Lint::ParenthesesAsGroupedExpression::MSG = T.let(T.unsafe(nil), String)

# This cop checks for quotes and commas in %w, e.g. `%w('foo', "bar")`
#
# It is more likely that the additional characters are unintended (for
# example, mistranslating an array of literals to percent string notation)
# rather than meant to be part of the resulting strings.
#
# @example
#
#   # bad
#
#   %w('foo', "bar")
# @example
#
#   # good
#
#   %w(foo bar)
#
# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#23
class RuboCop::Cop::Lint::PercentStringArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#43
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#33
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#37
  def on_percent_literal(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#60
  def contains_quotes_or_commas?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#27
RuboCop::Cop::Lint::PercentStringArray::LEADING_QUOTE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#30
RuboCop::Cop::Lint::PercentStringArray::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#26
RuboCop::Cop::Lint::PercentStringArray::QUOTES_AND_COMMAS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#28
RuboCop::Cop::Lint::PercentStringArray::TRAILING_QUOTE = T.let(T.unsafe(nil), Regexp)

# This cop checks for colons and commas in %i, e.g. `%i(:foo, :bar)`
#
# It is more likely that the additional characters are unintended (for
# example, mistranslating an array of literals to percent string notation)
# rather than meant to be part of the resulting symbols.
#
# @example
#
#   # bad
#
#   %i(:foo, :bar)
# @example
#
#   # good
#
#   %i(foo bar)
#
# source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#23
class RuboCop::Cop::Lint::PercentSymbolArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#39
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#29
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#33
  def on_percent_literal(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#53
  def contains_colons_or_commas?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#63
  def non_alphanumeric_literal?(literal); end
end

# source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#26
RuboCop::Cop::Lint::PercentSymbolArray::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `rand(1)` calls.
# Such calls always return `0`.
#
# @example
#
#   # bad
#
#   rand 1
#   Kernel.rand(-1)
#   rand 1.0
#   rand(-1.0)
# @example
#
#   # good
#
#   0 # just use 0 instead
#
# source://rubocop//lib/rubocop/cop/lint/rand_one.rb#23
class RuboCop::Cop::Lint::RandOne < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#31
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#27
  def rand_one?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#39
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/lint/rand_one.rb#24
RuboCop::Cop::Lint::RandOne::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant `with_index`.
#
# @example
#   # bad
#   ary.each_with_index do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
#   # bad
#   ary.each.with_index do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#29
class RuboCop::Cop::Lint::RedundantWithIndex < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#50
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#44
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#35
  def redundant_with_index?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#65
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#73
  def with_index_range(send); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#32
RuboCop::Cop::Lint::RedundantWithIndex::MSG_EACH_WITH_INDEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#33
RuboCop::Cop::Lint::RedundantWithIndex::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)

# This cop checks for redundant `with_object`.
#
# @example
#   # bad
#   ary.each_with_object([]) do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
#   # bad
#   ary.each.with_object([]) do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#29
class RuboCop::Cop::Lint::RedundantWithObject < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#51
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#45
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#36
  def redundant_with_object?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#66
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#74
  def with_object_range(send); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#32
RuboCop::Cop::Lint::RedundantWithObject::MSG_EACH_WITH_OBJECT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#34
RuboCop::Cop::Lint::RedundantWithObject::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)

# This cop checks for regexp literals used as `match-current-line`.
# If a regexp literal is in condition, the regexp matches `$_` implicitly.
#
# @example
#   # bad
#   if /foo/
#   do_something
#   end
#
#   # good
#   if /foo/ =~ $_
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#19
class RuboCop::Cop::Lint::RegexpAsCondition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#23
  def on_match_current_line(node); end
end

# source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#20
RuboCop::Cop::Lint::RegexpAsCondition::MSG = T.let(T.unsafe(nil), String)

# This cop checks for expressions where there is a call to a predicate
# method with at least one argument, where no parentheses are used around
# the parameter list, and a boolean operator, && or ||, is used in the
# last argument.
#
# The idea behind warning for these constructs is that the user might
# be under the impression that the return value from the method call is
# an operand of &&/||.
#
# @example
#
#   # bad
#
#   if day.is? :tuesday && month == :jan
#   # ...
#   end
# @example
#
#   # good
#
#   if day.is?(:tuesday) && month == :jan
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#30
class RuboCop::Cop::Lint::RequireParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#36
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#36
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#58
  def check_predicate(predicate, node); end

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#49
  def check_ternary(ternary, node); end
end

# source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#33
RuboCop::Cop::Lint::RequireParentheses::MSG = T.let(T.unsafe(nil), String)

# This cop checks for *rescue* blocks targeting the Exception class.
#
# @example
#
#   # bad
#
#   begin
#   do_something
#   rescue Exception
#   handle_exception
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue ArgumentError
#   handle_exception
#   end
#
# source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#27
class RuboCop::Cop::Lint::RescueException < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#31
  def on_resbody(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#40
  def targets_exception?(rescue_arg_node); end
end

# source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#28
RuboCop::Cop::Lint::RescueException::MSG = T.let(T.unsafe(nil), String)

# Check for arguments to `rescue` that will result in a `TypeError`
# if an exception is raised.
#
# @example
#   # bad
#   begin
#   bar
#   rescue nil
#   baz
#   end
#
#   # bad
#   def foo
#   bar
#   rescue 1, 'a', "#{b}", 0.0, [], {}
#   baz
#   end
#
#   # good
#   begin
#   bar
#   rescue
#   baz
#   end
#
#   # good
#   def foo
#   bar
#   rescue NameError
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#37
class RuboCop::Cop::Lint::RescueType < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RescueNode

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#62
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#44
  def on_resbody(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#75
  def correction(*exceptions); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#86
  def invalid_exceptions(exceptions); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#82
  def valid_exceptions(exceptions); end
end

# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#42
RuboCop::Cop::Lint::RescueType::INVALID_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#40
RuboCop::Cop::Lint::RescueType::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of a return with a value in a context
# where the value will be ignored. (initialize and setter methods)
#
# @example
#
#   # bad
#   def initialize
#   foo
#   return :qux if bar?
#   baz
#   end
#
#   def foo=(bar)
#   return 42
#   end
# @example
#
#   # good
#   def initialize
#   foo
#   return if bar?
#   baz
#   end
#
#   def foo=(bar)
#   return
#   end
#
# source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#34
class RuboCop::Cop::Lint::ReturnInVoidContext < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#37
  def on_return(return_node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#59
  def method_name(context_node); end

  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#55
  def non_void_context(return_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#67
  def setter_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#63
  def void_context_method?(method_name); end
end

# source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#35
RuboCop::Cop::Lint::ReturnInVoidContext::MSG = T.let(T.unsafe(nil), String)

# The safe navigation operator returns nil if the receiver is
# nil. If you chain an ordinary method call after a safe
# navigation operator, it raises NoMethodError. We should use a
# safe navigation operator after a safe navigation operator.
# This cop checks for the problem outlined above.
#
# @example
#
#   # bad
#
#   x&.foo.bar
#   x&.foo + bar
#   x&.foo[bar]
# @example
#
#   # good
#
#   x&.foo&.bar
#   x&.foo || bar
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#26
class RuboCop::Cop::Lint::SafeNavigationChain < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#33
  def bad_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#42
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#57
  def method_chain(node); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#30
RuboCop::Cop::Lint::SafeNavigationChain::MSG = T.let(T.unsafe(nil), String)

# This cop check to make sure that if safe navigation is used for a method
# call in an `&&` or `||` condition that safe navigation is used for all
# method calls on that same object.
#
# @example
#   # bad
#   foo&.bar && foo.baz
#
#   # bad
#   foo.bar || foo&.baz
#
#   # bad
#   foo&.bar && (foobar.baz || foo.baz)
#
#   # good
#   foo.bar && foo.baz
#
#   # good
#   foo&.bar || foo&.baz
#
#   # good
#   foo&.bar && (foobar.baz || foo&.baz)
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#29
class RuboCop::Cop::Lint::SafeNavigationConsistency < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::NilMethods

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#61
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#42
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#36
  def on_csend(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#71
  def top_conditional_ancestor(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#84
  def unsafe_method_calls(method_calls, safe_nav_receiver); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#33
RuboCop::Cop::Lint::SafeNavigationConsistency::MSG = T.let(T.unsafe(nil), String)

# This cop checks to make sure safe navigation isn't used with `empty?` in
# a conditional.
#
# While the safe navigation operator is generally a good idea, when
# checking `foo&.empty?` in a conditional, `foo` being `nil` will actually
# do the opposite of what the author intends.
#
# @example
#   # bad
#   return if foo&.empty?
#   return unless foo&.empty?
#
#   # good
#   return if foo && foo.empty?
#   return unless foo && foo.empty?
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#22
class RuboCop::Cop::Lint::SafeNavigationWithEmpty < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#30
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#26
  def safe_navigation_empty_in_conditional?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#23
RuboCop::Cop::Lint::SafeNavigationWithEmpty::MSG = T.let(T.unsafe(nil), String)

# This cop checks if a file which has a shebang line as
# its first line is granted execute permission.
#
# @example
#   # bad
#
#   # A file which has a shebang line as its first line is not
#   # granted execute permission.
#
#   #!/usr/bin/env ruby
#   puts 'hello, world'
#
#   # good
#
#   # A file which has a shebang line as its first line is
#   # granted execute permission.
#
#   #!/usr/bin/env ruby
#   puts 'hello, world'
#
#   # good
#
#   # A file which has not a shebang line as its first line is not
#   # granted execute permission.
#
#   puts 'hello, world'
#
# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#33
class RuboCop::Cop::Lint::ScriptPermission < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#48
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#37
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#56
  def executable?(processed_source); end

  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#63
  def format_message_from(processed_source); end
end

# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#34
RuboCop::Cop::Lint::ScriptPermission::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#35
RuboCop::Cop::Lint::ScriptPermission::SHEBANG = T.let(T.unsafe(nil), String)

# This cop checks for shadowed arguments.
#
# This cop has `IgnoreImplicitReferences` configuration option.
# It means argument shadowing is used in order to pass parameters
# to zero arity `super` when `IgnoreImplicitReferences` is `true`.
#
# @example
#
#   # bad
#   do_something do |foo|
#   foo = 42
#   puts foo
#   end
#
#   def do_something(foo)
#   foo = 42
#   puts foo
#   end
#
#   # good
#   do_something do |foo|
#   foo = foo + 42
#   puts foo
#   end
#
#   def do_something(foo)
#   foo = foo + 42
#   puts foo
#   end
#
#   def do_something(foo)
#   puts foo
#   end
# @example IgnoreImplicitReferences: false (default)
#
#   # bad
#   def do_something(foo)
#   foo = 42
#   super
#   end
#
#   def do_something(foo)
#   foo = super
#   bar
#   end
# @example IgnoreImplicitReferences: true
#
#   # good
#   def do_something(foo)
#   foo = 42
#   super
#   end
#
#   def do_something(foo)
#   foo = super
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#66
class RuboCop::Cop::Lint::ShadowedArgument < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#76
  def after_leaving_scope(scope, _variable_table); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#72
  def join_force?(force_class); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#70
  def uses_var?(node0, param1); end

  private

  # Get argument references without assignments' references
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#163
  def argument_references(argument); end

  # Find the first argument assignment, which doesn't reference the
  # argument at the rhs. If the assignment occurs inside a branch or
  # block, it is impossible to tell whether it's executed, so precise
  # shadowing location is not known.
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#122
  def assignment_without_argument_usage(argument); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#84
  def check_argument(argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#176
  def ignore_implicit_references?; end

  # Check whether the given node is nested into block or conditional.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#154
  def node_within_block_or_conditional?(node, stop_search_node); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#146
  def reference_pos(node); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#97
  def shadowing_assignment(argument); end
end

# source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#67
RuboCop::Cop::Lint::ShadowedArgument::MSG = T.let(T.unsafe(nil), String)

# This cop checks for a rescued exception that get shadowed by a
# less specific exception being rescued before a more specific
# exception is rescued.
#
# @example
#
#   # bad
#
#   begin
#   something
#   rescue Exception
#   handle_exception
#   rescue StandardError
#   handle_standard_error
#   end
#
#   # good
#
#   begin
#   something
#   rescue StandardError
#   handle_standard_error
#   rescue Exception
#   handle_exception
#   end
#
#   # good, however depending on runtime environment.
#   #
#   # This is a special case for system call errors.
#   # System dependent error code depends on runtime environment.
#   # For example, whether `Errno::EAGAIN` and `Errno::EWOULDBLOCK` are
#   # the same error code or different error code depends on environment.
#   # This good case is for `Errno::EAGAIN` and `Errno::EWOULDBLOCK` with
#   # the same error code.
#   begin
#   something
#   rescue Errno::EAGAIN, Errno::EWOULDBLOCK
#   handle_standard_error
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#46
class RuboCop::Cop::Lint::ShadowedException < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#52
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#92
  def compare_exceptions(exception, other_exception); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#83
  def contains_multiple_levels_of_exceptions?(group); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#120
  def evaluate_exceptions(rescue_group); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#165
  def find_shadowing_rescue(rescues); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#70
  def offense_range(rescues); end

  # @param rescue_group [RuboCop::AST::Node] is a node of array_type
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#156
  def rescued_exceptions(rescue_group); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#76
  def rescued_groups_for(rescues); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#110
  def silence_warnings; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#139
  def sorted?(rescued_groups); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#106
  def system_call_err?(error); end
end

# source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#50
RuboCop::Cop::Lint::ShadowedException::MSG = T.let(T.unsafe(nil), String)

# This cop looks for use of the same name as outer local variables
# for block arguments or block local variables.
# This is a mimic of the warning
# "shadowing outer local variable - foo" from `ruby -cw`.
#
# @example
#
#   # bad
#
#   def some_method
#   foo = 1
#
#   2.times do |foo| # shadowing outer `foo`
#   do_something(foo)
#   end
#   end
# @example
#
#   # good
#
#   def some_method
#   foo = 1
#
#   2.times do |bar|
#   do_something(bar)
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#34
class RuboCop::Cop::Lint::ShadowingOuterLocalVariable < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#41
  def before_declaring_variable(variable, variable_table); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#37
  def join_force?(force_class); end
end

# source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#35
RuboCop::Cop::Lint::ShadowingOuterLocalVariable::MSG = T.let(T.unsafe(nil), String)

# This cop checks for string conversion in string interpolation,
# which is redundant.
#
# @example
#
#   # bad
#
#   "result is #{something.to_s}"
# @example
#
#   # good
#
#   "result is #{something}"
#
# source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#20
class RuboCop::Cop::Lint::StringConversionInInterpolation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#27
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#25
  def to_s_without_args?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#53
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#21
RuboCop::Cop::Lint::StringConversionInInterpolation::MSG_DEFAULT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/string_conversion_in_interpolation.rb#22
RuboCop::Cop::Lint::StringConversionInInterpolation::MSG_SELF = T.let(T.unsafe(nil), String)

# This is not actually a cop. It does not inspect anything. It just
# provides methods to repack Parser's diagnostics/errors
# into RuboCop's offenses.
#
# source://rubocop//lib/rubocop/cop/lint/syntax.rb#9
class RuboCop::Cop::Lint::Syntax < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#31
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#41
  def add_offense_from_error(error); end

  private

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#51
  def beautify_message(message); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/syntax.rb#15
    def offenses_from_processed_source(processed_source, config, options); end
  end
end

# source://rubocop//lib/rubocop/cop/lint/syntax.rb#13
RuboCop::Cop::Lint::Syntax::ERROR_SOURCE_RANGE = T.let(T.unsafe(nil), RuboCop::Cop::Lint::Syntax::PseudoSourceRange)

# source://rubocop//lib/rubocop/cop/lint/syntax.rb#10
class RuboCop::Cop::Lint::Syntax::PseudoSourceRange < ::Struct
  # Returns the value of attribute begin_pos
  #
  # @return [Object] the current value of begin_pos
  def begin_pos; end

  # Sets the attribute begin_pos
  #
  # @param value [Object] the value to set the attribute begin_pos to.
  # @return [Object] the newly set value
  def begin_pos=(_); end

  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute end_pos
  #
  # @return [Object] the current value of end_pos
  def end_pos; end

  # Sets the attribute end_pos
  #
  # @param value [Object] the value to set the attribute end_pos to.
  # @return [Object] the newly set value
  def end_pos=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute source_line
  #
  # @return [Object] the current value of source_line
  def source_line; end

  # Sets the attribute source_line
  #
  # @param value [Object] the value to set the attribute source_line to.
  # @return [Object] the newly set value
  def source_line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This cop checks to make sure `#to_json` includes an optional argument.
# When overriding `#to_json`, callers may invoke JSON
# generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows
# for an optional argument, your method should too.
#
# @example
#   # bad
#   def to_json
#   end
#
#   # good
#   def to_json(_opts)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/to_json.rb#20
class RuboCop::Cop::Lint::ToJSON < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/to_json.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/to_json.rb#24
  def on_def(node); end
end

# source://rubocop//lib/rubocop/cop/lint/to_json.rb#21
RuboCop::Cop::Lint::ToJSON::MSG = T.let(T.unsafe(nil), String)

# This cop checks for underscore-prefixed variables that are actually
# used.
#
# @example
#
#   # bad
#
#   [1, 2, 3].each do |_num|
#   do_something(_num)
#   end
# @example
#
#   # good
#
#   [1, 2, 3].each do |num|
#   do_something(num)
#   end
# @example
#
#   # good
#
#   [1, 2, 3].each do |_num|
#   do_something # not using `_num`
#   end
#
# source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#32
class RuboCop::Cop::Lint::UnderscorePrefixedVariableName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#39
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#45
  def check_variable(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#35
  def join_force?(force_class); end
end

# source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#33
RuboCop::Cop::Lint::UnderscorePrefixedVariableName::MSG = T.let(T.unsafe(nil), String)

# This cop checks for using Fixnum or Bignum constant.
#
# @example
#
#   # bad
#
#   1.is_a?(Fixnum)
#   1.is_a?(Bignum)
# @example
#
#   # good
#
#   1.is_a?(Integer)
#
# source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#20
class RuboCop::Cop::Lint::UnifiedInteger < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#23
  def fixnum_or_bignum_const(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#27
  def on_const(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#21
RuboCop::Cop::Lint::UnifiedInteger::MSG = T.let(T.unsafe(nil), String)

# removed without causing any offenses to be reported. It's implemented
# as a cop in that it inherits from the Cop base class and calls
# add_offense. The unusual part of its implementation is that it doesn't
# have any on_* methods or an investigate method. This means that it
# doesn't take part in the investigation phase when the other cops do
# their work. Instead, it waits until it's called in a later stage of the
# execution. The reason it can't be implemented as a normal cop is that
# it depends on the results of all other cops to do its work.
#
# @example
#   # bad
#   # rubocop:disable Metrics/LineLength
#   x += 1
#   # rubocop:enable Metrics/LineLength
#
#   # good
#   x += 1
#
# source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#28
class RuboCop::Cop::Lint::UnneededCopDisableDirective < ::RuboCop::Cop::Cop
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#45
  def autocorrect(args); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#34
  def check(offenses, cop_disabled_line_ranges, comments); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#184
  def add_offense_for_entire_comment(comment, cops); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#195
  def add_offense_for_some_cops(comment, cops); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#173
  def add_offenses(unneeded_cops); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#251
  def all_cop_names; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#157
  def all_disabled?(comment); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#247
  def collect_variable_like_names(scope); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#61
  def comment_range_with_surrounding_space(range); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#209
  def cop_range(comment, cop); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#232
  def describe(cop); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#167
  def directive_count(comment); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#76
  def directive_range_in_list(range, ranges); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#119
  def each_already_disabled(line_ranges, disabled_ranges, comments); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#107
  def each_line_range(line_ranges, disabled_ranges, offenses, comments, cop); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#92
  def each_unneeded_disable(cop_disabled_line_ranges, offenses, comments, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#255
  def ends_its_line?(range); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#139
  def find_unneeded(comment, offenses, cop, line_range, next_line_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#161
  def ignore_offense?(disabled_ranges, line_range); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#215
  def matching_range(haystack, needle); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#224
  def trailing_range?(ranges, range); end
end

# source://rubocop//lib/rubocop/cop/lint/unneeded_cop_disable_directive.rb#32
RuboCop::Cop::Lint::UnneededCopDisableDirective::COP_NAME = T.let(T.unsafe(nil), String)

# removed.
#
# that cop checks whether any cop was actually enabled.
#
# @example
#   # bad
#   foo = 1
#   # rubocop:enable Metrics/LineLength
#
#   # good
#   foo = 1
# @example
#   # bad
#   # rubocop:disable Metrics/LineLength
#   baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrrrrrrrr
#   # rubocop:enable Metrics/LineLength
#   baz
#   # rubocop:enable all
#
#   # good
#   # rubocop:disable Metrics/LineLength
#   baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrrrrrrrr
#   # rubocop:enable all
#   baz
#
# source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#35
class RuboCop::Cop::Lint::UnneededCopEnableDirective < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#54
  def autocorrect(comment_and_name); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#41
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#110
  def all_or_name(name); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#67
  def comment_start(comment); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#71
  def cop_name_indention(comment, name); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#62
  def range_of_offense(comment, name); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#95
  def range_to_remove(begin_pos, end_pos, comma_pos, comment); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#75
  def range_with_comma(comment, name); end
end

# source://rubocop//lib/rubocop/cop/lint/unneeded_cop_enable_directive.rb#39
RuboCop::Cop::Lint::UnneededCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

# Checks for unnecessary `require` statement.
#
# The following features are unnecessary `require` statement because
# they are already loaded.
#
# ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'
# ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]
# ["enumerator.so", "rational.so", "complex.so", "thread.rb"]
#
# This cop targets Ruby 2.2 or higher containing these 4 features.
#
# @example
#   # bad
#   require 'unloaded_feature'
#   require 'thread'
#
#   # good
#   require 'unloaded_feature'
#
# source://rubocop//lib/rubocop/cop/lint/unneeded_require_statement.rb#24
class RuboCop::Cop::Lint::UnneededRequireStatement < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/unneeded_require_statement.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_require_statement.rb#34
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_require_statement.rb#29
  def unnecessary_require_statement?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/unneeded_require_statement.rb#27
RuboCop::Cop::Lint::UnneededRequireStatement::MSG = T.let(T.unsafe(nil), String)

# This cop checks for unneeded usages of splat expansion
#
# @example
#
#   # bad
#
#   a = *[1, 2, 3]
#   a = *'a'
#   a = *1
#
#   begin
#   foo
#   rescue *[StandardError, ApplicationError]
#   bar
#   end
#
#   case foo
#   when *[1, 2, 3]
#   bar
#   else
#   baz
#   end
# @example
#
#   # good
#
#   c = [1, 2, 3]
#   a = *c
#   a, b = *c
#   a, *b = *c
#   a = *1..10
#   a = ['a']
#
#   begin
#   foo
#   rescue StandardError, ApplicationError
#   bar
#   end
#
#   case foo
#   when 1, 2, 3
#   bar
#   else
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#52
class RuboCop::Cop::Lint::UnneededSplatExpansion < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#61
  def array_new?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#78
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#63
  def literal_expansion(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#67
  def on_splat(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#102
  def array_new_inside_array_literal?(array_new_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#124
  def array_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#128
  def method_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#132
  def part_of_an_array?(node); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#147
  def remove_brackets(array); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#109
  def replacement_range_and_content(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#139
  def unneeded_brackets?(node); end

  # source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#88
  def unneeded_splat_expansion(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#54
RuboCop::Cop::Lint::UnneededSplatExpansion::ARRAY_PARAM_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#59
RuboCop::Cop::Lint::UnneededSplatExpansion::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#53
RuboCop::Cop::Lint::UnneededSplatExpansion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#58
RuboCop::Cop::Lint::UnneededSplatExpansion::PERCENT_CAPITAL_I = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#56
RuboCop::Cop::Lint::UnneededSplatExpansion::PERCENT_CAPITAL_W = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#57
RuboCop::Cop::Lint::UnneededSplatExpansion::PERCENT_I = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unneeded_splat_expansion.rb#55
RuboCop::Cop::Lint::UnneededSplatExpansion::PERCENT_W = T.let(T.unsafe(nil), String)

# This cop checks for unreachable code.
# The check are based on the presence of flow of control
# statement in non-final position in *begin*(implicit) blocks.
#
# @example
#
#   # bad
#
#   def some_method
#   return
#   do_something
#   end
#
#   # bad
#
#   def some_method
#   if cond
#   return
#   else
#   return
#   end
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#37
class RuboCop::Cop::Lint::UnreachableCode < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#54
  def flow_command?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#87
  def check_case(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#80
  def check_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#64
  def flow_expression?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#38
RuboCop::Cop::Lint::UnreachableCode::MSG = T.let(T.unsafe(nil), String)

# Common functionality for cops handling unused arguments.
#
# source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#7
module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#14
  def after_leaving_scope(scope, _variable_table); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#10
  def join_force?(force_class); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#22
  def check_argument(variable); end
end

# This cop checks for unused block arguments.
#
# @example
#
#   # bad
#
#   do_something do |used, unused|
#   puts used
#   end
#
#   do_something do |bar|
#   puts :foo
#   end
#
#   define_method(:foo) do |bar|
#   puts :baz
#   end
# @example
#
#   #good
#
#   do_something do |used, _unused|
#   puts used
#   end
#
#   do_something do
#   puts :foo
#   end
#
#   define_method(:foo) do |_bar|
#   puts :baz
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#39
class RuboCop::Cop::Lint::UnusedBlockArgument < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Lint::UnusedArgument

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#42
  def autocorrect(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#139
  def allow_unused_keyword_arguments?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#55
  def allowed_block?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#60
  def allowed_keyword_argument?(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#75
  def augment_message(message, variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#48
  def check_argument(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#126
  def define_method_call?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#133
  def empty_block?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#143
  def ignore_empty_blocks?; end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#65
  def message(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#109
  def message_for_lambda(variable, all_arguments); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#96
  def message_for_normal_block(variable, all_arguments); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#121
  def message_for_underscore_prefix(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#88
  def variable_type(variable); end
end

# This cop checks for unused method arguments.
#
# @example
#
#   # bad
#
#   def some_method(used, unused, _unused_but_allowed)
#   puts used
#   end
# @example
#
#   # good
#
#   def some_method(used, _unused, _unused_but_allowed)
#   puts used
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#23
class RuboCop::Cop::Lint::UnusedMethodArgument < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Lint::UnusedArgument

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#26
  def autocorrect(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#32
  def check_argument(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#46
  def message(variable); end
end

# This cop identifies places where `URI.escape` can be replaced by
# `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component`
# depending on your specific use case.
# Also this cop identifies places where `URI.unescape` can be replaced by
# `CGI.unescape`, `URI.decode_www_form`,
# or `URI.decode_www_form_component` depending on your specific use case.
#
# @example
#   # bad
#   URI.escape('http://example.com')
#   URI.encode('http://example.com')
#
#   # good
#   CGI.escape('http://example.com')
#   URI.encode_www_form([['example', 'param'], ['lang', 'en']])
#   URI.encode_www_form(page: 10, locale: 'en')
#   URI.encode_www_form_component('http://example.com')
#
#   # bad
#   URI.unescape(enc_uri)
#   URI.decode(enc_uri)
#
#   # good
#   CGI.unescape(enc_uri)
#   URI.decode_www_form(enc_uri)
#   URI.decode_www_form_component(enc_uri)
#
# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#32
class RuboCop::Cop::Lint::UriEscapeUnescape < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#54
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#48
  def uri_escape_unescape?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#33
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_ESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#38
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_UNESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#44
RuboCop::Cop::Lint::UriEscapeUnescape::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where `URI.regexp` is obsolete and should
# not be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`.
#
# @example
#   # bad
#   URI.regexp('http://example.com')
#
#   # good
#   URI::DEFAULT_PARSER.make_regexp('http://example.com')
#
# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#16
class RuboCop::Cop::Lint::UriRegexp < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#44
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#32
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#21
  def uri_regexp_with_argument?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#27
  def uri_regexp_without_argument?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#65
  def register_offense(node, top_level: T.unsafe(nil), arg: T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#17
RuboCop::Cop::Lint::UriRegexp::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant access modifiers, including those with no
# code, those which are repeated, and leading `public` modifiers in a
# class or module body. Conditionally-defined methods are considered as
# always being defined, and thus access modifiers guarding such methods
# are not redundant.
#
# @example
#
#   class Foo
#   public # this is redundant (default access is public)
#
#   def method
#   end
#
#   private # this is not redundant (a method is defined)
#   def method2
#   end
#
#   private # this is redundant (no following methods are defined)
#   end
# @example
#
#   class Foo
#   # The following is not redundant (conditionally defined methods are
#   # considered as always defining a method)
#   private
#
#   if condition?
#   def method
#   end
#   end
#
#   protected # this is not redundant (method is defined)
#
#   define_method(:method2) do
#   end
#
#   protected # this is redundant (repeated from previous modifier)
#
#   [1,2,3].each do |i|
#   define_method("foo#{i}") do
#   end
#   end
#
#   # The following is redundant (methods defined on the class'
#   # singleton class are not affected by the public modifier)
#   public
#
#   def self.method3
#   end
#   end
# @example
#   # Lint/UselessAccessModifier:
#   #   ContextCreatingMethods:
#   #     - concerning
#   require 'active_support/concern'
#   class Foo
#   concerning :Bar do
#   def some_public_method
#   end
#
#   private
#
#   def some_private_method
#   end
#   end
#
#   # this is not redundant because `concerning` created its own context
#   private
#
#   def some_other_private_method
#   end
#   end
# @example
#   # Lint/UselessAccessModifier:
#   #   MethodCreatingMethods:
#   #     - delegate
#   require 'active_support/core_ext/module/delegation'
#   class Foo
#   # this is not redundant because `delegate` creates methods
#   private
#
#   delegate :method_a, to: :method_b
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#93
class RuboCop::Cop::Lint::UselessAccessModifier < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#124
  def class_or_instance_eval?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#128
  def class_or_module_or_struct_new_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#120
  def dynamic_method_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#104
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#96
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#100
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#110
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#116
  def static_method_definition?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#142
  def access_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#225
  def any_context_creating_methods?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#201
  def any_method_definition?(child); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#153
  def check_child_nodes(node, unused, cur_vis); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#178
  def check_new_visibility(node, unused, new_vis, cur_vis); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#132
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#147
  def check_scope(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#169
  def check_send_node(node, cur_vis, unused); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#219
  def eval_call?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#195
  def method_definition?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#214
  def start_of_new_scope?(child); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#94
RuboCop::Cop::Lint::UselessAccessModifier::MSG = T.let(T.unsafe(nil), String)

# This cop checks for every useless assignment to local variable in every
# scope.
# The basic idea for this cop was from the warning of `ruby -cw`:
#
#   assigned but unused variable - foo
#
# Currently this cop has advanced logic that detects unreferenced
# reassignments and properly handles varied cases such as branch, loop,
# rescue, ensure, etc.
#
# @example
#
#   # bad
#
#   def some_method
#   some_var = 1
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   some_var = 1
#   do_something(some_var)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#33
class RuboCop::Cop::Lint::UselessAssignment < ::RuboCop::Cop::Cop
  include ::RuboCop::NameSimilarity

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#41
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#47
  def check_for_unused_assignments(variable); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#112
  def collect_variable_like_names(scope); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#37
  def join_force?(force_class); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#65
  def message_for_useless_assignment(assignment); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#72
  def message_specification(assignment, variable); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#82
  def multiple_assignment_message(variable_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#87
  def operator_assignment_message(scope, assignment); end

  # TODO: More precise handling (rescue, ensure, nested begin, etc.)
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#102
  def return_value_node_of_scope(scope); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#96
  def similar_name_message(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#124
  def variable_like_method_invocation?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#35
RuboCop::Cop::Lint::UselessAssignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks for comparison of something with itself.
#
# @example
#
#   # bad
#
#   x.top >= x.top
#
# source://rubocop//lib/rubocop/cop/lint/useless_comparison.rb#13
class RuboCop::Cop::Lint::UselessComparison < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/useless_comparison.rb#20
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_comparison.rb#17
  def useless_comparison?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_comparison.rb#14
RuboCop::Cop::Lint::UselessComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/useless_comparison.rb#15
RuboCop::Cop::Lint::UselessComparison::OPS = T.let(T.unsafe(nil), Array)

# This cop checks for useless `else` in `begin..end` without `rescue`.
#
# @example
#
#   # bad
#
#   begin
#   do_something
#   else
#   do_something_else # This will never be run.
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue
#   handle_errors
#   else
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#29
class RuboCop::Cop::Lint::UselessElseWithoutRescue < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ParserDiagnostic

  private

  # source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#40
  def alternative_message(_diagnostic); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#36
  def relevant_diagnostic?(diagnostic); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#32
RuboCop::Cop::Lint::UselessElseWithoutRescue::MSG = T.let(T.unsafe(nil), String)

# This cop checks for setter call to local variable as the final
# expression of a function definition.
#
# @example
#
#   # bad
#
#   def something
#   x = Something.new
#   x.attr = 5
#   end
# @example
#
#   # good
#
#   def something
#   x = Something.new
#   x.attr = 5
#   x
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#27
class RuboCop::Cop::Lint::UselessSetterCall < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#31
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#31
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#52
  def setter_call_to_local_variable?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#56
  def last_expression(body); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#29
RuboCop::Cop::Lint::UselessSetterCall::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#28
RuboCop::Cop::Lint::UselessSetterCall::MSG = T.let(T.unsafe(nil), String)

# This class tracks variable assignments in a method body
# and if a variable contains object passed as argument at the end of
# the method.
#
# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#65
class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  # @return [MethodVariableTracker] a new instance of MethodVariableTracker
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#66
  def initialize(body_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#154
  def constructor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#71
  def contain_local_object?(variable_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#143
  def process_assignment(asgn_node, rhs_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#91
  def process_assignment_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#133
  def process_binary_operator_assignment(op_asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#124
  def process_logical_operator_assignment(asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#105
  def process_multiple_assignment(masgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#81
  def scan(node, &block); end
end

# This cop checks for operators, variables, literals, and nonmutating
# methods used in void context.
#
# @example
#
#   # bad
#
#   def some_method
#   some_num * 10
#   do_something
#   end
# @example
#
#   # bad
#
#   def some_method(some_var)
#   some_var
#   do_something
#   end
# @example
#
#   # bad, when CheckForMethodsWithNoSideEffects is set true
#
#   def some_method(some_array)
#   some_array.sort
#   do_something(some_array)
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   some_num * 10
#   end
# @example
#
#   # good
#
#   def some_method(some_var)
#   do_something
#   some_var
#   end
# @example
#
#   # good, when CheckForMethodsWithNoSideEffects is set true
#
#   def some_method(some_array)
#   some_array.sort!
#   do_something(some_array)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/void.rb#62
class RuboCop::Cop::Lint::Void < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/lint/void.rb#90
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#83
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#90
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/void.rb#97
  def check_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#144
  def check_defined(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#105
  def check_expression(expr); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#132
  def check_literal(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#150
  def check_nonmutating(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#138
  def check_self(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#124
  def check_var(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#116
  def check_void_op(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/void.rb#160
  def in_void_context?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/void.rb#71
RuboCop::Cop::Lint::Void::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#67
RuboCop::Cop::Lint::Void::DEFINED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#65
RuboCop::Cop::Lint::Void::LIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#75
RuboCop::Cop::Lint::Void::NONMUTATING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#68
RuboCop::Cop::Lint::Void::NONMUTATING_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#73
RuboCop::Cop::Lint::Void::OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#63
RuboCop::Cop::Lint::Void::OP_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#66
RuboCop::Cop::Lint::Void::SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#72
RuboCop::Cop::Lint::Void::UNARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#64
RuboCop::Cop::Lint::Void::VAR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#74
RuboCop::Cop::Lint::Void::VOID_CONTEXT_TYPES = T.let(T.unsafe(nil), Array)

# Common functionality for obtaining source ranges from regexp matches
#
# source://rubocop//lib/rubocop/cop/mixin/match_range.rb#6
module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp

  private

  # Return a new `Range` covering the first matching group number for each
  # match of `regex` inside `range`
  #
  # source://rubocop//lib/rubocop/cop/mixin/match_range.rb#13
  def each_match_range(range, regex); end

  # For a `match` inside `range`, return a new `Range` covering the match
  #
  # source://rubocop//lib/rubocop/cop/mixin/match_range.rb#20
  def match_range(range, match); end
end

# Message Annotator class annotates a basic offense message
# based on params passed into initializer.
#
#  #=> 'Cop/CopName: message (http://example.org/styleguide)'
#
# @example
#   RuboCop::Cop::MessageAnnotator.new(
#   config, cop_config, @options
#   ).annotate('message', 'Cop/CopName')
# @see #initialize
#
# source://rubocop//lib/rubocop/cop/message_annotator.rb#15
class RuboCop::Cop::MessageAnnotator
  # @option cop_config
  # @option cop_config
  # @option cop_config
  # @option options
  # @option options
  # @option options
  # @option options
  # @param config [RuboCop::Config] Check configs for all cops
  #   @note Message Annotator specifically checks the
  #   following config options for_all_cops
  #   :StyleGuideBaseURL [String] URL for styleguide
  #   :DisplayStyleGuide [Boolean] Include styleguide and reference URLs
  #   :ExtraDetails [Boolean] Include cop details
  #   :DisplayCopNames [Boolean] Include cop name
  # @param cop_config [Hash] configs for specific cop, from config#for_cop
  # @param options [Hash, nil] optional
  # @return [MessageAnnotator] a new instance of MessageAnnotator
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#46
  def initialize(config, cop_config, options); end

  # Returns the annotated message,
  # based on params passed into initializer
  #
  # @return [String] annotated message
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#56
  def annotate(message, name); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def config; end

  # Returns the value of attribute cop_config.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def cop_config; end

  # Returns the value of attribute options.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def options; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#66
  def urls; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#101
  def debug?; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#113
  def details; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#105
  def display_cop_names?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#86
  def display_style_guide?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#97
  def extra_details?; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#92
  def reference_urls; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#72
  def style_guide_url; end

  class << self
    # Returns the value of attribute style_guide_urls.
    #
    # source://rubocop//lib/rubocop/cop/message_annotator.rb#21
    def style_guide_urls; end
  end
end

# This module handles measurement and reporting of complexity in methods.
#
# source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#6
module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#23
  def define_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#15
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#10
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#10
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#30
  def check_complexity(node, method_name); end

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#49
  def complexity(body); end
end

# Common code for cops that deal with preferred methods.
#
# source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#6
module RuboCop::Cop::MethodPreference
  private

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#26
  def default_cop_config; end

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#9
  def preferred_method(method); end

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#13
  def preferred_methods; end
end

# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#5
module RuboCop::Cop::Metrics; end

# This cop checks that the ABC size of methods is not higher than the
# configured maximum. The ABC size is based on assignments, branches
# (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric
# and https://en.wikipedia.org/wiki/ABC_Software_Metric.
#
# source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#10
class RuboCop::Cop::Metrics::AbcSize < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::MethodComplexity

  private

  # source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#18
  def complexity(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#13
RuboCop::Cop::Metrics::AbcSize::MSG = T.let(T.unsafe(nil), String)

# This cop checks if the length of a block exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
# The cop can be configured to ignore blocks passed to certain methods.
#
# source://rubocop//lib/rubocop/cop/metrics/block_length.rb#10
class RuboCop::Cop::Metrics::BlockLength < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::TooManyLines

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#15
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#44
  def cop_label; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#24
  def excluded_method?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#40
  def excluded_methods; end
end

# source://rubocop//lib/rubocop/cop/metrics/block_length.rb#13
RuboCop::Cop::Metrics::BlockLength::LABEL = T.let(T.unsafe(nil), String)

# This cop checks for excessive nesting of conditional and looping
# constructs.
#
# You can configure if blocks are considered using the `CountBlocks`
# option. When set to `false` (the default) blocks are not counted
# towards the nesting level. Set to `true` to count blocks as well.
#
# The maximum level of nesting allowed is configurable.
#
# source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#14
class RuboCop::Cop::Metrics::BlockNesting < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#22
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#31
  def check_nesting_level(node, max, current_level); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#49
  def consider_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#59
  def count_blocks?; end

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#55
  def message(max); end
end

# source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#17
RuboCop::Cop::Metrics::BlockNesting::NESTING_BLOCKS = T.let(T.unsafe(nil), Array)

# This cop checks if the length a class exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
#
# source://rubocop//lib/rubocop/cop/metrics/class_length.rb#9
class RuboCop::Cop::Metrics::ClassLength < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ClassishLength

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#24
  def class_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#16
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#12
  def on_class(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#28
  def message(length, max_length); end
end

# This cop checks that the cyclomatic complexity of methods is not higher
# than the configured maximum. The cyclomatic complexity is the number of
# linearly independent paths through a method. The algorithm counts
# decision points and adds one.
#
# An if statement (or unless or ?:) increases the complexity by one. An
# else branch does not, since it doesn't add a decision point. The &&
# operator (or keyword and) can be converted to a nested if statement,
# and ||/or is shorthand for a sequence of ifs, so they also add one.
# Loops can be said to have an exit condition, so they add one.
#
# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#16
class RuboCop::Cop::Metrics::CyclomaticComplexity < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::MethodComplexity

  private

  # source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#26
  def complexity_score_for(_node); end
end

# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#21
RuboCop::Cop::Metrics::CyclomaticComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#19
RuboCop::Cop::Metrics::CyclomaticComplexity::MSG = T.let(T.unsafe(nil), String)

# This cop checks the length of lines in the source code.
# The maximum length is configurable.
# The tab size is configured in the `IndentationWidth`
# of the `Layout/Tab` cop.
#
# source://rubocop//lib/rubocop/cop/metrics/line_length.rb#12
class RuboCop::Cop::Metrics::LineLength < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#19
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#92
  def allow_heredoc?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#117
  def allow_uri?; end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#96
  def allowed_heredoc; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#125
  def allowed_uri_position?(line, uri_range); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#164
  def check_directive_line(line, index); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#46
  def check_line(line, index, heredocs); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#195
  def check_uri_line(line, index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#178
  def directive_on_source_line?(index); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#77
  def excess_range(uri_range, line, index); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#100
  def extract_heredocs(ast); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#131
  def find_excessive_uri_range(line); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#42
  def highligh_start(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#121
  def ignore_cop_directives?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#64
  def ignored_line?(line, index, heredocs); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#32
  def indentation_difference(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#110
  def line_in_permitted_heredoc?(heredocs, line_number); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#38
  def line_length(line); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#190
  def line_length_without_directive(line); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#144
  def match_uris(string); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#88
  def max; end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#69
  def register_offense(loc, line); end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#28
  def tab_indentation_width; end

  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#159
  def uri_regexp; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/line_length.rb#152
  def valid_uri?(uri_ish_string); end
end

# source://rubocop//lib/rubocop/cop/metrics/line_length.rb#17
RuboCop::Cop::Metrics::LineLength::MSG = T.let(T.unsafe(nil), String)

# This cop checks if the length of a method exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
#
# source://rubocop//lib/rubocop/cop/metrics/method_length.rb#9
class RuboCop::Cop::Metrics::MethodLength < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::TooManyLines

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#22
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#14
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#14
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#30
  def cop_label; end
end

# source://rubocop//lib/rubocop/cop/metrics/method_length.rb#12
RuboCop::Cop::Metrics::MethodLength::LABEL = T.let(T.unsafe(nil), String)

# This cop checks if the length a module exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
#
# source://rubocop//lib/rubocop/cop/metrics/module_length.rb#9
class RuboCop::Cop::Metrics::ModuleLength < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ClassishLength

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#24
  def module_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#16
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#12
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#28
  def message(length, max_length); end
end

# This cop checks for methods with too many parameters.
# The maximum number of parameters is configurable.
# Keyword arguments can optionally be excluded from the total count.
#
# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#9
class RuboCop::Cop::Metrics::ParameterLists < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#28
  def argument_to_lambda_or_proc?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#15
  def on_args(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#36
  def args_count(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#48
  def count_keyword_args?; end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#44
  def max_params; end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#32
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#12
RuboCop::Cop::Metrics::ParameterLists::MSG = T.let(T.unsafe(nil), String)

# This cop tries to produce a complexity score that's a measure of the
# complexity the reader experiences when looking at a method. For that
# reason it considers `when` nodes as something that doesn't add as much
# complexity as an `if` or a `&&`. Except if it's one of those special
# `case`/`when` constructs where there's no expression after `case`. Then
# the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when`
# nodes count. In contrast to the CyclomaticComplexity cop, this cop
# considers `else` nodes as adding complexity.
#
# @example
#
#   def my_method                   # 1
#   if cond                       # 1
#   case var                    # 2 (0.8 + 4 * 0.2, rounded)
#   when 1 then func_one
#   when 2 then func_two
#   when 3 then func_three
#   when 4..10 then func_other
#   end
#   else                          # 1
#   do_something until a && b   # 2
#   end                           # ===
#   end                             # 7 complexity points
#
# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#29
class RuboCop::Cop::Metrics::PerceivedComplexity < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::MethodComplexity

  private

  # source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#39
  def complexity_score_for(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#34
RuboCop::Cop::Metrics::PerceivedComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#32
RuboCop::Cop::Metrics::PerceivedComplexity::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#6
module RuboCop::Cop::Metrics::Utils; end

# > ABC is .. a software size metric .. computed by counting the number
# > of assignments, branches and conditions for a section of code.
# > http://c2.com/cgi/wiki?AbcMetric
#
# We separate the *calculator* from the *cop* so that the calculation,
# the formula itself, is easier to test.
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#13
class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  # @return [AbcSizeCalculator] a new instance of AbcSizeCalculator
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#28
  def initialize(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#35
  def calculate; end

  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#50
  def evaluate_branch_nodes(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#58
  def node_has_else_branch?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#24
    def calculate(node); end
  end
end

# > Branch -- an explicit forward program branch out of scope -- a
# > function call, class method call ..
# > http://c2.com/cgi/wiki?AbcMetric
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#17
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::BRANCH_NODES = T.let(T.unsafe(nil), Array)

# > Condition -- a logical/Boolean test, == != <= >= < > else case
# > default try catch ? and unary conditionals.
# > http://c2.com/cgi/wiki?AbcMetric
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#22
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::CONDITION_NODES = T.let(T.unsafe(nil), Array)

# Common functionality for checking minimum body length.
#
# source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#6
module RuboCop::Cop::MinBodyLength
  private

  # source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#13
  def min_body_length; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#9
  def min_body_length?(node); end
end

# Common functionality for checking multiline method calls and binary
# operations.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#7
module RuboCop::Cop::MultilineExpressionIndentation
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#16
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#155
  def argument_in_method_call(node, kind); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#214
  def assignment_rhs(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#85
  def check(range, node, lhs, rhs); end

  # The correct indentation of `node` is usually `IndentationWidth`, with
  # one exception: prefix keywords.
  #
  # ```
  # while foo &&  # Here, `while` is called a "prefix keyword"
  #     bar       # This is called "special indentation"
  #   baz
  # end
  # ```
  #
  # Note that *postfix conditionals* do *not* get "special indentation".
  #
  # ```
  # next if foo &&
  #   bar # normal indentation, not special
  # ```
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#74
  def correct_indentation(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#185
  def disqualified_rhs?(candidate, ancestor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#231
  def grouped_expression?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#93
  def incorrect_style_detected(range, node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#104
  def indentation(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#145
  def indented_keyword_expression(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#235
  def inside_arg_list_parentheses?(node, ancestor); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#120
  def keyword_message_tail(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#130
  def kw_node_with_special_indentation(node); end

  # In a chain of method calls, we regard the top send node as the base
  # for indentation of all lines following the first. For example:
  # a.
  #   b c { block }.            <-- b is indented relative to a
  #   d                         <-- d is indented relative to a
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#33
  def left_hand_side(lhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#224
  def not_for_this_cop?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#108
  def operation_description(node, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#171
  def part_of_assignment_rhs(node, candidate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#210
  def part_of_block_body?(candidate, block_node); end

  # Returns true if `node` is a conditional whose `body` and `condition`
  # begin on the same line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#244
  def postfix_conditional?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#46
  def regular_method_right_hand_side(send_node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#38
  def right_hand_side(send_node); end

  # The []= operator and setters (a.b = c) are parsed as :send nodes.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#201
  def valid_method_rhs_candidate?(candidate, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#190
  def valid_rhs?(candidate, ancestor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#206
  def valid_rhs_candidate?(candidate, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#248
  def within_node?(inner, outer); end
end

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#12
RuboCop::Cop::MultilineExpressionIndentation::ASSIGNMENT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#11
RuboCop::Cop::MultilineExpressionIndentation::DEFAULT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#8
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#13
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#9
RuboCop::Cop::MultilineExpressionIndentation::UNALIGNED_RHS_TYPES = T.let(T.unsafe(nil), Array)

# Autocorrection logic for the closing brace of a literal either
# on the same line as the last contained elements, or a new line.
#
# source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#7
class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::RangeHelp

  # @return [MultilineLiteralBraceCorrector] a new instance of MultilineLiteralBraceCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#11
  def initialize(node, processed_source); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#16
  def call(corrector); end

  private

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#38
  def correct_next_line_brace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#34
  def correct_same_line_brace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#49
  def last_element_range_with_trailing_comma(node); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#58
  def last_element_trailing_comma_range(node); end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#32
  def node; end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#32
  def processed_source; end
end

# Common functionality for checking the closing brace of a literal is
# either on the same line as the last contained elements or a new line.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#7
module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  private

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#36
  def check(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#12
  def check_brace_layout(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#44
  def check_new_line(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#52
  def check_same_line(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#60
  def check_symmetrical(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#86
  def children(node); end

  # This method depends on the fact that we have guarded
  # against implicit and empty literals.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#98
  def closing_brace_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#74
  def empty_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#82
  def ignored_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#78
  def implicit_literal?(node); end

  # Starting with the parent node and recursively for the parent node's
  # children, check if the node is a HEREDOC and if the HEREDOC ends below
  # or on the last line of the parent node.
  #
  # Example:
  #
  #   # node is `b: ...` parameter
  #   # last_line_heredoc?(node) => false
  #   foo(a,
  #     b: {
  #       a: 1,
  #       c: <<-EOM
  #         baz
  #       EOM
  #     }
  #   )
  #
  #   # node is `b: ...` parameter
  #   # last_line_heredoc?(node) => true
  #   foo(a,
  #     b: <<-EOM
  #       baz
  #     EOM
  #   )
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#126
  def last_line_heredoc?(node, parent = T.unsafe(nil)); end

  # Returns true for the case
  #   [a,
  #    b # comment
  #   ].some_method
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#26
  def new_line_needed_before_closing_brace?(node); end

  # This method depends on the fact that we have guarded
  # against implicit and empty literals.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#92
  def opening_brace_on_same_line?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#5
module RuboCop::Cop::Naming; end

# This cop makes sure that accessor methods are named properly.
#
# @example
#   # bad
#   def set_attribute(value)
#   end
#
#   # good
#   def attribute=(value)
#   end
#
#   # bad
#   def get_attribute
#   end
#
#   # good
#   def attribute
#   end
#
# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#24
class RuboCop::Cop::Naming::AccessorMethodName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#28
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#28
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#45
  def bad_reader_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#49
  def bad_writer_name?(node); end

  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#37
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#25
RuboCop::Cop::Naming::AccessorMethodName::MSG_READER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#26
RuboCop::Cop::Naming::AccessorMethodName::MSG_WRITER = T.let(T.unsafe(nil), String)

# This cop checks for non-ascii characters in identifier names.
#
# @example
#   # bad
#   def  # Greek alphabet (non-ascii)
#   end
#
#   # bad
#   def  # Japanese character (non-ascii)
#   end
#
#   # bad
#   def hello_ # Emoji (non-ascii)
#   end
#
#   # good
#   def say_hello
#   end
#
#   # bad
#    = 10 # Hangul character (non-ascii)
#
#   # good
#   height = 10
#
#   # bad
#   params[:_gteq] # Arabic character (non-ascii)
#
#   # good
#   params[:width_gteq]
#
# source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#39
class RuboCop::Cop::Naming::AsciiIdentifiers < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#44
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#65
  def first_non_ascii_chars(string); end

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#54
  def first_offense_range(identifier); end
end

# source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#42
RuboCop::Cop::Naming::AsciiIdentifiers::MSG = T.let(T.unsafe(nil), String)

# This cop makes sure that certain binary operator methods have their
# sole  parameter named `other`.
#
# @example
#
#   # bad
#   def +(amount); end
#
#   # good
#   def +(other); end
#
# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#16
class RuboCop::Cop::Naming::BinaryOperatorParameterName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#27
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#23
  def op_method_candidate?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#35
  def op_method?(name); end
end

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#21
RuboCop::Cop::Naming::BinaryOperatorParameterName::BLACKLISTED = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#17
RuboCop::Cop::Naming::BinaryOperatorParameterName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#20
RuboCop::Cop::Naming::BinaryOperatorParameterName::OP_LIKE_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for class and module names with
# an underscore in them.
#
# @example
#   # bad
#   class My_Class
#   end
#   module My_Module
#   end
#
#   # good
#   class MyClass
#   end
#   module MyModule
#   end
#
# source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#21
class RuboCop::Cop::Naming::ClassAndModuleCamelCase < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#24
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#24
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#22
RuboCop::Cop::Naming::ClassAndModuleCamelCase::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether constant names are written using
# SCREAMING_SNAKE_CASE.
#
# To avoid false positives, it ignores cases in which we cannot know
# for certain the type of value that would be assigned to a constant.
#
# @example
#   # bad
#   InchInCm = 2.54
#   INCHinCM = 2.54
#   Inch_In_Cm = 2.54
#
#   # good
#   INCH_IN_CM = 2.54
#
# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#20
class RuboCop::Cop::Naming::ConstantName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#26
  def class_or_struct_return_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#66
  def literal_receiver?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#32
  def on_casgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#54
  def allowed_assignment?(value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#71
  def allowed_conditional_expression_on_rhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#61
  def allowed_method_call_on_rhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#75
  def contains_contant?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#21
RuboCop::Cop::Naming::ConstantName::MSG = T.let(T.unsafe(nil), String)

# Use POSIX character classes, so we allow accented characters rather
# than just standard ASCII characters
#
# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#24
RuboCop::Cop::Naming::ConstantName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

# This cop makes sure that Ruby source files have snake_case
# names. Ruby scripts (i.e. source files with a shebang in the
# first line) are ignored.
#
# The cop also ignores `.gemspec` files, because Bundler
# recommends using dashes to separate namespaces in nested gems
# (i.e. `bundler-console` becomes `Bundler::Console`). As such, the
# gemspec is supposed to be named `bundler-console.gemspec`.
#
# @example
#   # bad
#   lib/layoutManager.rb
#
#   anything/usingCamelCase
#
#   # good
#   lib/layout_manager.rb
#
#   anything/using_snake_case.rake
#
# source://rubocop//lib/rubocop/cop/naming/file_name.rb#27
class RuboCop::Cop::Naming::FileName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#38
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#94
  def allowed_acronyms; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#86
  def expect_matching_definition?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#98
  def filename_good?(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#108
  def find_class_or_module(node, namespace); end

  # @yield [source_range(processed_source.buffer, 1, 0), msg]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#50
  def for_bad_filename(file_path); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#82
  def ignore_executable_scripts?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#158
  def match?(expected); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#162
  def match_acronym?(expected, name); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#128
  def match_namespace(node, namespace, expected); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#68
  def no_definition_message(basename, file_path); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#74
  def other_message(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#142
  def partial_matcher!(expected); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#90
  def regex; end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#198
  def to_module_name(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#171
  def to_namespace(path); end
end

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#32
RuboCop::Cop::Naming::FileName::MSG_NO_DEFINITION = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#34
RuboCop::Cop::Naming::FileName::MSG_REGEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#30
RuboCop::Cop::Naming::FileName::MSG_SNAKE_CASE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#36
RuboCop::Cop::Naming::FileName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

# This cop checks that your heredocs are using the configured case.
# By default it is configured to enforce uppercase heredocs.
#
# @example EnforcedStyle: uppercase (default)
#   # bad
#   <<-sql
#   SELECT * FROM foo
#   sql
#
#   # good
#   <<-SQL
#   SELECT * FROM foo
#   SQL
# @example EnforcedStyle: lowercase
#   # bad
#   <<-SQL
#   SELECT * FROM foo
#   SQL
#
#   # good
#   <<-sql
#   SELECT * FROM foo
#   sql
#
# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#30
class RuboCop::Cop::Naming::HeredocDelimiterCase < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#36
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#48
  def correct_case_delimiters?(node); end

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#52
  def correct_delimiters(node); end

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#44
  def message(_node); end
end

# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#34
RuboCop::Cop::Naming::HeredocDelimiterCase::MSG = T.let(T.unsafe(nil), String)

# This cop checks that your heredocs are using meaningful delimiters.
# By default it disallows `END` and `EO*`, and can be configured through
# blacklisting additional delimiters.
#
# @example
#
#   # good
#   <<-SQL
#   SELECT * FROM foo
#   SQL
#
#   # bad
#   <<-END
#   SELECT * FROM foo
#   END
#
#   # bad
#   <<-EOS
#   SELECT * FROM foo
#   EOS
#
# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#26
class RuboCop::Cop::Naming::HeredocDelimiterNaming < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Heredoc

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#31
  def on_heredoc(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#49
  def blacklisted_delimiters; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#39
  def meaningful_delimiters?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#29
RuboCop::Cop::Naming::HeredocDelimiterNaming::MSG = T.let(T.unsafe(nil), String)

# This cop checks for memoized methods whose instance variable name
# does not match the method name.
#
# This cop can be configured with the EnforcedStyleForLeadingUnderscores
# directive. It can be configured to allow for memoized instance variables
# prefixed with an underscore. Prefixing ivars with an underscore is a
# convention that is used to implicitly indicate that an ivar should not
# be set or referencd outside of the memoization method.
#
# @example EnforcedStyleForLeadingUnderscores: disallowed (default)
#   # bad
#   # Method foo is memoized using an instance variable that is
#   # not `@foo`. This can cause confusion and bugs.
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= begin
#   calculate_expensive_thing
#   end
#   end
#
#   # good
#   def foo
#   helper_variable = something_we_need_to_calculate_foo
#   @foo ||= calculate_expensive_thing(helper_variable)
#   end
# @example EnforcedStyleForLeadingUnderscores: required
#   # bad
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   # bad
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @_foo ||= calculate_expensive_thing
#   end
# @example EnforcedStyleForLeadingUnderscores :optional
#   # bad
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @_foo ||= calculate_expensive_thing
#   end
#
# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#87
class RuboCop::Cop::Naming::MemoizedInstanceVariableName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#106
  def memoized?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#108
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#108
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#128
  def matches?(method_name, ivar_assign); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#138
  def message(variable); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#124
  def style_parameter_name; end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#147
  def suggested_var(method_name); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#153
  def variable_name_candidates(method_name); end

  class << self
    private

    # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#95
    def node_pattern; end
  end
end

# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#90
RuboCop::Cop::Naming::MemoizedInstanceVariableName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#92
RuboCop::Cop::Naming::MemoizedInstanceVariableName::UNDERSCORE_REQUIRED = T.let(T.unsafe(nil), String)

# This cop makes sure that all methods use the configured style,
# snake_case or camelCase, for their names.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   def fooBar; end
#
#   # good
#   def foo_bar; end
# @example EnforcedStyle: camelCase
#   # bad
#   def foo_bar; end
#
#   # good
#   def fooBar; end
#
# source://rubocop//lib/rubocop/cop/naming/method_name.rb#22
class RuboCop::Cop::Naming::MethodName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#27
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#27
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#36
  def message(style); end
end

# source://rubocop//lib/rubocop/cop/naming/method_name.rb#25
RuboCop::Cop::Naming::MethodName::MSG = T.let(T.unsafe(nil), String)

# This cop makes sure that predicates are named properly.
#
# @example
#   # bad
#   def is_even(value)
#   end
#
#   def is_even?(value)
#   end
#
#   # good
#   def even?(value)
#   end
#
#   # bad
#   def has_value
#   end
#
#   def has_value?
#   end
#
#   # good
#   def value?
#   end
#
# source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#30
class RuboCop::Cop::Naming::PredicateName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#31
  def dynamic_method_define(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#52
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#52
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#37
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#69
  def allowed_method_name?(method_name, prefix); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#76
  def expected_name(method_name, prefix); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#86
  def message(method_name, new_name); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#102
  def method_definition_macros(macro_name); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#94
  def predicate_prefixes; end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#98
  def predicate_whitelist; end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#90
  def prefix_blacklist; end
end

# This cop checks block parameter names for how descriptive they
# are. It is highly configurable.
#
# The `MinNameLength` config option takes an integer. It represents
# the minimum amount of characters the name must be. Its default is 1.
# The `AllowNamesEndingInNumbers` config option takes a boolean. When
# set to false, this cop will register offenses for names ending with
# numbers. Its default is false. The `AllowedNames` config option
# takes an array of whitelisted names that will never register an
# offense. The `ForbiddenNames` config option takes an array of
# blacklisted names that will always register an offense.
#
# @example
#   # bad
#   bar do |varOne, varTwo|
#   varOne + varTwo
#   end
#
#   # With `AllowNamesEndingInNumbers` set to false
#   foo { |num1, num2| num1 * num2 }
#
#   # With `MinParamNameLength` set to number greater than 1
#   baz { |a, b, c| do_stuff(a, b, c) }
#
#   # good
#   bar do |thud, fred|
#   thud + fred
#   end
#
#   foo { |speed, distance| speed * distance }
#
#   baz { |age, height, gender| do_stuff(age, height, gender) }
#
# source://rubocop//lib/rubocop/cop/naming/uncommunicative_block_param_name.rb#38
class RuboCop::Cop::Naming::UncommunicativeBlockParamName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop//lib/rubocop/cop/naming/uncommunicative_block_param_name.rb#41
  def on_block(node); end
end

# This cop checks method parameter names for how descriptive they
# are. It is highly configurable.
#
# The `MinNameLength` config option takes an integer. It represents
# the minimum amount of characters the name must be. Its default is 3.
# The `AllowNamesEndingInNumbers` config option takes a boolean. When
# set to false, this cop will register offenses for names ending with
# numbers. Its default is false. The `AllowedNames` config option
# takes an array of whitelisted names that will never register an
# offense. The `ForbiddenNames` config option takes an array of
# blacklisted names that will always register an offense.
#
# @example
#   # bad
#   def bar(varOne, varTwo)
#   varOne + varTwo
#   end
#
#   # With `AllowNamesEndingInNumbers` set to false
#   def foo(num1, num2)
#   num1 * num2
#   end
#
#   # With `MinArgNameLength` set to number greater than 1
#   def baz(a, b, c)
#   do_stuff(a, b, c)
#   end
#
#   # good
#   def bar(thud, fred)
#   thud + fred
#   end
#
#   def foo(speed, distance)
#   speed * distance
#   end
#
#   def baz(age_a, height_b, gender_c)
#   do_stuff(age_a, height_b, gender_c)
#   end
#
# source://rubocop//lib/rubocop/cop/naming/uncommunicative_method_param_name.rb#46
class RuboCop::Cop::Naming::UncommunicativeMethodParamName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop//lib/rubocop/cop/naming/uncommunicative_method_param_name.rb#49
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/uncommunicative_method_param_name.rb#49
  def on_defs(node); end
end

# This cop makes sure that all variables use the configured style,
# snake_case or camelCase, for their names.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   fooBar = 1
#
#   # good
#   foo_bar = 1
# @example EnforcedStyle: camelCase
#   # bad
#   foo_bar = 1
#
#   # good
#   fooBar = 1
#
# source://rubocop//lib/rubocop/cop/naming/variable_name.rb#22
class RuboCop::Cop::Naming::VariableName < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_blockarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_kwarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_kwrestarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_optarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#27
  def on_restarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#45
  def message(style); end
end

# source://rubocop//lib/rubocop/cop/naming/variable_name.rb#25
RuboCop::Cop::Naming::VariableName::MSG = T.let(T.unsafe(nil), String)

# This cop makes sure that all numbered variables use the
# configured style, snake_case, normalcase, or non_integer,
# for their numbering.
#
# @example EnforcedStyle: snake_case
#   # bad
#
#   variable1 = 1
#
#   # good
#
#   variable_1 = 1
# @example EnforcedStyle: normalcase (default)
#   # bad
#
#   variable_1 = 1
#
#   # good
#
#   variable1 = 1
# @example EnforcedStyle: non_integer
#   # bad
#
#   variable1 = 1
#
#   variable_1 = 1
#
#   # good
#
#   variableone = 1
#
#   variable_one = 1
#
# source://rubocop//lib/rubocop/cop/naming/variable_number.rb#40
class RuboCop::Cop::Naming::VariableNumber < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNumbering

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#45
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#45
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#45
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#45
  def on_lvasgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#55
  def message(style); end
end

# source://rubocop//lib/rubocop/cop/naming/variable_number.rb#43
RuboCop::Cop::Naming::VariableNumber::MSG = T.let(T.unsafe(nil), String)

# Some common code shared between `NegatedIf` and
# `NegatedWhile` cops.
#
# source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#7
module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#16
  def empty_condition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#15
  def single_negative?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#18
  def check_negative_conditional(node); end
end

# source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#10
RuboCop::Cop::NegativeConditional::MSG = T.let(T.unsafe(nil), String)

# This module provides a list of methods that are:
# 1. In the NilClass by default
# 2. Added to NilClass by explicitly requiring any standard libraries
# 3. Cop's configuration parameter Whitelist.
#
# source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#9
module RuboCop::Cop::NilMethods
  private

  # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#12
  def nil_methods; end

  # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#16
  def other_stdlib_methods; end

  # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#20
  def whitelist; end
end

# An offense represents a style violation detected by RuboCop.
#
# source://rubocop//lib/rubocop/cop/offense.rb#6
class RuboCop::Cop::Offense
  include ::Comparable

  # @api private
  # @return [Offense] a new instance of Offense
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#58
  def initialize(severity, location, message, cop_name, status = T.unsafe(nil)); end

  # Returns `-1`, `0`, or `+1`
  # if this offense is less than, equal to, or greater than `other`.
  #
  # @api public
  # @return [Integer] comparison result
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#185
  def <=>(other); end

  # @api public
  # @return [Boolean] returns `true` if two offenses contain same attributes
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#164
  def ==(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#113
  def column; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#123
  def column_length; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#147
  def column_range; end

  # @api public
  # @example
  #   'LineLength'
  # @return [String] a cop class name without department.
  #   i.e. type of the violation.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#52
  def cop_name; end

  # @api public
  # @return [Boolean] whether this offense is automatically corrected.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#74
  def corrected; end

  # @api public
  # @return [Boolean] whether this offense is automatically corrected.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#74
  def corrected?; end

  # @api public
  # @return [Boolean] whether this offense was locally disabled where it occurred
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#85
  def disabled?; end

  # @api public
  # @return [Boolean] returns `true` if two offenses contain same attributes
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#164
  def eql?(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#132
  def first_line; end

  # source://rubocop//lib/rubocop/cop/offense.rb#172
  def hash; end

  # @api public
  # @return [Parser::Source::Range] the range of the code that is highlighted
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#93
  def highlighted_area; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#142
  def last_column; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#137
  def last_line; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#108
  def line; end

  # @api public
  # @return [Parser::Source::Range] the location where the violation is detected.
  # @see https://www.rubydoc.info/gems/parser/Parser/Source/Range Parser::Source::Range
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#29
  def location; end

  # @api public
  # @example
  #   'Line is too long. [90/80]'
  # @return [String] human-readable message
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#40
  def message; end

  # Internally we use column number that start at 0, but when
  # outputting column numbers, we want them to start at 1. One
  # reason is that editors, such as Emacs, expect this.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#156
  def real_column; end

  # @api public
  # @return [RuboCop::Cop::Severity]
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#18
  def severity; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#118
  def source_line; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#55
  def status; end

  # This is just for debugging purpose.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#101
  def to_s; end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/offense.rb#10
RuboCop::Cop::Offense::COMPARISON_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# Common functionality for cops checking if and unless expressions.
#
# source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#6
module RuboCop::Cop::OnNormalIfUnless
  # source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#7
  def on_if(node); end
end

# This auto-corrects gem dependency order
#
# source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#6
class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode

  class << self
    # Returns the value of attribute comments_as_separators.
    #
    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#10
    def comments_as_separators; end

    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#12
    def correct(processed_source, node, previous_declaration, comments_as_separators); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#10
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#27
    def declaration_with_comment(node); end

    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#35
    def swap_range(corrector, range1, range2); end
  end
end

# Common functionality for Bundler/OrderedGems and
# Gemspec/OrderedDependencies.
#
# source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#7
module RuboCop::Cop::OrderedGemNode
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#18
  def case_insensitive_out_of_order?(string_a, string_b); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#22
  def consecutive_lines(previous, current); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#45
  def find_gem_name(gem_node); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#39
  def gem_name(declaration_node); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#10
  def get_source_range(node, comments_as_separators); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#30
  def register_offense(previous, current); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#51
  def treat_comments_as_separators; end
end

# Common functionality for handling parentheses.
#
# source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#6
module RuboCop::Cop::Parentheses
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#9
  def parens_required?(node); end
end

# This auto-corrects parentheses
#
# source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#6
class RuboCop::Cop::ParenthesesCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#8
    def correct(node); end

    private

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#25
    def next_char_is_question_mark?(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#21
    def ternary_condition?(node); end
  end
end

# Common functionality for cops which processes Parser's diagnostics.
# This mixin requires its user class to define `#relevant_diagnostic?`.
#
#     def relevant_diagnostic?(diagnostic)
#       diagnostic.reason == :my_interested_diagnostic_type
#     end
#
# If you want to use an alternative offense message rather than the one in
# Parser's diagnostic, define `#alternative_message`.
#
#     def alternative_message(diagnostic)
#       'My custom message'
#     end
#
# source://rubocop//lib/rubocop/cop/mixin/parser_diagnostic.rb#18
module RuboCop::Cop::ParserDiagnostic
  # source://rubocop//lib/rubocop/cop/mixin/parser_diagnostic.rb#19
  def investigate(processed_source); end
end

# Common functionality for handling percent arrays.
#
# source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#6
module RuboCop::Cop::PercentArray
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#21
  def allowed_bracket_array?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#44
  def check_bracketed_array(node); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#39
  def check_percent_array(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#30
  def comments_in_array?(node); end

  # Ruby does not allow percent arrays in an ambiguous block context.
  #
  # @example
  #
  #   foo %i[bar baz] { qux }
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#14
  def invalid_percent_array_context?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#26
  def message(_node); end
end

# Common functionality for handling percent literals.
#
# source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#6
module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#23
  def begin_source(node); end

  # A range containing only the contents of the percent literal (e.g. in
  # %i{1 2 3} this will be the range covering '1 2 3' only)
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#33
  def contents_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#11
  def percent_literal?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#17
  def process(node, *types); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#27
  def type(node); end
end

# This auto-corrects percent literals
#
# source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#6
class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # @return [PercentLiteralCorrector] a new instance of PercentLiteralCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#11
  def initialize(config, preferred_delimiters); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def config; end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#16
  def correct(node, char); end

  # Returns the value of attribute preferred_delimiters.
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def preferred_delimiters; end

  private

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#53
  def autocorrect_multiline_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#59
  def autocorrect_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#39
  def delimiters_for(type); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#111
  def end_content(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#35
  def escape_words?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#89
  def first_line?(node, previous_line_num); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#100
  def fix_escaped_content(word_node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#80
  def line_breaks(node, source, previous_line_num, base_line_num, node_indx); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#45
  def new_contents(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#93
  def process_lines(node, previous_line_num, base_line_num, source_in_lines); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#65
  def process_multiline_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#107
  def substitute_escaped_delimiters(content, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#26
  def wrap_contents(node, contents, char, delimiters); end
end

# source://rubocop//lib/rubocop/cop/performance/caller.rb#5
module RuboCop::Cop::Performance; end

# This cop identifies places where `caller[n]`
# can be replaced by `caller(n..n).first`.
#
# @example
#   # bad
#   caller[1]
#   caller.first
#   caller_locations[1]
#   caller_locations.first
#
#   # good
#   caller(2..2).first
#   caller(1..1).first
#   caller_locations(2..2).first
#   caller_locations(1..1).first
#
# source://rubocop//lib/rubocop/cop/performance/caller.rb#21
class RuboCop::Cop::Performance::Caller < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/caller.rb#34
  def caller_with_scope_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/caller.rb#41
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/caller.rb#27
  def slow_caller?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/caller.rb#63
  def int_value(node); end

  # source://rubocop//lib/rubocop/cop/performance/caller.rb#49
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/performance/caller.rb#22
RuboCop::Cop::Performance::Caller::MSG_BRACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/caller.rb#24
RuboCop::Cop::Performance::Caller::MSG_FIRST = T.let(T.unsafe(nil), String)

# Reordering `when` conditions with a splat to the end
# of the `when` branches can improve performance.
#
# Ruby has to allocate memory for the splat expansion every time
# that the `case` `when` statement is run. Since Ruby does not support
# fall through inside of `case` `when`, like some other languages do,
# the order of the `when` branches should not matter. By placing any
# splat expansions at the end of the list of `when` branches we will
# reduce the number of times that memory has to be allocated for
# the expansion. The exception to this is if multiple of your `when`
# conditions can be true for any given condition. A likely scenario for
# this defining a higher level when condition to override a condition
# that is inside of the splat expansion.
#
# This is not a guaranteed performance improvement. If the data being
# processed by the `case` condition is normalized in a manner that favors
# hitting a condition in the splat expansion, it is possible that
# moving the splat condition to the end will use more memory,
# and run slightly slower.
#
# @example
#   # bad
#   case foo
#   when *condition
#   bar
#   when baz
#   foobar
#   end
#
#   case foo
#   when *[1, 2, 3, 4]
#   bar
#   when 5
#   baz
#   end
#
#   # good
#   case foo
#   when baz
#   foobar
#   when *condition
#   bar
#   end
#
#   case foo
#   when 1, 2, 3, 4
#   bar
#   when 5
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#56
class RuboCop::Cop::Performance::CaseWhenSplat < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#76
  def autocorrect(when_node); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#65
  def on_case(case_node); end

  private

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#139
  def indent_for(node); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#93
  def inline_fix_branch(corrector, when_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#164
  def needs_reorder?(when_node); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#134
  def new_branch_without_then(node, new_condition); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#129
  def new_condition_with_then(node, new_condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#157
  def non_splat?(condition); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#101
  def reorder_condition(corrector, when_node); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#111
  def reordering_correction(when_node); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#88
  def replacement(conditions); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#143
  def splat_offenses(when_conditions); end

  # source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#121
  def when_branch_range(when_node); end
end

# source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#62
RuboCop::Cop::Performance::CaseWhenSplat::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/case_when_splat.rb#60
RuboCop::Cop::Performance::CaseWhenSplat::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where a case-insensitive string comparison
# can better be implemented using `casecmp`.
#
# @example
#   # bad
#   str.downcase == 'abc'
#   str.upcase.eql? 'ABC'
#   'abc' == str.downcase
#   'ABC'.eql? str.upcase
#   str.downcase == str.downcase
#
#   # good
#   str.casecmp('ABC').zero?
#   'abc'.casecmp(str).zero?
#
# source://rubocop//lib/rubocop/cop/performance/casecmp.rb#20
class RuboCop::Cop::Performance::Casecmp < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#38
  def downcase_downcase(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#24
  def downcase_eq(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#31
  def eq_downcase(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#45
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#95
  def build_good_method(arg, variable); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#85
  def correction(node, _receiver, method, arg, variable); end

  # source://rubocop//lib/rubocop/cop/performance/casecmp.rb#68
  def take_method_apart(node); end
end

# source://rubocop//lib/rubocop/cop/performance/casecmp.rb#22
RuboCop::Cop::Performance::Casecmp::CASE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/performance/casecmp.rb#21
RuboCop::Cop::Performance::Casecmp::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of
# Each of these methods (`compact`, `flatten`, `map`) will generate a
# new intermediate array that is promptly thrown away. Instead it is
# faster to mutate when we know it's safe.
#
# @example
#   # bad
#   array = ["a", "b", "c"]
#   array.compact.flatten.map { |x| x.downcase }
# @example
#   # good.
#   array = ["a", "b", "c"]
#   array.compact!
#   array.flatten!
#   array.map! { |x| x.downcase }
#   array
#
# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#23
class RuboCop::Cop::Performance::ChainArrayAllocation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#54
  def flat_map_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#62
  def on_send(node); end
end

# These methods ALWAYS return a new array
# after they're called it's safe to mutate the the resulting array
#
# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#39
RuboCop::Cop::Performance::ChainArrayAllocation::ALWAYS_RETURNS_NEW_ARRAY = T.let(T.unsafe(nil), String)

# These methods have a mutation alternative. For example :collect
# can be called as :collect!
#
# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#47
RuboCop::Cop::Performance::ChainArrayAllocation::HAS_MUTATION_ALTERNATIVE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#50
RuboCop::Cop::Performance::ChainArrayAllocation::MSG = T.let(T.unsafe(nil), String)

# These methods return a new array only when called without a block.
#
# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#35
RuboCop::Cop::Performance::ChainArrayAllocation::RETURNS_NEW_ARRAY_WHEN_NO_BLOCK = T.let(T.unsafe(nil), String)

# These methods return a new array but only sometimes. They must be
# called with an argument. For example:
#
#   [1,2].first    # => 1
#   [1,2].first(1) # => [1]
#
# source://rubocop//lib/rubocop/cop/performance/chain_array_allocation.rb#32
RuboCop::Cop::Performance::ChainArrayAllocation::RETURN_NEW_ARRAY_WHEN_ARGS = T.let(T.unsafe(nil), String)

# This cop identifies places where `sort { |a, b| a.foo <=> b.foo }`
# can be replaced by `sort_by(&:foo)`.
# This cop also checks `max` and `min` methods.
#
# @example
#   # bad
#   array.sort { |a, b| a.foo <=> b.foo }
#   array.max { |a, b| a.foo <=> b.foo }
#   array.min { |a, b| a.foo <=> b.foo }
#   array.sort { |a, b| a[:foo] <=> b[:foo] }
#
#   # good
#   array.sort_by(&:foo)
#   array.sort_by { |v| v.foo }
#   array.sort_by do |var|
#   var.foo
#   end
#   array.max_by(&:foo)
#   array.min_by(&:foo)
#   array.sort_by { |a| a[:foo] }
#
# source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#26
class RuboCop::Cop::Performance::CompareWithBlock < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#63
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#33
  def compare?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#47
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#40
  def replaceable_body?(node = T.unsafe(nil), param1, param2); end

  private

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#116
  def compare_range(send, node); end

  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#95
  def message(send, method, var_a, var_b, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#80
  def slow_compare?(method, args_a, args_b); end
end

# source://rubocop//lib/rubocop/cop/performance/compare_with_block.rb#29
RuboCop::Cop::Performance::CompareWithBlock::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of `count` on an `Enumerable` that
# follow calls to `select` or `reject`. Querying logic can instead be
# passed to the `count` call.
#
# `ActiveRecord` compatibility:
# `ActiveRecord` will ignore the block that is passed to `count`.
# Other methods, such as `select`, will convert the association to an
# array and then run the block on the array. A simple work around to
# make `count` work with a block is to call `to_a.count {...}`.
#
# Example:
#   Model.where(id: [1, 2, 3].select { |m| m.method == true }.size
#
#   becomes:
#
#   Model.where(id: [1, 2, 3]).to_a.count { |m| m.method == true }
#
# @example
#   # bad
#   [1, 2, 3].select { |e| e > 2 }.size
#   [1, 2, 3].reject { |e| e > 2 }.size
#   [1, 2, 3].select { |e| e > 2 }.length
#   [1, 2, 3].reject { |e| e > 2 }.length
#   [1, 2, 3].select { |e| e > 2 }.count { |e| e.odd? }
#   [1, 2, 3].reject { |e| e > 2 }.count { |e| e.even? }
#   array.select(&:value).count
#
#   # good
#   [1, 2, 3].count { |e| e > 2 }
#   [1, 2, 3].count { |e| e < 2 }
#   [1, 2, 3].count { |e| e > 2 && e.odd? }
#   [1, 2, 3].count { |e| e < 2 && e.even? }
#   Model.select('field AS field_one').count
#   Model.select(:value).count
#
# source://rubocop//lib/rubocop/cop/performance/count.rb#40
class RuboCop::Cop::Performance::Count < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SafeMode
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/count.rb#70
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/count.rb#46
  def count_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/count.rb#53
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/count.rb#86
  def eligible_node?(node); end

  # source://rubocop//lib/rubocop/cop/performance/count.rb#90
  def source_starting_at(node); end
end

# source://rubocop//lib/rubocop/cop/performance/count.rb#44
RuboCop::Cop::Performance::Count::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of
# `select.first`, `select.last`, `find_all.first`, and `find_all.last`
# and change them to use `detect` instead.
#
# `ActiveRecord` compatibility:
# `ActiveRecord` does not implement a `detect` method and `find` has its
# own meaning. Correcting ActiveRecord methods with this cop should be
# considered unsafe.
#
# @example
#   # bad
#   [].select { |item| true }.first
#   [].select { |item| true }.last
#   [].find_all { |item| true }.first
#   [].find_all { |item| true }.last
#
#   # good
#   [].detect { |item| true }
#   [].reverse.detect { |item| true }
#
# source://rubocop//lib/rubocop/cop/performance/detect.rb#25
class RuboCop::Cop::Performance::Detect < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SafeMode

  # source://rubocop//lib/rubocop/cop/performance/detect.rb#54
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/detect.rb#33
  def detect_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/detect.rb#40
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/detect.rb#75
  def accept_first_call?(receiver, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/detect.rb#101
  def lazy?(node); end

  # source://rubocop//lib/rubocop/cop/performance/detect.rb#96
  def preferred_method; end

  # source://rubocop//lib/rubocop/cop/performance/detect.rb#84
  def register_offense(node, receiver, second_method); end
end

# source://rubocop//lib/rubocop/cop/performance/detect.rb#28
RuboCop::Cop::Performance::Detect::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/detect.rb#30
RuboCop::Cop::Performance::Detect::REVERSE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for double `#start_with?` or `#end_with?` calls
# separated by `||`. In some cases such calls can be replaced
# with an single `#start_with?`/`#end_with?` call.
#
# @example
#   # bad
#   str.start_with?("a") || str.start_with?(Some::CONST)
#   str.start_with?("a", "b") || str.start_with?("c")
#   str.end_with?(var1) || str.end_with?(var2)
#
#   # good
#   str.start_with?("a", Some::CONST)
#   str.start_with?("a", "b", "c")
#   str.end_with?(var1, var2)
#
# source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#20
class RuboCop::Cop::Performance::DoubleStartEndWith < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#84
  def check_with_active_support_aliases(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#24
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#78
  def two_start_end_with_calls(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#65
  def add_offense_for_double_call(node, receiver, method, combined_args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#74
  def check_for_active_support_aliases?; end

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#61
  def combine_args(first_call_args, second_call_args); end

  # source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#53
  def process_source(node); end
end

# source://rubocop//lib/rubocop/cop/performance/double_start_end_with.rb#21
RuboCop::Cop::Performance::DoubleStartEndWith::MSG = T.let(T.unsafe(nil), String)

# This cop identifies unnecessary use of a regex where `String#end_with?`
# would suffice.
#
# @example
#   # bad
#   'abc'.match?(/bc\Z/)
#   'abc' =~ /bc\Z/
#   'abc'.match(/bc\Z/)
#
#   # good
#   'abc'.end_with?('bc')
#
# source://rubocop//lib/rubocop/cop/performance/end_with.rb#17
class RuboCop::Cop::Performance::EndWith < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/end_with.rb#40
  def autocorrect(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/end_with.rb#27
  def literal_at_end?(regex_str); end

  # source://rubocop//lib/rubocop/cop/performance/end_with.rb#34
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/end_with.rb#22
  def redundant_regex?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/end_with.rb#18
RuboCop::Cop::Performance::EndWith::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/end_with.rb#20
RuboCop::Cop::Performance::EndWith::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# Do not compute the size of statically sized objects.
#
# @example
#   # String methods
#   # bad
#   'foo'.size
#   %q[bar].count
#   %(qux).length
#
#   # Symbol methods
#   # bad
#   :fred.size
#   :'baz'.length
#
#   # Array methods
#   # bad
#   [1, 2, thud].count
#   %W(1, 2, bar).size
#
#   # Hash methods
#   # bad
#   { a: corge, b: grault }.length
#
#   # good
#   foo.size
#   bar.count
#   qux.length
#
#   # good
#   :"#{fred}".size
#   CONST = :baz.length
#
#   # good
#   [1, 2, *thud].count
#   garply = [1, 2, 3]
#   garly.size
#
#   # good
#   { a: corge, **grault }.length
#   waldo = { a: corge, b: grault }
#   waldo.size
#
# source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#48
class RuboCop::Cop::Performance::FixedSize < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#51
  def counter(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#55
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#71
  def allowed_argument?(arg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#75
  def allowed_parent?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#67
  def allowed_variable?(var); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#85
  def contains_double_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#79
  def contains_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#91
  def non_string_argument?(node); end
end

# source://rubocop//lib/rubocop/cop/performance/fixed_size.rb#49
RuboCop::Cop::Performance::FixedSize::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of
#
# @example
#   # bad
#   [1, 2, 3, 4].map { |e| [e, e] }.flatten(1)
#   [1, 2, 3, 4].collect { |e| [e, e] }.flatten(1)
#
#   # good
#   [1, 2, 3, 4].flat_map { |e| [e, e] }
#   [1, 2, 3, 4].map { |e| [e, e] }.flatten
#   [1, 2, 3, 4].collect { |e| [e, e] }.flatten
#
# source://rubocop//lib/rubocop/cop/performance/flat_map.rb#17
class RuboCop::Cop::Performance::FlatMap < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#25
  def flat_map_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#29
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#57
  def offense_for_levels(node, map_node, first_method, flatten); end

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#62
  def offense_for_method(node, map_node, first_method, flatten); end

  # source://rubocop//lib/rubocop/cop/performance/flat_map.rb#66
  def register_offense(node, map_node, first_method, flatten, message); end
end

# source://rubocop//lib/rubocop/cop/performance/flat_map.rb#21
RuboCop::Cop::Performance::FlatMap::FLATTEN_MULTIPLE_LEVELS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/flat_map.rb#20
RuboCop::Cop::Performance::FlatMap::MSG = T.let(T.unsafe(nil), String)

# This cop checks for inefficient searching of keys and values within
# hashes.
#
# `Hash#keys.include?` is less efficient than `Hash#key?` because
# the former allocates a new array and then performs an O(n) search
# through that array, while `Hash#key?` does not allocate any array and
# performs a faster O(1) search for the key.
#
# `Hash#values.include?` is less efficient than `Hash#value?`. While they
# both perform an O(n) search through all of the values, calling `values`
# allocates a new array while using `value?` does not.
#
# @example
#   # bad
#   { a: 1, b: 2 }.keys.include?(:a)
#   { a: 1, b: 2 }.keys.include?(:z)
#   h = { a: 1, b: 2 }; h.keys.include?(100)
#
#   # good
#   { a: 1, b: 2 }.key?(:a)
#   { a: 1, b: 2 }.has_key?(:z)
#   h = { a: 1, b: 2 }; h.key?(100)
#
#   # bad
#   { a: 1, b: 2 }.values.include?(2)
#   { a: 1, b: 2 }.values.include?('garbage')
#   h = { a: 1, b: 2 }; h.values.include?(nil)
#
#   # good
#   { a: 1, b: 2 }.value?(2)
#   { a: 1, b: 2 }.has_value?('garbage')
#   h = { a: 1, b: 2 }; h.value?(nil)
#
# source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#39
class RuboCop::Cop::Performance::InefficientHashSearch < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#52
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#40
  def inefficient_include?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#44
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#89
  def autocorrect_argument(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#93
  def autocorrect_hash_expression(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#71
  def autocorrect_method(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#78
  def current_method(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#66
  def message(node); end

  # source://rubocop//lib/rubocop/cop/performance/inefficient_hash_search.rb#82
  def use_long_method; end
end

# This cop identifies places where `lstrip.rstrip` can be replaced by
# `strip`.
#
# @example
#   # bad
#   'abc'.lstrip.rstrip
#   'abc'.rstrip.lstrip
#
#   # good
#   'abc'.strip
#
# source://rubocop//lib/rubocop/cop/performance/lstrip_rstrip.rb#16
class RuboCop::Cop::Performance::LstripRstrip < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/lstrip_rstrip.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/lstrip_rstrip.rb#21
  def lstrip_rstrip(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/lstrip_rstrip.rb#26
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/performance/lstrip_rstrip.rb#19
RuboCop::Cop::Performance::LstripRstrip::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `OpenStruct.new` calls.
# Instantiation of an `OpenStruct` invalidates
# Ruby global method cache as it causes dynamic method
# definition during program runtime.
# This could have an effect on performance,
# especially in case of single-threaded
# applications with multiple `OpenStruct` instantiations.
#
# @example
#   # bad
#   class MyClass
#   def my_method
#   OpenStruct.new(my_key1: 'my_value1', my_key2: 'my_value2')
#   end
#   end
#
#   # good
#   class MyClass
#   MyStruct = Struct.new(:my_key1, :my_key2)
#   def my_method
#   MyStruct.new('my_value1', 'my_value2')
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/performance/open_struct.rb#30
class RuboCop::Cop::Performance::OpenStruct < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/open_struct.rb#38
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/open_struct.rb#34
  def open_struct(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/open_struct.rb#31
RuboCop::Cop::Performance::OpenStruct::MSG = T.let(T.unsafe(nil), String)

# This cop identifies uses of `Range#include?`, which iterates over each
# item in a `Range` to see if a specified item is there. In contrast,
# `Range#cover?` simply compares the target item with the beginning and
# end points of the `Range`. In a great majority of cases, this is what
# is wanted.
#
# This cop is `Safe: false` by default because `Range#include?` and
# `Range#cover?` are not equivalent behaviour.
#
# @example
#   # bad
#   ('a'..'z').include?('b') # => true
#
#   # good
#   ('a'..'z').cover?('b') # => true
#
#   # Example of a case where `Range#cover?` may not provide
#   # the desired result:
#
#   ('a'..'z').cover?('yellow') # => true
#
# source://rubocop//lib/rubocop/cop/performance/range_include.rb#26
class RuboCop::Cop::Performance::RangeInclude < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/range_include.rb#44
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/range_include.rb#38
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/range_include.rb#34
  def range_include(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/range_include.rb#27
RuboCop::Cop::Performance::RangeInclude::MSG = T.let(T.unsafe(nil), String)

# This cop identifies the use of a `&block` parameter and `block.call`
# where `yield` would do just as well.
#
# @example
#   # bad
#   def method(&block)
#   block.call
#   end
#   def another(&func)
#   func.call 1, 2, 3
#   end
#
#   # good
#   def method
#   yield
#   end
#   def another
#   yield 1, 2, 3
#   end
#
# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#25
class RuboCop::Cop::Performance::RedundantBlockCall < ::RuboCop::Cop::Cop
  # offenses are registered on the `block.call` nodes
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#56
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#41
  def blockarg_assigned?(node0, param1); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#37
  def blockarg_calls(node0, param1); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#32
  def blockarg_def(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#45
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#85
  def args_include_block_pass?(blockcall); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#75
  def calls_to_report(argname, body); end
end

# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#29
RuboCop::Cop::Performance::RedundantBlockCall::CLOSE_PAREN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#26
RuboCop::Cop::Performance::RedundantBlockCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#28
RuboCop::Cop::Performance::RedundantBlockCall::OPEN_PAREN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#30
RuboCop::Cop::Performance::RedundantBlockCall::SPACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/redundant_block_call.rb#27
RuboCop::Cop::Performance::RedundantBlockCall::YIELD = T.let(T.unsafe(nil), String)

# This cop identifies the use of `Regexp#match` or `String#match`, which
# returns `#<MatchData>`/`nil`. The return value of `=~` is an integral
# index/`nil` and is more performant.
#
# @example
#   # bad
#   do_something if str.match(/regex/)
#   while regex.match('str')
#   do_something
#   end
#
#   # good
#   method(str =~ /regex/)
#   return value unless regex =~ 'str'
#
# source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#20
class RuboCop::Cop::Performance::RedundantMatch < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#43
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#26
  def match_call?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#35
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#31
  def only_truthiness_matters?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/redundant_match.rb#21
RuboCop::Cop::Performance::RedundantMatch::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where `Hash#merge!` can be replaced by
# `Hash#[]=`.
#
# @example
#   hash.merge!(a: 1)
#   hash.merge!({'key' => 'value'})
#   hash.merge!(a: 1, b: 2)
#
# source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#13
class RuboCop::Cop::Performance::RedundantMerge < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#27
  def modifier_flow_control?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#31
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#23
  def redundant_merge_candidate(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#86
  def correct_multiple_elements(node, parent, new_source); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#98
  def correct_single_element(node, new_source); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#59
  def each_redundant_merge(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#130
  def indent_width; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#77
  def kwsplat_used?(pairs); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#126
  def leading_spaces(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#134
  def max_key_value_pairs; end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#51
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#67
  def non_redundant_merge?(node, receiver, pairs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#73
  def non_redundant_pairs?(receiver, pairs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#81
  def non_redundant_value_used?(receiver, node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#114
  def rewrite_with_modifier(node, parent, new_source); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#102
  def to_assignments(receiver, pairs); end
end

# source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#14
RuboCop::Cop::Performance::RedundantMerge::AREF_ASGN = T.let(T.unsafe(nil), String)

# A utility class for checking the use of values within an
# `each_with_object` call.
#
# source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#140
class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  extend ::RuboCop::NodePattern::Macros

  # @return [EachWithObjectInspector] a new instance of EachWithObjectInspector
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#143
  def initialize(node, receiver); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#176
  def each_with_object_node(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#148
  def value_used?; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#158
  def eligible_receiver?; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#156
  def node; end

  # Returns the value of attribute receiver.
  #
  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#156
  def receiver; end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#162
  def second_argument; end

  # source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#169
  def unwind(receiver); end
end

# source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#15
RuboCop::Cop::Performance::RedundantMerge::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/redundant_merge.rb#17
RuboCop::Cop::Performance::RedundantMerge::WITH_MODIFIER_CORRECTION = T.let(T.unsafe(nil), String)

# This cop identifies places where `sort_by { ... }` can be replaced by
# `sort`.
#
# @example
#   # bad
#   array.sort_by { |x| x }
#   array.sort_by do |var|
#   var
#   end
#
#   # good
#   array.sort
#
# source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#18
class RuboCop::Cop::Performance::RedundantSortBy < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#27
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#23
  def redundant_sort_by(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#44
  def sort_by_range(send, node); end
end

# source://rubocop//lib/rubocop/cop/performance/redundant_sort_by.rb#21
RuboCop::Cop::Performance::RedundantSortBy::MSG = T.let(T.unsafe(nil), String)

# In Ruby 2.4, `String#match?`, `Regexp#match?`, and `Symbol#match?`
# have been added. The methods are faster than `match`.
# Because the methods avoid creating a `MatchData` object or saving
# backref.
# So, when `MatchData` is not used, use `match?` instead of `match`.
#
# @example
#   # bad
#   def foo
#   if x =~ /re/
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if x !~ /re/
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if x.match(/re/)
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if /re/ === x
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if x.match?(/re/)
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if !x.match?(/re/)
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if x =~ /re/
#   do_something(Regexp.last_match)
#   end
#   end
#
#   # good
#   def foo
#   if x.match(/re/)
#   do_something($~)
#   end
#   end
#
#   # good
#   def foo
#   if /re/ === x
#   do_something($~)
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#75
class RuboCop::Cop::Performance::RegexpMatch < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#144
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#121
  def last_matches(node0); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#87
  def match_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#118
  def match_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#94
  def match_operator?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#98
  def match_threequals?(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#102
  def match_with_lvasgn?(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#134
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#130
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#119
  def search_match_nodes(node0); end

  private

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#160
  def check_condition(cond); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#235
  def correct_operator(corrector, recv, arg, oper = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#256
  def correction_range(recv, arg); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#195
  def find_last_match(body, range, scope_root); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#172
  def last_match_used?(match_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#224
  def match_gvar?(sym); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#168
  def message(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#187
  def next_match_pos(body, match_node_pos, scope_root); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#203
  def scope_body(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#215
  def scope_root(node); end

  # source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#251
  def swap_receiver_and_arg(corrector, recv, arg); end
end

# source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#109
RuboCop::Cop::Performance::RegexpMatch::MATCH_NODE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#83
RuboCop::Cop::Performance::RegexpMatch::MSG = T.let(T.unsafe(nil), String)

# Constants are included in this list because it is unlikely that
# someone will store `nil` as a constant and then use it for comparison
#
# source://rubocop//lib/rubocop/cop/performance/regexp_match.rb#82
RuboCop::Cop::Performance::RegexpMatch::TYPES_IMPLEMENTING_MATCH = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `reverse.each` and
# change them to use `reverse_each` instead.
#
# @example
#   # bad
#   [].reverse.each
#
#   # good
#   [].reverse_each
#
# source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#15
class RuboCop::Cop::Performance::ReverseEach < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#25
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#21
  def reverse_each?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#18
RuboCop::Cop::Performance::ReverseEach::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/reverse_each.rb#19
RuboCop::Cop::Performance::ReverseEach::UNDERSCORE = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of `shuffle.first`,
# `shuffle.last`, and `shuffle[]` and change them to use
# `sample` instead.
#
# @example
#   # bad
#   [1, 2, 3].shuffle.first
#   [1, 2, 3].shuffle.first(2)
#   [1, 2, 3].shuffle.last
#   [2, 1, 3].shuffle.at(0)
#   [2, 1, 3].shuffle.slice(0)
#   [1, 2, 3].shuffle[2]
#   [1, 2, 3].shuffle[0, 2]    # sample(2) will do the same
#   [1, 2, 3].shuffle[0..2]    # sample(3) will do the same
#   [1, 2, 3].shuffle(random: Random.new).first
#
#   # good
#   [1, 2, 3].shuffle
#   [1, 2, 3].sample
#   [1, 2, 3].sample(3)
#   [1, 2, 3].shuffle[1, 3]    # sample(3) might return a longer Array
#   [1, 2, 3].shuffle[1..3]    # sample(3) might return a longer Array
#   [1, 2, 3].shuffle[foo, bar]
#   [1, 2, 3].shuffle(random: Random.new)
#
# source://rubocop//lib/rubocop/cop/performance/sample.rb#30
class RuboCop::Cop::Performance::Sample < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/sample.rb#47
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#37
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#33
  def sample_candidate?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#123
  def correction(shuffle_arg, method, method_args); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#139
  def extract_source(args); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#117
  def message(shuffle_arg, method, method_args, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/sample.rb#59
  def offensive?(method, method_args); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#96
  def range_size(range_node); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#130
  def sample_arg(method, method_args); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#70
  def sample_size(method_args); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#79
  def sample_size_for_one_arg(arg); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#90
  def sample_size_for_two_args(first, second); end

  # source://rubocop//lib/rubocop/cop/performance/sample.rb#111
  def source_range(shuffle_node, node); end
end

# source://rubocop//lib/rubocop/cop/performance/sample.rb#31
RuboCop::Cop::Performance::Sample::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of `count` on an
# `Array` and `Hash` and change them to `size`.
#
# TODO: Add advanced detection of variables that could
# have been assigned to an array or a hash.
#
# @example
#   # bad
#   [1, 2, 3].count
#
#   # bad
#   {a: 1, b: 2, c: 3}.count
#
#   # good
#   [1, 2, 3].size
#
#   # good
#   {a: 1, b: 2, c: 3}.size
#
#   # good
#   [1, 2, 3].count { |e| e > 2 }
#
# source://rubocop//lib/rubocop/cop/performance/size.rb#26
class RuboCop::Cop::Performance::Size < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/size.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/size.rb#29
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/size.rb#53
  def allowed_parent?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/size.rb#57
  def array?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/size.rb#41
  def eligible_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/size.rb#47
  def eligible_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/size.rb#66
  def hash?(node); end
end

# source://rubocop//lib/rubocop/cop/performance/size.rb#27
RuboCop::Cop::Performance::Size::MSG = T.let(T.unsafe(nil), String)

# This cop identifies unnecessary use of a regex where
# `String#start_with?` would suffice.
#
# @example
#   # bad
#   'abc'.match?(/\Aab/)
#   'abc' =~ /\Aab/
#   'abc'.match(/\Aab/)
#
#   # good
#   'abc'.start_with?('ab')
#
# source://rubocop//lib/rubocop/cop/performance/start_with.rb#17
class RuboCop::Cop::Performance::StartWith < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/start_with.rb#43
  def autocorrect(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/start_with.rb#27
  def literal_at_start?(regex_str); end

  # source://rubocop//lib/rubocop/cop/performance/start_with.rb#37
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/start_with.rb#22
  def redundant_regex?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/start_with.rb#18
RuboCop::Cop::Performance::StartWith::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/start_with.rb#20
RuboCop::Cop::Performance::StartWith::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# This cop identifies places where `gsub` can be replaced by
# `tr` or `delete`.
#
# @example
#   # bad
#   'abc'.gsub('b', 'd')
#   'abc'.gsub('a', '')
#   'abc'.gsub(/a/, 'd')
#   'abc'.gsub!('a', 'd')
#
#   # good
#   'abc'.gsub(/.*/, 'a')
#   'abc'.gsub(/a+/, 'd')
#   'abc'.tr('b', 'd')
#   'a b c'.delete(' ')
#
# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#21
class RuboCop::Cop::Performance::StringReplacement < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#37
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#62
  def replace_method(node, first, second, first_param, replacement); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#31
  def string_replacement?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#83
  def accept_first_param?(first_param); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#78
  def accept_second_param?(second_param); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#110
  def first_source(first_param); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#153
  def message(node, first_source, second_source); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#160
  def method_suffix(node); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#99
  def offense(node, first_param, second_param); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#139
  def range(node); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#164
  def remove_second_param(corrector, node, first_param); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#143
  def replacement_method(node, first_source, second_source); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#128
  def source_from_regex_constructor(node); end

  # source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#121
  def source_from_regex_literal(node); end
end

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#28
RuboCop::Cop::Performance::StringReplacement::BANG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#26
RuboCop::Cop::Performance::StringReplacement::DELETE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#25
RuboCop::Cop::Performance::StringReplacement::DETERMINISTIC_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#24
RuboCop::Cop::Performance::StringReplacement::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#29
RuboCop::Cop::Performance::StringReplacement::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/string_replacement.rb#27
RuboCop::Cop::Performance::StringReplacement::TR = T.let(T.unsafe(nil), String)

# This cop checks for .times.map calls.
# In most cases such calls can be replaced
# with an explicit array creation.
#
# @example
#   # bad
#   9.times.map do |i|
#   i.to_s
#   end
#
#   # good
#   Array.new(9) do |i|
#   i.to_s
#   end
#
# source://rubocop//lib/rubocop/cop/performance/times_map.rb#20
class RuboCop::Cop::Performance::TimesMap < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#29
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#25
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#64
  def times_map_call(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#47
  def check(node); end

  # source://rubocop//lib/rubocop/cop/performance/times_map.rb#53
  def message(map_or_collect, count); end
end

# source://rubocop//lib/rubocop/cop/performance/times_map.rb#21
RuboCop::Cop::Performance::TimesMap::MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/performance/times_map.rb#23
RuboCop::Cop::Performance::TimesMap::MESSAGE_ONLY_IF = T.let(T.unsafe(nil), String)

# In Ruby 2.3 or later, use unary plus operator to unfreeze a string
# literal instead of `String#dup` and `String.new`.
# Unary plus operator is faster than `String#dup`.
#
# Note: `String.new` (without operator) is not exactly the same as `+''`.
# These differ in encoding. `String.new.encoding` is always `ASCII-8BIT`.
# However, `(+'').encoding` is the same as script encoding(e.g. `UTF-8`).
# So, if you expect `ASCII-8BIT` encoding, disable this cop.
#
# @example
#   # bad
#   ''.dup
#   "something".dup
#   String.new
#   String.new('')
#   String.new('something')
#
#   # good
#   +'something'
#   +''
#
# source://rubocop//lib/rubocop/cop/performance/unfreeze_string.rb#26
class RuboCop::Cop::Performance::UnfreezeString < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/performance/unfreeze_string.rb#33
  def dup_string?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/performance/unfreeze_string.rb#44
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/unfreeze_string.rb#37
  def string_new?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/unfreeze_string.rb#31
RuboCop::Cop::Performance::UnfreezeString::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify instances of sorting and then
# taking only the first or last element. The same behavior can
# be accomplished without a relatively expensive sort by using
# `Enumerable#min` instead of sorting and taking the first
# element and `Enumerable#max` instead of sorting and taking the
# last element. Similarly, `Enumerable#min_by` and
# `Enumerable#max_by` can replace `Enumerable#sort_by` calls
# after which only the first or last element is used.
#
# @example
#   # bad
#   [2, 1, 3].sort.first
#   [2, 1, 3].sort[0]
#   [2, 1, 3].sort.at(0)
#   [2, 1, 3].sort.slice(0)
#
#   # good
#   [2, 1, 3].min
#
#   # bad
#   [2, 1, 3].sort.last
#   [2, 1, 3].sort[-1]
#   [2, 1, 3].sort.at(-1)
#   [2, 1, 3].sort.slice(-1)
#
#   # good
#   [2, 1, 3].max
#
#   # bad
#   arr.sort_by(&:foo).first
#   arr.sort_by(&:foo)[0]
#   arr.sort_by(&:foo).at(0)
#   arr.sort_by(&:foo).slice(0)
#
#   # good
#   arr.min_by(&:foo)
#
#   # bad
#   arr.sort_by(&:foo).last
#   arr.sort_by(&:foo)[-1]
#   arr.sort_by(&:foo).at(-1)
#   arr.sort_by(&:foo).slice(-1)
#
#   # good
#   arr.max_by(&:foo)
#
# source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#52
class RuboCop::Cop::Performance::UnneededSort < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#89
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#74
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#58
  def unneeded_sort?(node = T.unsafe(nil)); end

  private

  # This gets the start of the accessor whether it has a dot
  # (e.g. `.first`) or doesn't (e.g. `[0]`)
  #
  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#155
  def accessor_start(node); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#145
  def arg_node(node); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#149
  def arg_value(node); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#129
  def base(accessor, arg); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#111
  def message(node, sorter, accessor); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#137
  def suffix(sorter); end

  # source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#125
  def suggestion(sorter, accessor, arg); end
end

# source://rubocop//lib/rubocop/cop/performance/unneeded_sort.rb#55
RuboCop::Cop::Performance::UnneededSort::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where `URI::Parser.new`
# can be replaced by `URI::DEFAULT_PARSER`.
#
# @example
#   # bad
#   URI::Parser.new
#
#   # good
#   URI::DEFAULT_PARSER
#
# source://rubocop//lib/rubocop/cop/performance/uri_default_parser.rb#16
class RuboCop::Cop::Performance::UriDefaultParser < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/performance/uri_default_parser.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/performance/uri_default_parser.rb#26
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/performance/uri_default_parser.rb#20
  def uri_parser_new?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/performance/uri_default_parser.rb#17
RuboCop::Cop::Performance::UriDefaultParser::MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking whether an AST node/token is aligned
# with something on a preceding or following line
#
# source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#7
module RuboCop::Cop::PrecedingFollowingAlignment
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#85
  def aligned_assignment?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#81
  def aligned_char?(range, line); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#60
  def aligned_comment_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#89
  def aligned_identical?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#73
  def aligned_operator?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#67
  def aligned_token?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#22
  def aligned_with_adjacent_line?(range, predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#40
  def aligned_with_any_line?(line_ranges, range, indent = T.unsafe(nil), &predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#30
  def aligned_with_any_line_range?(line_ranges, range, &predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#46
  def aligned_with_line?(line_nos, range, indent = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#18
  def aligned_with_operator?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#14
  def aligned_with_something?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#77
  def aligned_words?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#10
  def allow_for_alignment?; end
end

# Common functionality for handling percent literal delimiters.
#
# source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#6
class RuboCop::Cop::PreferredDelimiters
  # @return [PreferredDelimiters] a new instance of PreferredDelimiters
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#11
  def initialize(type, config, preferred_delimiters); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def config; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#17
  def delimiters; end

  # Returns the value of attribute type.
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def type; end

  private

  # @raise [ArgumentError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#23
  def ensure_valid_preferred_delimiters; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#32
  def preferred_delimiters; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#48
  def preferred_delimiters_config; end
end

# source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#9
RuboCop::Cop::PreferredDelimiters::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# This auto-corrects punctuation
#
# source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#6
class RuboCop::Cop::PunctuationCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#12
    def add_space(token); end

    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#8
    def remove_space(space_before); end

    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#16
    def swap_comma(range); end
  end
end

# source://rubocop//lib/rubocop/cop/rails/action_filter.rb#5
module RuboCop::Cop::Rails; end

# This cop enforces the consistent use of action filter methods.
#
# The cop is configurable and can enforce the use of the older
# something_filter methods or the newer something_action methods.
#
# If the TargetRailsVersion is set to less than 4.0, the cop will enforce
# the use of filter methods.
#
# @example EnforcedStyle: action (default)
#   # bad
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
#
#   # good
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
# @example EnforcedStyle: filter
#   # bad
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
#
#   # good
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
#
# source://rubocop//lib/rubocop/cop/rails/action_filter.rb#35
class RuboCop::Cop::Rails::ActionFilter < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#83
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#75
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#79
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#103
  def bad_methods; end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#92
  def check_method_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#107
  def good_methods; end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#98
  def message(node); end

  # source://rubocop//lib/rubocop/cop/rails/action_filter.rb#111
  def preferred_method(method); end
end

# source://rubocop//lib/rubocop/cop/rails/action_filter.rb#57
RuboCop::Cop::Rails::ActionFilter::ACTION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/action_filter.rb#41
RuboCop::Cop::Rails::ActionFilter::FILTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/action_filter.rb#39
RuboCop::Cop::Rails::ActionFilter::MSG = T.let(T.unsafe(nil), String)

# Checks that ActiveRecord aliases are not used. The direct method names
# are more clear and easier to read.
#
# @example
#   #bad
#   Book.update_attributes!(author: 'Alice')
#
#   #good
#   Book.update!(author: 'Alice')
#
# source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#15
class RuboCop::Cop::Rails::ActiveRecordAliases < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#23
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#23
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#18
RuboCop::Cop::Rails::ActiveRecordAliases::ALIASES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/rails/active_record_aliases.rb#16
RuboCop::Cop::Rails::ActiveRecordAliases::MSG = T.let(T.unsafe(nil), String)

# This cop checks that ActiveSupport aliases to core ruby methods
# are not used.
#
# @example
#   # good
#   'some_string'.start_with?('prefix')
#   'some_string'.end_with?('suffix')
#   [1, 2, 'a'] << 'b'
#   [1, 2, 'a'].unshift('b')
#
#   # bad
#   'some_string'.starts_with?('prefix')
#   'some_string'.ends_with?('suffix')
#   [1, 2, 'a'].append('b')
#   [1, 2, 'a'].prepend('b')
#
# source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#22
class RuboCop::Cop::Rails::ActiveSupportAliases < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#37
  def append(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#47
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#37
  def ends_with?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#40
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#37
  def prepend(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#37
  def starts_with?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#59
  def register_offense(node, method_name); end
end

# source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#25
RuboCop::Cop::Rails::ActiveSupportAliases::ALIASES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/rails/active_support_aliases.rb#23
RuboCop::Cop::Rails::ActiveSupportAliases::MSG = T.let(T.unsafe(nil), String)

# This cop checks that jobs subclass ApplicationJob with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Job < ApplicationJob
#   # ...
#   end
#
#   # bad
#   class Rails4Job < ActiveJob::Base
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/rails/application_job.rb#19
class RuboCop::Cop::Rails::ApplicationJob < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/application_job.rb#32
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/rails/application_job.rb#26
RuboCop::Cop::Rails::ApplicationJob::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/application_job.rb#24
RuboCop::Cop::Rails::ApplicationJob::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/application_job.rb#25
RuboCop::Cop::Rails::ApplicationJob::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that models subclass ApplicationRecord with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Model < ApplicationRecord
#   # ...
#   end
#
#   # bad
#   class Rails4Model < ActiveRecord::Base
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/rails/application_record.rb#19
class RuboCop::Cop::Rails::ApplicationRecord < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/application_record.rb#32
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/rails/application_record.rb#26
RuboCop::Cop::Rails::ApplicationRecord::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/application_record.rb#24
RuboCop::Cop::Rails::ApplicationRecord::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/application_record.rb#25
RuboCop::Cop::Rails::ApplicationRecord::SUPERCLASS = T.let(T.unsafe(nil), String)

# Use `assert_not` instead of `assert !`.
#
# @example
#   # bad
#   assert !x
#
#   # good
#   assert_not x
#
# source://rubocop//lib/rubocop/cop/rails/assert_not.rb#16
class RuboCop::Cop::Rails::AssertNot < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/assert_not.rb#25
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/assert_not.rb#19
  def offensive?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/assert_not.rb#21
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/assert_not.rb#38
  def corrected_source(source); end
end

# source://rubocop//lib/rubocop/cop/rails/assert_not.rb#17
RuboCop::Cop::Rails::AssertNot::MSG = T.let(T.unsafe(nil), String)

# This cop looks for belongs_to associations where we control whether the
# association is required via the deprecated `required` option instead.
#
# Since Rails 5, belongs_to associations are required by default and this
# can be controlled through the use of `optional: true`.
#
# From the release notes:
#
#     belongs_to will now trigger a validation error by default if the
#     association is not present. You can turn this off on a
#     per-association basis with optional: true. Also deprecate required
#     option in favor of optional for belongs_to. (Pull Request)
#
# In the case that the developer is doing `required: false`, we
# definitely want to autocorrect to `optional: true`.
#
# However, without knowing whether they've set overridden the default
# value of `config.active_record.belongs_to_required_by_default`, we
# can't say whether it's safe to remove `required: true` or whether we
# should replace it with `optional: false` (or, similarly, remove a
# superfluous `optional: false`). Therefore, in the cases we're using
# `required: true`, we'll simply invert it to `optional: false` and the
# user can remove depending on their defaults.
#
# @example
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: false
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: true
#   end
#
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: true
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: false
#   end
# @see https://guides.rubyonrails.org/5_0_release_notes.html
# @see https://github.com/rails/rails/pull/18937
#
# source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#53
class RuboCop::Cop::Rails::BelongsTo < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#95
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#108
  def extract_required_option(node); end

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#68
  def match_belongs_to_with_options(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#72
  def match_required_false?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#76
  def match_required_true?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#80
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#58
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_FALSE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/belongs_to.rb#62
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_TRUE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#blank?` defined by Active Support.
#
# @example NilOrEmpty: true (default)
#   # Converts usages of `nil? || empty?` to `blank?`
#
#   # bad
#   foo.nil? || foo.empty?
#   foo == nil || foo.empty?
#
#   # good
#   foo.blank?
# @example NotPresent: true (default)
#   # Converts usages of `!present?` to `blank?`
#
#   # bad
#   !foo.present?
#
#   # good
#   foo.blank?
# @example UnlessPresent: true (default)
#   # Converts usages of `unless present?` to `if blank?`
#
#   # bad
#   something unless foo.present?
#
#   # good
#   something if foo.blank?
#
#   # bad
#   unless foo.present?
#   something
#   end
#
#   # good
#   if foo.blank?
#   something
#   end
#
#   # good
#   def blank?
#   !present?
#   end
#
# source://rubocop//lib/rubocop/cop/rails/blank.rb#51
class RuboCop::Cop::Rails::Blank < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/blank.rb#126
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#78
  def defining_blank?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#61
  def nil_or_empty?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#76
  def not_present?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#111
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#98
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#84
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#80
  def unless_present?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#152
  def replacement(node); end

  # source://rubocop//lib/rubocop/cop/rails/blank.rb#144
  def unless_condition(node, method_call); end
end

# source://rubocop//lib/rubocop/cop/rails/blank.rb#52
RuboCop::Cop::Rails::Blank::MSG_NIL_OR_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/blank.rb#53
RuboCop::Cop::Rails::Blank::MSG_NOT_PRESENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/blank.rb#54
RuboCop::Cop::Rails::Blank::MSG_UNLESS_PRESENT = T.let(T.unsafe(nil), String)

# This Cop checks whether alter queries are combinable.
# If combinable queries are detected, it suggests to you
# to use `change_table` with `bulk: true` instead.
# This option causes the migration to generate a single
# ALTER TABLE statement combining multiple column alterations.
#
# The `bulk` option is only supported on the MySQL and
# the PostgreSQL (5.2 later) adapter; thus it will
# automatically detect an adapter from `development` environment
# in `config/database.yml` when the `Database` option is not set.
# If the adapter is not `mysql2` or `postgresql`,
# this Cop ignores offenses.
#
# @example
#   # bad
#   def change
#   add_column :users, :name, :string, null: false
#   add_column :users, :nickname, :string
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL
#   # ALTER TABLE `users` ADD `nickname` varchar(255)
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL,
#   #                     ADD `nickname` varchar(255)
#   end
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   # When you don't want to combine alter queries.
#   def change
#   change_table :users, bulk: false do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
#
# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#68
class RuboCop::Cop::Rails::BulkChangeTable < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#135
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#153
  def on_send(node); end

  private

  # @param node [RuboCop::AST::SendNode]
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#241
  def add_offense_for_alter_methods(node); end

  # @param node [RuboCop::AST::SendNode]
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#251
  def add_offense_for_change_table(node); end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#222
  def combinable_alter_methods; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#231
  def combinable_transformations; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#180
  def database; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#184
  def database_from_yaml; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#195
  def database_yaml; end

  # @param node [RuboCop::AST::SendNode] (send nil? :change_table ...)
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#171
  def include_bulk_options?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#209
  def support_bulk_alter?; end
end

# Record combinable alter methods and register offensive nodes.
#
# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#256
class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  # @return [AlterMethodsRecorder] a new instance of AlterMethodsRecorder
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#257
  def initialize; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#276
  def flush; end

  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#281
  def offensive_nodes; end

  # @param new_node [RuboCop::AST::SendNode]
  #
  # source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#263
  def process(new_node); end
end

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#105
RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#81
RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#79
RuboCop::Cop::Rails::BulkChangeTable::MIGRATION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#72
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_ALTER_METHODS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#69
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_CHANGE_TABLE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#76
RuboCop::Cop::Rails::BulkChangeTable::MYSQL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#120
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#114
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#77
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#130
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/bulk_change_table.rb#126
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# This cop checks the migration for which timestamps are not included
# when creating a new table.
# In many cases, timestamps are useful information and should be added.
#
# @example
#   # bad
#   create_table :users
#
#   # bad
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.timestamps
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :created_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :updated_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
#
# source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#43
class RuboCop::Cop::Rails::CreateTableWithTimestamps < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#46
  def create_table_with_block?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#53
  def create_table_with_timestamps_proc?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#61
  def created_at_or_updated_at_included?(node0); end

  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#67
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#57
  def timestamps_included?(node0); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#85
  def time_columns_included?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/create_table_with_timestamps.rb#44
RuboCop::Cop::Rails::CreateTableWithTimestamps::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the correct use of Date methods,
# such as Date.today, Date.current etc.
#
# Using `Date.today` is dangerous, because it doesn't know anything about
# Rails time zone. You must use `Time.zone.today` instead.
#
# The cop also reports warnings when you are using `to_time` method,
# because it doesn't know about Rails time zone either.
#
# Two styles are supported for this cop. When EnforcedStyle is 'strict'
# then the Date methods `today`, `current`, `yesterday`, and `tomorrow`
# are prohibited and the usage of both `to_time`
# and 'to_time_in_current_zone' are reported as warning.
#
# When EnforcedStyle is 'flexible' then only `Date.today` is prohibited
# and only `to_time` is reported as warning.
#
# @example EnforcedStyle: strict
#   # bad
#   Date.current
#   Date.yesterday
#   Date.today
#   date.to_time
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
# @example EnforcedStyle: flexible (default)
#   # bad
#   Date.today
#   date.to_time
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
#   Date.current
#   Date.yesterday
#   date.in_time_zone
#
# source://rubocop//lib/rubocop/cop/rails/date.rb#46
class RuboCop::Cop::Rails::Date < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/rails/date.rb#64
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#72
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#72
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/date.rb#142
  def bad_days; end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#146
  def bad_methods; end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#97
  def check_date_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#86
  def check_deprecated_methods(node); end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#108
  def extract_method_chain(node); end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#138
  def good_days; end

  # source://rubocop//lib/rubocop/cop/rails/date.rb#150
  def good_methods; end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/date.rb#114
  def method_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/date.rb#120
  def safe_chain?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/date.rb#126
  def safe_to_time?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/date.rb#55
RuboCop::Cop::Rails::Date::BAD_DAYS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/date.rb#57
RuboCop::Cop::Rails::Date::DEPRECATED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/date.rb#61
RuboCop::Cop::Rails::Date::DEPRECATED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/date.rb#49
RuboCop::Cop::Rails::Date::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/date.rb#52
RuboCop::Cop::Rails::Date::MSG_SEND = T.let(T.unsafe(nil), String)

# This cop looks for delegations that could have been created
# automatically with the `delegate` method.
#
# Safe navigation `&.` is ignored because Rails' `allow_nil`
# option checks not just for nil but also delegates if nil
# responds to the delegated method.
#
# The `EnforceForPrefixed` option (defaulted to `true`) means that
# using the target object as a prefix of the method name
# without using the `delegate` method will be a violation.
# When set to `false`, this case is legal.
#
# @example
#   # bad
#   def bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo
#
#   # good
#   def bar
#   foo&.bar
#   end
#
#   # good
#   private
#   def bar
#   foo.bar
#   end
# @example EnforceForPrefixed: true (default)
#   # bad
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
# @example EnforceForPrefixed: false
#   # good
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
#
# source://rubocop//lib/rubocop/cop/rails/delegate.rb#55
class RuboCop::Cop::Rails::Delegate < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#70
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#58
  def delegate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#63
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#94
  def arguments_match?(arg_array, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#111
  def include_prefix_case?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#106
  def method_name_matches?(method_name, body); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#115
  def prefixed_method_name(body); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#125
  def private_or_protected_before(line); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#119
  def private_or_protected_delegation(node); end

  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#129
  def private_or_protected_inline(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/delegate.rb#86
  def trivial_delegate?(def_node); end
end

# source://rubocop//lib/rubocop/cop/rails/delegate.rb#56
RuboCop::Cop::Rails::Delegate::MSG = T.let(T.unsafe(nil), String)

# This cop looks for delegations that pass :allow_blank as an option
# instead of :allow_nil. :allow_blank is not a valid option to pass
# to ActiveSupport#delegate.
#
# @example
#   # bad
#   delegate :foo, to: :bar, allow_blank: true
#
#   # good
#   delegate :foo, to: :bar, allow_nil: true
#
# source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#16
class RuboCop::Cop::Rails::DelegateAllowBlank < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#23
  def allow_blank_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#35
  def autocorrect(pair_node); end

  # source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#19
  def delegate_options(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#27
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#43
  def allow_blank_option(node); end
end

# source://rubocop//lib/rubocop/cop/rails/delegate_allow_blank.rb#17
RuboCop::Cop::Rails::DelegateAllowBlank::MSG = T.let(T.unsafe(nil), String)

# This cop checks dynamic `find_by_*` methods.
# Use `find_by` instead of dynamic method.
# See. https://github.com/rubocop-hq/rails-style-guide#find_by
#
# @example
#   # bad
#   User.find_by_name(name)
#
#   # bad
#   User.find_by_name_and_email(name)
#
#   # bad
#   User.find_by_email!(name)
#
#   # good
#   User.find_by(name: name)
#
#   # good
#   User.find_by(name: name, email: email)
#
#   # good
#   User.find_by!(email: email)
#
# source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#28
class RuboCop::Cop::Rails::DynamicFindBy < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#47
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#32
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#32
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#65
  def autocorrect_argument_keywords(corrector, node, keywords); end

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#60
  def autocorrect_method_name(corrector, node); end

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#75
  def column_keywords(method); end

  # Returns static method name.
  # If code isn't wrong, returns nil
  #
  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#82
  def static_method_name(method_name); end

  # source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#71
  def whitelist; end
end

# source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#30
RuboCop::Cop::Rails::DynamicFindBy::METHOD_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/rails/dynamic_find_by.rb#29
RuboCop::Cop::Rails::DynamicFindBy::MSG = T.let(T.unsafe(nil), String)

# This cop looks for duplicate values in enum declarations.
#
# @example
#   # bad
#   enum status: { active: 0, archived: 0 }
#
#   # good
#   enum status: { active: 0, archived: 1 }
#
#   # bad
#   enum status: [:active, :archived, :active]
#
#   # good
#   enum status: [:active, :archived]
#
# source://rubocop//lib/rubocop/cop/rails/enum_uniqueness.rb#20
class RuboCop::Cop::Rails::EnumUniqueness < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Duplication

  # source://rubocop//lib/rubocop/cop/rails/enum_uniqueness.rb#26
  def enum_declaration(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/enum_uniqueness.rb#30
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/rails/enum_uniqueness.rb#23
RuboCop::Cop::Rails::EnumUniqueness::MSG = T.let(T.unsafe(nil), String)

# This cop checks that Rails.env is compared using `.production?`-like
# methods instead of equality against a string or symbol.
#
# @example
#   # bad
#   Rails.env == 'production'
#
#   # bad, always returns false
#   Rails.env == :test
#
#   # good
#   Rails.env.production?
#
# source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#18
class RuboCop::Cop::Rails::EnvironmentComparison < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#50
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#24
  def environment_str_comparison?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#32
  def environment_sym_comparison?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#40
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#58
  def replacement(node); end
end

# source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#19
RuboCop::Cop::Rails::EnvironmentComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/environment_comparison.rb#21
RuboCop::Cop::Rails::EnvironmentComparison::SYM_MSG = T.let(T.unsafe(nil), String)

# This cop enforces that `exit` calls are not used within a rails app.
# Valid options are instead to raise an error, break, return, or some
# other form of stopping execution of current request.
#
# There are two obvious cases where `exit` is particularly harmful:
#
# - Usage in library code for your application. Even though Rails will
# rescue from a `SystemExit` and continue on, unit testing that library
# code will result in specs exiting (potentially silently if `exit(0)`
# is used.)
# - Usage in application code outside of the web process could result in
# the program exiting, which could result in the code failing to run and
# do its job.
#
# @example
#   # bad
#   exit(0)
#
#   # good
#   raise 'a bad error has happened'
#
# source://rubocop//lib/rubocop/cop/rails/exit.rb#26
class RuboCop::Cop::Rails::Exit < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/rails/exit.rb#33
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/exit.rb#39
  def offending_node?(node); end

  # More than 1 argument likely means it is a different
  # `exit` implementation than the one we are preventing.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/exit.rb#51
  def right_argument_count?(arg_nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/exit.rb#45
  def right_method_name?(method_name); end

  # Only register if exit is being called explicitly on `Kernel`,
  # `Process`, or if receiver node is nil for plain `exit` calls.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/exit.rb#57
  def right_receiver?(receiver_node); end
end

# source://rubocop//lib/rubocop/cop/rails/exit.rb#31
RuboCop::Cop::Rails::Exit::EXPLICIT_RECEIVERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/exit.rb#29
RuboCop::Cop::Rails::Exit::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/exit.rb#30
RuboCop::Cop::Rails::Exit::TARGET_METHODS = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of file path joining process
# to use `Rails.root.join` clause. It is used to add uniformity when
# joining paths.
#
# @example EnforcedStyle: arguments (default)
#   # bad
#   Rails.root.join('app/models/goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app', 'models', 'goober')
# @example EnforcedStyle: slashes
#   # bad
#   Rails.root.join('app', 'models', 'goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app/models/goober')
#
# source://rubocop//lib/rubocop/cop/rails/file_path.rb#28
class RuboCop::Cop::Rails::FilePath < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#37
  def file_join_nodes?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#49
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#57
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#45
  def rails_root_join_nodes?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#41
  def rails_root_nodes?(node0); end

  private

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#65
  def check_for_file_join_with_rails_root(node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#82
  def check_for_rails_root_join_with_slash_separated_path(node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#72
  def check_for_rails_root_join_with_string_arguments(node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#102
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#95
  def register_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/file_path.rb#91
  def string_with_slash?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/file_path.rb#34
RuboCop::Cop::Rails::FilePath::MSG_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/file_path.rb#32
RuboCop::Cop::Rails::FilePath::MSG_SLASHES = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of `where.first` and
# change them to use `find_by` instead.
#
# @example
#   # bad
#   User.where(name: 'Bruce').first
#   User.where(name: 'Bruce').take
#
#   # good
#   User.find_by(name: 'Bruce')
#
# source://rubocop//lib/rubocop/cop/rails/find_by.rb#16
class RuboCop::Cop::Rails::FindBy < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/rails/find_by.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/find_by.rb#26
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/find_by.rb#26
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/find_by.rb#22
  def where_first?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/rails/find_by.rb#19
RuboCop::Cop::Rails::FindBy::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/find_by.rb#20
RuboCop::Cop::Rails::FindBy::TARGET_SELECTORS = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `all.each` and
# change them to use `all.find_each` instead.
#
# @example
#   # bad
#   User.all.each
#
#   # good
#   User.all.find_each
#
# source://rubocop//lib/rubocop/cop/rails/find_each.rb#15
class RuboCop::Cop::Rails::FindEach < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/find_each.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/find_each.rb#24
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/find_each.rb#45
  def ignored_by_find_each?(relation_method); end

  # source://rubocop//lib/rubocop/cop/rails/find_each.rb#41
  def method_chain(node); end
end

# source://rubocop//lib/rubocop/cop/rails/find_each.rb#22
RuboCop::Cop::Rails::FindEach::IGNORED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/find_each.rb#16
RuboCop::Cop::Rails::FindEach::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/find_each.rb#18
RuboCop::Cop::Rails::FindEach::SCOPE_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for the use of the has_and_belongs_to_many macro.
#
# @example
#   # bad
#   # has_and_belongs_to_many :ingredients
#
#   # good
#   # has_many :ingredients, through: :recipe_ingredients
#
# source://rubocop//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#14
class RuboCop::Cop::Rails::HasAndBelongsToMany < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#17
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#15
RuboCop::Cop::Rails::HasAndBelongsToMany::MSG = T.let(T.unsafe(nil), String)

# This cop looks for `has_many` or `has_one` associations that don't
# specify a `:dependent` option.
# It doesn't register an offense if `:through` option was specified.
#
# @example
#   # bad
#   class User < ActiveRecord::Base
#   has_many :comments
#   has_one :avatar
#   end
#
#   # good
#   class User < ActiveRecord::Base
#   has_many :comments, dependent: :restrict_with_exception
#   has_one :avatar, dependent: :destroy
#   has_many :patients, through: :appointments
#   end
#
# source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#23
class RuboCop::Cop::Rails::HasManyOrHasOneDependent < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#26
  def active_resource_class?(node0); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#34
  def association_with_options?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#30
  def association_without_options?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#38
  def dependent_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#53
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#42
  def present_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#46
  def with_options_block(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#98
  def active_resource?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#75
  def contain_valid_options_in_with_options_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#89
  def valid_options?(options); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#67
  def valid_options_in_with_options_block?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#24
RuboCop::Cop::Rails::HasManyOrHasOneDependent::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of http methods like `get`, `post`,
# `put`, `patch` without the usage of keyword arguments in your tests and
# change them to use keyword args. This cop only applies to Rails >= 5.
# If you are running Rails < 5 you should disable the
# Rails/HttpPositionalArguments cop or set your TargetRailsVersion in your
# .rubocop.yml file to 4.0, etc.
#
# @example
#   # bad
#   get :new, { user_id: 1}
#
#   # good
#   get :new, params: { user_id: 1 }
#
# source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#19
class RuboCop::Cop::Rails::HttpPositionalArguments < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRailsVersion

  # given a pre Rails 5 method: get :new, {user_id: @user.id}, {}
  #
  # the result should look like:
  #     get :new, params: { user_id: @user.id }, session: {}
  # the http_method is the method used to call the controller
  # the controller node can be a symbol, method, object or string
  # that represents the path/action on the Rails controller
  # the data is the http parameters and environment sent in
  # the Rails 5 http call
  #
  # @return lambda of auto correct procedure
  #
  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#54
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#31
  def http_request?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#35
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#79
  def convert_hash_data(data, type); end

  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#94
  def correction(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#107
  def correction_template(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#75
  def format_arg?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#62
  def needs_conversion?(data); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#71
  def special_keyword_arg?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#27
RuboCop::Cop::Rails::HttpPositionalArguments::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#24
RuboCop::Cop::Rails::HttpPositionalArguments::KEYWORD_ARGS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/http_positional_arguments.rb#22
RuboCop::Cop::Rails::HttpPositionalArguments::MSG = T.let(T.unsafe(nil), String)

# Enforces use of symbolic or numeric value to define HTTP status.
#
# @example EnforcedStyle: symbolic (default)
#   # bad
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 200
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#
#   # good
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :ok
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
# @example EnforcedStyle: numeric
#   # bad
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :not_found
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
#
#   # good
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 404
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#
# source://rubocop//lib/rubocop/cop/rails/http_status.rb#34
class RuboCop::Cop::Rails::HttpStatus < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#71
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#44
  def http_status(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#55
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#51
  def status_pair?(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#67
  def support_autocorrect?; end

  private

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#87
  def checker_class; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#80
  def status_code(node); end
end

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#141
class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  # @return [NumericStyleChecker] a new instance of NumericStyleChecker
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#149
  def initialize(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#157
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#148
  def node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#153
  def offensive?; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#165
  def preferred_style; end

  private

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#171
  def number; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#179
  def permitted_symbol?; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#175
  def symbol; end
end

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#144
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#142
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#146
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::PERMITTED_STATUS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#39
RuboCop::Cop::Rails::HttpStatus::RACK_LOADED = T.let(T.unsafe(nil), FalseClass)

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#97
class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  # @return [SymbolicStyleChecker] a new instance of SymbolicStyleChecker
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#104
  def initialize(node); end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#112
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#103
  def node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#108
  def offensive?; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#120
  def preferred_style; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#134
  def custom_http_status_code?; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#130
  def number; end

  # source://rubocop//lib/rubocop/cop/rails/http_status.rb#126
  def symbol; end
end

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#100
RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/http_status.rb#98
RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

# This cop checks that `if` and `only` (or `except`) are not used together
# as options of `skip_*` action filter.
#
# The `if` option will be ignored when `if` and `only` are used together.
# Similarly, the `except` option will be ignored when `if` and `except`
# are used together.
#
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   only: :show, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name == "show" }
#   end
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   except: :admin, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name != "admin" }
#   end
# @see https://api.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-_normalize_callback_options
#
# source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#40
class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#52
  def filter_options(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#60
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#88
  def if_and_except?(options); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#84
  def if_and_only?(options); end

  # source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#78
  def options_hash(options); end
end

# source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#45
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::FILTERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#41
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::MSG = T.let(T.unsafe(nil), String)

# This cop looks for has_(one|many) and belongs_to associations where
# Active Record can't automatically determine the inverse association
# because of a scope or the options used. Using the blog with order scope
# example below, traversing the a Blog's association in both directions
# with `blog.posts.first.blog` would cause the `blog` to be loaded from
# the database twice.
#
# `:inverse_of` must be manually specified for Active Record to use the
# associated object in memory, or set to `false` to opt-out. Note that
# setting `nil` does not stop Active Record from trying to determine the
# inverse automatically, and is not considered a valid value for this.
#
# @example
#   # good
#   class Blog < ApplicationRecord
#   has_many :posts
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
# @example
#   # bad
#   class Blog < ApplicationRecord
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: :blog)
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   with_options inverse_of: :blog do
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   # When you don't want to use the inverse association.
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: false)
#   end
# @example
#   # bad
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   # good
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
# @example
#   # bad
#   # However, RuboCop can not detect this pattern...
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician
#   belongs_to :patient
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
#
#   # good
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician, inverse_of: :appointments
#   belongs_to :patient, inverse_of: :appointments
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
# @see https://guides.rubyonrails.org/association_basics.html#bi-directional-associations
# @see https://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#module-ActiveRecord::Associations::ClassMethods-label-Setting+Inverses
#
# source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#131
class RuboCop::Cop::Rails::InverseOf < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#160
  def as_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#140
  def association_recv_arguments(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#148
  def conditions_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#164
  def foreign_key_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#172
  def inverse_of_nil_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#168
  def inverse_of_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#176
  def on_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#216
  def options_contain_inverse_of?(options); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#144
  def options_from_argument(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#210
  def options_ignoring_inverse_of?(options); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#199
  def options_requiring_inverse_of?(options); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#156
  def polymorphic_option?(node = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#228
  def same_context_in_with_options?(arg, recv); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#195
  def scope?(arguments); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#152
  def through_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#220
  def with_options_arguments(recv, node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#236
  def message(options); end
end

# source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#137
RuboCop::Cop::Rails::InverseOf::NIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/inverse_of.rb#136
RuboCop::Cop::Rails::InverseOf::SPECIFY_MSG = T.let(T.unsafe(nil), String)

# This cop checks that methods specified in the filter's `only` or
# `except` options are defined within the same class or module.
#
# You can technically specify methods of superclass or methods added
# by mixins on the filter, but these confuse developers. If you
# specify methods that are defined in other classes or modules, you
# should define the filter in that class or module.
#
# @example
#   # bad
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#   end
#
#   # good
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#
#   def settings
#   end
#
#   def logout
#   end
#   end
# @example
#   # bad
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#   end
#
#   # good
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#
#   def foo
#   # something
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#59
class RuboCop::Cop::Rails::LexicallyScopedActionFilter < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#89
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#78
  def only_or_except_filter_methods(node = T.unsafe(nil)); end

  private

  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  #
  # source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#112
  def array_values(node); end

  # @param methods [Array<String>]
  # @param parent [RuboCop::AST::Node]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#135
  def message(methods, parent); end
end

# source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#62
RuboCop::Cop::Rails::LexicallyScopedActionFilter::FILTERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#60
RuboCop::Cop::Rails::LexicallyScopedActionFilter::MSG = T.let(T.unsafe(nil), String)

# This cop checks for calls to `link_to` that contain a
# `target: '_blank'` but no `rel: 'noopener'`. This can be a security
# risk as the loaded page will have control over the previous page
# and could change its location for phishing purposes.
#
# @example
#   # bad
#   link_to 'Click here', url, target: '_blank'
#
#   # good
#   link_to 'Click here', url, target: '_blank', rel: 'noopener'
#
# source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#17
class RuboCop::Cop::Rails::LinkToBlank < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#45
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#20
  def blank_target?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#24
  def includes_noopener?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#32
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#28
  def rel_node?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#74
  def add_rel(send_node, offence_node, corrector); end

  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#65
  def append_to_rel(rel_node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#82
  def contains_noopener?(str); end
end

# source://rubocop//lib/rubocop/cop/rails/link_to_blank.rb#18
RuboCop::Cop::Rails::LinkToBlank::MSG = T.let(T.unsafe(nil), String)

# This cop checks for add_column call with NOT NULL constraint
# in migration file.
#
# @example
#   # bad
#   add_column :users, :name, :string, null: false
#   add_reference :products, :category, null: false
#
#   # good
#   add_column :users, :name, :string, null: true
#   add_column :users, :name, :string, null: false, default: ''
#   add_reference :products, :category
#   add_reference :products, :category, null: false, default: 1
#
# source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#19
class RuboCop::Cop::Rails::NotNullColumn < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#22
  def add_not_null_column?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#26
  def add_not_null_reference?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#34
  def default_option?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#30
  def null_false?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#38
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#45
  def check_add_column(node); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#50
  def check_add_reference(node); end

  # source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#55
  def check_pairs(pairs); end
end

# source://rubocop//lib/rubocop/cop/rails/not_null_column.rb#20
RuboCop::Cop::Rails::NotNullColumn::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of output calls like puts and print
#
# @example
#   # bad
#   puts 'A debug message'
#   pp 'A debug message'
#   print 'A debug message'
#
#   # good
#   Rails.logger.debug 'A debug message'
#
# source://rubocop//lib/rubocop/cop/rails/output.rb#16
class RuboCop::Cop::Rails::Output < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/output.rb#24
  def io_output?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/output.rb#34
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/output.rb#20
  def output?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/output.rb#43
  def match_gvar?(sym); end
end

# source://rubocop//lib/rubocop/cop/rails/output.rb#17
RuboCop::Cop::Rails::Output::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of output safety calls like `html_safe`,
# `raw`, and `safe_concat`. These methods do not escape content. They
# simply return a SafeBuffer containing the content as is. Instead,
# use `safe_join` to join content and escape it and concat to
# concatenate content and escape it, ensuring its safety.
#
# @example
#   user_content = "<b>hi</b>"
#
#   # bad
#   "<p>#{user_content}</p>".html_safe
#   # => ActiveSupport::SafeBuffer "<p><b>hi</b></p>"
#
#   # good
#   content_tag(:p, user_content)
#   # => ActiveSupport::SafeBuffer "<p>&lt;b&gt;hi&lt;/b&gt;</p>"
#
#   # bad
#   out = ""
#   out << "<li>#{user_content}</li>"
#   out << "<li>#{user_content}</li>"
#   out.html_safe
#   # => ActiveSupport::SafeBuffer "<li><b>hi</b></li><li><b>hi</b></li>"
#
#   # good
#   out = []
#   out << content_tag(:li, user_content)
#   out << content_tag(:li, user_content)
#   safe_join(out)
#   # => ActiveSupport::SafeBuffer
#   #    "<li>&lt;b&gt;hi&lt;/b&gt;</li><li>&lt;b&gt;hi&lt;/b&gt;</li>"
#
#   # bad
#   out = "<h1>trusted content</h1>".html_safe
#   out.safe_concat(user_content)
#   # => ActiveSupport::SafeBuffer "<h1>trusted_content</h1><b>hi</b>"
#
#   # good
#   out = "<h1>trusted content</h1>".html_safe
#   out.concat(user_content)
#   # => ActiveSupport::SafeBuffer
#   #    "<h1>trusted_content</h1>&lt;b&gt;hi&lt;/b&gt;"
#
#   # safe, though maybe not good style
#   out = "trusted content"
#   result = out.concat(user_content)
#   # => String "trusted content<b>hi</b>"
#   # because when rendered in ERB the String will be escaped:
#   # <%= result %>
#   # => trusted content&lt;b&gt;hi&lt;/b&gt;
#
#   # bad
#   (user_content + " " + content_tag(:span, user_content)).html_safe
#   # => ActiveSupport::SafeBuffer "<b>hi</b> <span><b>hi</b></span>"
#
#   # good
#   safe_join([user_content, " ", content_tag(:span, user_content)])
#   # => ActiveSupport::SafeBuffer
#   #    "&lt;b&gt;hi&lt;/b&gt; <span>&lt;b&gt;hi&lt;/b&gt;</span>"
#
# source://rubocop//lib/rubocop/cop/rails/output_safety.rb#65
class RuboCop::Cop::Rails::OutputSafety < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#68
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#68
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#85
  def looks_like_rails_html_safe?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#89
  def looks_like_rails_raw?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#93
  def looks_like_rails_safe_concat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/output_safety.rb#81
  def non_interpolated_string?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/output_safety.rb#66
RuboCop::Cop::Rails::OutputSafety::MSG = T.let(T.unsafe(nil), String)

# This cop checks for correct grammar when using ActiveSupport's
# core extensions to the numeric classes.
#
# @example
#   # bad
#   3.day.ago
#   1.months.ago
#
#   # good
#   3.days.ago
#   1.month.ago
#
# source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#17
class RuboCop::Cop::Rails::PluralizationGrammar < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#31
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#57
  def correct_method(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#100
  def duration_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#88
  def literal_number?(node); end

  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#50
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#65
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#72
  def plural_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#84
  def plural_receiver?(number); end

  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#92
  def pluralize(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#76
  def singular_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#80
  def singular_receiver?(number); end

  # source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#96
  def singularize(method_name); end
end

# source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#29
RuboCop::Cop::Rails::PluralizationGrammar::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#27
RuboCop::Cop::Rails::PluralizationGrammar::PLURAL_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/rails/pluralization_grammar.rb#18
RuboCop::Cop::Rails::PluralizationGrammar::SINGULAR_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks code that can be written more easily using
# `Object#presence` defined by Active Support.
#
# @example
#   # bad
#   a.present? ? a : nil
#
#   # bad
#   !a.present? ? nil : a
#
#   # bad
#   a.blank? ? nil : a
#
#   # bad
#   !a.blank? ? a : nil
#
#   # good
#   a.presence
# @example
#   # bad
#   a.present? ? a : b
#
#   # bad
#   !a.present? ? b : a
#
#   # bad
#   a.blank? ? b : a
#
#   # bad
#   !a.blank? ? a : b
#
#   # good
#   a.presence || b
#
# source://rubocop//lib/rubocop/cop/rails/presence.rb#40
class RuboCop::Cop::Rails::Presence < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/presence.rb#89
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/presence.rb#73
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/rails/presence.rb#58
  def redundant_negative_receiver_and_other(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/presence.rb#43
  def redundant_receiver_and_other(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/presence.rb#103
  def ignore_if_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/presence.rb#107
  def ignore_other_node?(node); end

  # source://rubocop//lib/rubocop/cop/rails/presence.rb#111
  def message(node, receiver, other); end

  # source://rubocop//lib/rubocop/cop/rails/presence.rb#117
  def replacement(receiver, other); end
end

# source://rubocop//lib/rubocop/cop/rails/presence.rb#41
RuboCop::Cop::Rails::Presence::MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#present?` defined by Active Support.
#
# simpler conditionals.
#
# @example NotNilAndNotEmpty: true (default)
#   # Converts usages of `!nil? && !empty?` to `present?`
#
#   # bad
#   !foo.nil? && !foo.empty?
#
#   # bad
#   foo != nil && !foo.empty?
#
#   # good
#   foo.present?
# @example NotBlank: true (default)
#   # Converts usages of `!blank?` to `present?`
#
#   # bad
#   !foo.blank?
#
#   # bad
#   not foo.blank?
#
#   # good
#   foo.present?
# @example UnlessBlank: true (default)
#   # Converts usages of `unless blank?` to `if present?`
#
#   # bad
#   something unless foo.blank?
#
#   # good
#   something if foo.present?
#
# source://rubocop//lib/rubocop/cop/rails/present.rb#43
class RuboCop::Cop::Rails::Present < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/present.rb#116
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#50
  def exists_and_not_empty?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#64
  def not_blank?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#81
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#104
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#94
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#70
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#66
  def unless_blank?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/present.rb#143
  def replacement(node); end

  # source://rubocop//lib/rubocop/cop/rails/present.rb#135
  def unless_condition(node, method_call); end
end

# source://rubocop//lib/rubocop/cop/rails/present.rb#45
RuboCop::Cop::Rails::Present::MSG_EXISTS_AND_NOT_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/present.rb#44
RuboCop::Cop::Rails::Present::MSG_NOT_BLANK = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/present.rb#47
RuboCop::Cop::Rails::Present::MSG_UNLESS_BLANK = T.let(T.unsafe(nil), String)

# This cop checks for the use of the `read_attribute` or `write_attribute`
# methods and recommends square brackets instead.
#
# If an attribute is missing from the instance (for example, when
# initialized by a partial `select`) then `read_attribute`
# will return nil, but square brackets will raise
# an `ActiveModel::MissingAttributeError`.
#
# Explicitly raising an error in this situation is preferable, and that
# is why rubocop recommends using square brackets.
#
# @example
#
#   # bad
#   x = read_attribute(:attr)
#   write_attribute(:attr, val)
#
#   # good
#   x = self[:attr]
#   self[:attr] = val
#
# source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#26
class RuboCop::Cop::Rails::ReadWriteAttribute < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#36
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#29
  def read_write_attribute?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#55
  def message(node); end

  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#64
  def read_attribute_replacement(node); end

  # source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#68
  def write_attribute_replacement(node); end
end

# source://rubocop//lib/rubocop/cop/rails/read_write_attribute.rb#27
RuboCop::Cop::Rails::ReadWriteAttribute::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant receiver in `with_options`.
# Receiver is implicit from Rails 4.2 or higher.
#
# @example
#   # bad
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do |assoc|
#   assoc.has_many :customers
#   assoc.has_many :products
#   assoc.has_many :invoices
#   assoc.has_many :expenses
#   end
#   end
#
#   # good
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do
#   has_many :customers
#   has_many :products
#   has_many :invoices
#   has_many :expenses
#   end
#   end
# @example
#   # bad
#   with_options options: false do |merger|
#   merger.invoke(merger.something)
#   end
#
#   # good
#   with_options options: false do
#   invoke(something)
#   end
#
#   # good
#   client = Client.new
#   with_options options: false do |merger|
#   client.invoke(merger.something, something)
#   end
#
#   # ok
#   # When `with_options` includes a block, all scoping scenarios
#   # cannot be evaluated. Thus, it is ok to include the explicit
#   # receiver.
#   with_options options: false do |merger|
#   merger.invoke
#   with_another_method do |another_receiver|
#   merger.invoke(another_receiver)
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#57
class RuboCop::Cop::Rails::RedundantReceiverInWithOptions < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#74
  def all_block_nodes_in(node0); end

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#78
  def all_send_nodes_in(node0); end

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#97
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#82
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#65
  def with_options?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#107
  def block_argument_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#129
  def same_value?(arg_node, recv_node); end

  # source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#119
  def search_begin_pos_of_space_before_block_argument(begin_pos); end
end

# source://rubocop//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#63
RuboCop::Cop::Rails::RedundantReceiverInWithOptions::MSG = T.let(T.unsafe(nil), String)

# This cop checks if the value of the option `class_name`, in
# the definition of a reflection is a string.
#
# @example
#   # bad
#   has_many :accounts, class_name: Account
#   has_many :accounts, class_name: Account.name
#
#   # good
#   has_many :accounts, class_name: 'Account'
#
# source://rubocop//lib/rubocop/cop/rails/reflection_class_name.rb#16
class RuboCop::Cop::Rails::ReflectionClassName < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/reflection_class_name.rb#19
  def association_with_options?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reflection_class_name.rb#27
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/reflection_class_name.rb#23
  def reflection_class_name(node0); end
end

# source://rubocop//lib/rubocop/cop/rails/reflection_class_name.rb#17
RuboCop::Cop::Rails::ReflectionClassName::MSG = T.let(T.unsafe(nil), String)

# Use `assert_not` methods instead of `refute` methods.
#
# @example
#   # bad
#   refute false
#   refute_empty [1, 2, 3]
#   refute_equal true, false
#
#   # good
#   assert_not false
#   assert_not_empty [1, 2, 3]
#   assert_not_equal true, false
#
# source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#20
class RuboCop::Cop::Rails::RefuteMethods < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#51
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#42
  def offensive?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#44
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#66
  def offense_message(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#62
  def refute_method?(method_name); end
end

# source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#23
RuboCop::Cop::Rails::RefuteMethods::CORRECTIONS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#21
RuboCop::Cop::Rails::RefuteMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/refute_methods.rb#40
RuboCop::Cop::Rails::RefuteMethods::OFFENSIVE_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks whether constant value isn't relative date.
# Because the relative date will be evaluated only once.
#
# @example
#   # bad
#   class SomeClass
#   EXPIRED_AT = 1.week.since
#   end
#
#   # good
#   class SomeClass
#   def self.expired_at
#   1.week.since
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#21
class RuboCop::Cop::Rails::RelativeDateConstant < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#56
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#27
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#33
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#50
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#83
  def relative_date?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#71
  def relative_date_assignment?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#79
  def relative_date_or_assignment?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/rails/relative_date_constant.rb#24
RuboCop::Cop::Rails::RelativeDateConstant::MSG = T.let(T.unsafe(nil), String)

# This cop checks for consistent uses of `request.referer` or
# `request.referrer`, depending on the cop's configuration.
#
# @example EnforcedStyle: referer (default)
#   # bad
#   request.referrer
#
#   # good
#   request.referer
# @example EnforcedStyle: referrer
#   # bad
#   request.referer
#
#   # good
#   request.referrer
#
# source://rubocop//lib/rubocop/cop/rails/request_referer.rb#22
class RuboCop::Cop::Rails::RequestReferer < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/rails/request_referer.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/request_referer.rb#32
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/request_referer.rb#28
  def referer?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/request_referer.rb#46
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/rails/request_referer.rb#50
  def wrong_method_name; end
end

# source://rubocop//lib/rubocop/cop/rails/request_referer.rb#25
RuboCop::Cop::Rails::RequestReferer::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the change method of the migration file is
# reversible.
#
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   end
#   end
#
#   # good
#   def change
#   create_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.column :name, :string
#   end
#
#   dir.down do
#   t.remove :name
#   end
#   end
#   end
#   end
# @example
#   # drop_table
#
#   # bad
#   def change
#   drop_table :users
#   end
#
#   # good
#   def change
#   drop_table :users do |t|
#   t.string :name
#   end
#   end
# @example
#   # change_column_default
#
#   # bad
#   def change
#   change_column_default(:suppliers, :qualification, 'new')
#   end
#
#   # good
#   def change
#   change_column_default(:posts, :state, from: nil, to: "draft")
#   end
# @example
#   # remove_column
#
#   # bad
#   def change
#   remove_column(:suppliers, :qualification)
#   end
#
#   # good
#   def change
#   remove_column(:suppliers, :qualification, :string)
#   end
# @example
#   # remove_foreign_key
#
#   # bad
#   def change
#   remove_foreign_key :accounts, column: :owner_id
#   end
#
#   # good
#   def change
#   remove_foreign_key :accounts, :branches
#   end
# @example
#   # change_table
#
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   t.change_default :authorized, 1
#   t.change :price, :string
#   end
#   end
#
#   # good
#   def change
#   change_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.change :price, :string
#   end
#
#   dir.down do
#   t.change :price, :integer
#   end
#   end
#   end
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html
#
# source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#128
class RuboCop::Cop::Rails::ReversibleMigration < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#142
  def change_column_default_call(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#154
  def change_table_call(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#138
  def drop_table_call(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#134
  def irreversible_schema_statement_call(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#169
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#158
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#146
  def remove_column_call(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#150
  def remove_foreign_key_call(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#274
  def all_hash_key?(args, *keys); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#196
  def check_change_column_default_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#232
  def check_change_table_node(node, block); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#249
  def check_change_table_offense(receiver, node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#185
  def check_drop_table_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#179
  def check_irreversible_schema_statement_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#209
  def check_remove_column_node(node); end

  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#220
  def check_remove_foreign_key_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#260
  def within_change_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#266
  def within_reversible_or_up_only_block?(node); end
end

# source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#130
RuboCop::Cop::Rails::ReversibleMigration::IRREVERSIBLE_CHANGE_TABLE_CALLS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/reversible_migration.rb#129
RuboCop::Cop::Rails::ReversibleMigration::MSG = T.let(T.unsafe(nil), String)

# This cop converts usages of `try!` to `&.`. It can also be configured
# to convert `try`. It will convert code to use safe navigation if the
# target Ruby version is set to 2.3+
#
# @example
#   # ConvertTry: false
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#
#   foo.try!(:[], 0)
#
#   # good
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
#
#   # ConvertTry: true
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   # good
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
#
# source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#42
class RuboCop::Cop::Rails::SafeNavigation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#63
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#54
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#48
  def try_call(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#77
  def replacement(method, params); end
end

# source://rubocop//lib/rubocop/cop/rails/safe_navigation.rb#46
RuboCop::Cop::Rails::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

# This cop identifies possible cases where Active Record save! or related
# should be used instead of save because the model might have failed to
# save and an exception is better than unhandled failure.
#
# This will allow:
# - update or save calls, assigned to a variable,
#   or used as a condition in an if/unless/case statement.
# - create calls, assigned to a variable that then has a
#   call to `persisted?`.
# - calls if the result is explicitly returned from methods and blocks,
#   or provided as arguments.
# - calls whose signature doesn't look like an ActiveRecord
#   persistence method.
#
# By default it will also allow implicit returns from methods and blocks.
# that behavior can be turned off with `AllowImplicitReturn: false`.
#
# You can permit receivers that are giving false positives with
# `AllowedReceivers: []`
#
# @example
#
#   # bad
#   user.save
#   user.update(name: 'Joe')
#   user.find_or_create_by(name: 'Joe')
#   user.destroy
#
#   # good
#   unless user.save
#   # ...
#   end
#   user.save!
#   user.update!(name: 'Joe')
#   user.find_or_create_by!(name: 'Joe')
#   user.destroy!
#
#   user = User.find_or_create_by(name: 'Joe')
#   unless user.persisted?
#   # ...
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowImplicitReturn: true (default)
#
#   # good
#   users.each { |u| u.save }
#
#   def save_user
#   user.save
#   end
# @example AllowImplicitReturn: false
#
#   # bad
#   users.each { |u| u.save }
#   def save_user
#   user.save
#   end
#
#   # good
#   users.each { |u| u.save! }
#
#   def save_user
#   user.save!
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowedReceivers: ['merchant.customers', 'Service::Mailer']
#
#   # bad
#   merchant.create
#   customers.builder.save
#   Mailer.create
#
#   module Service::Mailer
#   self.create
#   end
#
#   # good
#   merchant.customers.create
#   MerchantService.merchant.customers.destroy
#   Service::Mailer.update(message: 'Message')
#   ::Service::Mailer.update
#   Services::Service::Mailer.update(message: 'Message')
#   Service::Mailer::update
#
# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#99
class RuboCop::Cop::Rails::SaveBang < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::NegativeConditional

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#121
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#151
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#129
  def check_assignment(assignment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#117
  def join_force?(force_class); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#139
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#139
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#160
  def add_offense_for_node(node, msg = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#234
  def allowed_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#285
  def argument?(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#206
  def array_parent(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#187
  def assignable_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#183
  def call_to_persisted?(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#213
  def check_used_in_conditional(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#223
  def conditional?(node); end

  # Const == Const
  # ::Const == ::Const
  # ::Const == Const
  # Const == ::Const
  # NameSpace::Const == Const
  # NameSpace::Const == NameSpace::Const
  # NameSpace::Const != ::Const
  # Const != NameSpace::Const
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#266
  def const_matches?(const, allowed_const); end

  # Check argument signature as no arguments or one hash
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#306
  def expected_signature?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#289
  def explicit_return?(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#196
  def hash_parent(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#275
  def implicit_return?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#299
  def persist_method?(node, methods = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#175
  def persisted_referenced?(assignment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#243
  def receiver_chain_matches?(node, allowed_receiver); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#294
  def return_value_assigned?(node); end

  # source://rubocop//lib/rubocop/cop/rails/save_bang.rb#167
  def right_assignment_node(assignment); end
end

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#107
RuboCop::Cop::Rails::SaveBang::CREATE_CONDITIONAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#104
RuboCop::Cop::Rails::SaveBang::CREATE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#110
RuboCop::Cop::Rails::SaveBang::CREATE_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#112
RuboCop::Cop::Rails::SaveBang::MODIFY_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#102
RuboCop::Cop::Rails::SaveBang::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/save_bang.rb#114
RuboCop::Cop::Rails::SaveBang::PERSIST_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for scope calls where it was passed
# a method (usually a scope) instead of a lambda/proc.
#
# @example
#
#   # bad
#   scope :something, where(something: true)
#
#   # good
#   scope :something, -> { where(something: true) }
#
# source://rubocop//lib/rubocop/cop/rails/scope_args.rb#16
class RuboCop::Cop::Rails::ScopeArgs < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/scope_args.rb#21
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/scope_args.rb#19
  def scope?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/rails/scope_args.rb#17
RuboCop::Cop::Rails::ScopeArgs::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of methods which skip
# validations which are listed in
# https://guides.rubyonrails.org/active_record_validations.html#skipping-validations
#
# Methods may be ignored from this rule by configuring a `Whitelist`.
#
# @example
#   # bad
#   Article.first.decrement!(:view_count)
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   Article.first.increment!(:view_count)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#   product.touch
#   Billing.update_all("category = 'authorized', author = 'David'")
#   user.update_attribute(:website, 'example.com')
#   user.update_columns(last_request_at: Time.current)
#   Post.update_counters 5, comment_count: -1, action_count: 1
#
#   # good
#   user.update(website: 'example.com')
#   FileUtils.touch('file')
# @example Whitelist: ["touch"]
#   # bad
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#
#   # good
#   user.touch
#
# source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#38
class RuboCop::Cop::Rails::SkipsModelValidations < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#52
  def good_touch?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#56
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#56
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#78
  def blacklist; end

  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#74
  def message(node); end

  # source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#82
  def whitelist; end
end

# source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#41
RuboCop::Cop::Rails::SkipsModelValidations::METHODS_WITH_ARGUMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/skips_model_validations.rb#39
RuboCop::Cop::Rails::SkipsModelValidations::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of Time methods without zone.
#
# Built on top of Ruby on Rails style guide (https://github.com/rubocop-hq/rails-style-guide#time)
# and the article http://danilenko.org/2012/7/6/rails_timezones/ .
#
# Two styles are supported for this cop. When EnforcedStyle is 'strict'
# then only use of Time.zone is allowed.
#
# When EnforcedStyle is 'flexible' then it's also allowed
# to use Time.in_time_zone.
#
# @example EnforcedStyle: strict
#   # `strict` means that `Time` should be used with `zone`.
#
#   # bad
#   Time.now
#   Time.parse('2015-03-02 19:05:37')
#
#   # bad
#   Time.current
#   Time.at(timestamp).in_time_zone
#
#   # good
#   Time.zone.now
#   Time.zone.parse('2015-03-02 19:05:37')
# @example EnforcedStyle: flexible (default)
#   # `flexible` allows usage of `in_time_zone` instead of `zone`.
#
#   # bad
#   Time.now
#   Time.parse('2015-03-02 19:05:37')
#
#   # good
#   Time.zone.now
#   Time.zone.parse('2015-03-02 19:05:37')
#
#   # good
#   Time.current
#   Time.at(timestamp).in_time_zone
#
# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#46
class RuboCop::Cop::Rails::TimeZone < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#81
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#72
  def on_const(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#196
  def acceptable?; end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#208
  def acceptable_methods(klass, method_name, node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#109
  def build_message(klass, method_name, node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#173
  def check_localtime(node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#93
  def check_time_node(klass, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#188
  def danger_chain?(chain); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#137
  def extract_method(node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#128
  def extract_method_chain(node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#200
  def good_methods; end

  # Only add the method to the chain if the method being
  # called is part of the time class.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#144
  def method_from_time_class?(node); end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#155
  def method_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#192
  def need_check_localtime?(chain); end

  # Time.new can be called with a time zone offset
  # When it is, that should be considered safe
  # Example:
  # Time.new(1988, 3, 15, 3, 0, 0, "-05:00")
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#225
  def offset_provided?(node); end

  # source://rubocop//lib/rubocop/cop/rails/time_zone.rb#163
  def safe_method(method_name, node); end
end

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#68
RuboCop::Cop::Rails::TimeZone::ACCEPTED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#65
RuboCop::Cop::Rails::TimeZone::DANGEROUS_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#63
RuboCop::Cop::Rails::TimeZone::GOOD_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#49
RuboCop::Cop::Rails::TimeZone::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#52
RuboCop::Cop::Rails::TimeZone::MSG_ACCEPTABLE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#58
RuboCop::Cop::Rails::TimeZone::MSG_CURRENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#55
RuboCop::Cop::Rails::TimeZone::MSG_LOCALTIME = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/time_zone.rb#61
RuboCop::Cop::Rails::TimeZone::TIMECLASS = T.let(T.unsafe(nil), Array)

# Prefer the use of uniq (or distinct), before pluck instead of after.
#
# The use of uniq before pluck is preferred because it executes within
# the database.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is conservative (the default) then only calls to pluck on a constant
# (i.e. a model class) before uniq are added as offenses.
#
# When the EnforcedStyle is aggressive then all calls to pluck before
# uniq are added as offenses. This may lead to false positives as the cop
# cannot distinguish between calls to pluck on an ActiveRecord::Relation
# vs a call to pluck on an ActiveRecord::Associations::CollectionProxy.
#
# Autocorrect is disabled by default for this cop since it may generate
# false positives.
#
# @example EnforcedStyle: conservative (default)
#   # bad
#   Model.pluck(:id).uniq
#
#   # good
#   Model.uniq.pluck(:id)
# @example EnforcedStyle: aggressive
#   # bad
#   # this will return a Relation that pluck is called on
#   Model.where(cond: true).pluck(:id).uniq
#
#   # bad
#   # an association on an instance will return a CollectionProxy
#   instance.assoc.pluck(:id).uniq
#
#   # bad
#   Model.pluck(:id).uniq
#
#   # good
#   Model.uniq.pluck(:id)
#
# source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#45
class RuboCop::Cop::Rails::UniqBeforePluck < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#57
  def aggressive_node_match(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#73
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#54
  def conservative_node_match(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#60
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#93
  def dot_method_begin_pos(method, node); end

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#88
  def dot_method_with_whitespace(method, node); end

  # source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#84
  def style_parameter_name; end
end

# source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#49
RuboCop::Cop::Rails::UniqBeforePluck::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#50
RuboCop::Cop::Rails::UniqBeforePluck::NEWLINE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/uniq_before_pluck.rb#51
RuboCop::Cop::Rails::UniqBeforePluck::PATTERN = T.let(T.unsafe(nil), String)

# This cop checks that environments called with `Rails.env` predicates
# exist.
#
# @example
#   # bad
#   Rails.env.proudction?
#
#   # good
#   Rails.env.production?
#
# source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#15
class RuboCop::Cop::Rails::UnknownEnv < ::RuboCop::Cop::Cop
  include ::RuboCop::NameSimilarity

  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#30
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#22
  def unknown_environment?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#38
  def collect_variable_like_names(_scope); end

  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#57
  def environments; end

  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#42
  def message(name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#51
  def unknown_env_name?(name); end
end

# source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#18
RuboCop::Cop::Rails::UnknownEnv::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/unknown_env.rb#19
RuboCop::Cop::Rails::UnknownEnv::MSG_SIMILAR = T.let(T.unsafe(nil), String)

# This cop checks for the use of old-style attribute validation macros.
#
# @example
#   # bad
#   validates_acceptance_of :foo
#   validates_confirmation_of :foo
#   validates_exclusion_of :foo
#   validates_format_of :foo
#   validates_inclusion_of :foo
#   validates_length_of :foo
#   validates_numericality_of :foo
#   validates_presence_of :foo
#   validates_size_of :foo
#   validates_uniqueness_of :foo
#
#   # good
#   validates :foo, acceptance: true
#   validates :foo, confirmation: true
#   validates :foo, exclusion: true
#   validates :foo, format: true
#   validates :foo, inclusion: true
#   validates :foo, length: true
#   validates :foo, numericality: true
#   validates :foo, presence: true
#   validates :foo, size: true
#   validates :foo, uniqueness: true
#
# source://rubocop//lib/rubocop/cop/rails/validation.rb#33
class RuboCop::Cop::Rails::Validation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/rails/validation.rb#59
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/rails/validation.rb#53
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/rails/validation.rb#96
  def braced_options(options); end

  # source://rubocop//lib/rubocop/cop/rails/validation.rb#80
  def correct_validate_type(corrector, node); end

  # source://rubocop//lib/rubocop/cop/rails/validation.rb#71
  def message(node); end

  # source://rubocop//lib/rubocop/cop/rails/validation.rb#76
  def preferred_method(method); end
end

# source://rubocop//lib/rubocop/cop/rails/validation.rb#51
RuboCop::Cop::Rails::Validation::ALLOWLIST = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/validation.rb#50
RuboCop::Cop::Rails::Validation::DENYLIST = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/rails/validation.rb#34
RuboCop::Cop::Rails::Validation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/rails/validation.rb#37
RuboCop::Cop::Rails::Validation::TYPES = T.let(T.unsafe(nil), Array)

# Methods that calculate and return Parser::Source::Ranges
#
# source://rubocop//lib/rubocop/cop/mixin/range_help.rb#6
module RuboCop::Cop::RangeHelp
  private

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#77
  def column_offset_between(base_range, range); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#96
  def directions(side); end

  # Returns the column attribute of the range, except if the range is on
  # the first line and there's a byte order mark at the beginning of that
  # line, in which case 1 is subtracted from the column value. This gives
  # the column as it appears when viewing the file in an editor.
  #
  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#87
  def effective_column(range); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#104
  def final_pos(src, pos, increment, newlines, whitespace); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#110
  def move_pos(src, pos, step, condition, regexp); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#30
  def range_between(start_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#65
  def range_by_whole_lines(range, include_final_newline: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#34
  def range_with_surrounding_comma(range, side = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#48
  def range_with_surrounding_space(range:, side: T.unsafe(nil), newlines: T.unsafe(nil), whitespace: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#11
  def source_range(source_buffer, line_number, column, length = T.unsafe(nil)); end
end

# The Unicode codepoint
#
# source://rubocop//lib/rubocop/cop/mixin/range_help.rb#9
RuboCop::Cop::RangeHelp::BYTE_ORDER_MARK = T.let(T.unsafe(nil), Integer)

# Registry that tracks all cops by their badge and department.
#
# source://rubocop//lib/rubocop/cop/registry.rb#24
class RuboCop::Cop::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#25
  def initialize(cops = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/registry.rb#139
  def ==(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#58
  def contains_cop_matching?(names); end

  # source://rubocop//lib/rubocop/cop/registry.rb#112
  def cops; end

  # @return [Array<Symbol>] list of departments for current cops.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#41
  def departments; end

  # source://rubocop//lib/rubocop/cop/registry.rb#153
  def each(&block); end

  # source://rubocop//lib/rubocop/cop/registry.rb#120
  def enabled(config, only, only_safe = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#126
  def enabled?(cop, config, only_safe); end

  # source://rubocop//lib/rubocop/cop/registry.rb#33
  def enlist(cop); end

  # @param cop_name [String]
  # @return [Class, nil]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#159
  def find_by_cop_name(cop_name); end

  # source://rubocop//lib/rubocop/cop/registry.rb#116
  def length; end

  # source://rubocop//lib/rubocop/cop/registry.rb#135
  def names; end

  # Convert a user provided cop name into a properly namespaced name
  #
  # @example gives back a correctly qualified cop name
  #
  #   cops = RuboCop::Cop::Cop.all
  #   cops.
  #   qualified_cop_name('Layout/IndentArray') # => 'Layout/IndentArray'
  # @example fixes incorrect namespaces
  #
  #   cops = RuboCop::Cop::Cop.all
  #   cops.qualified_cop_name('Lint/IndentArray') # => 'Layout/IndentArray'
  # @example namespaces bare cop identifiers
  #
  #   cops = RuboCop::Cop::Cop.all
  #   cops.qualified_cop_name('IndentArray') # => 'Layout/IndentArray'
  # @example passes back unrecognized cop names
  #
  #   cops = RuboCop::Cop::Cop.all
  #   cops.qualified_cop_name('NotACop') # => 'NotACop'
  # @note Emits a warning if the provided name has an incorrect namespace
  # @param name [String] Cop name extracted from config
  # @param path [String, nil] Path of file that `name` was extracted from
  # @raise [AmbiguousCopName] if a bare identifier with two possible namespaces is provided
  # @return [String] Qualified cop name
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#94
  def qualified_cop_name(name, path); end

  # source://rubocop//lib/rubocop/cop/registry.rb#149
  def select(&block); end

  # source://rubocop//lib/rubocop/cop/registry.rb#143
  def sort!; end

  # @return [Hash{String => Array<Class>}]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#108
  def to_h; end

  # @return [Registry] Cops for that specific department.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#46
  def with_department(department); end

  # @return [Registry] Cops not for a specific department.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#51
  def without_department(department); end

  private

  # source://rubocop//lib/rubocop/cop/registry.rb#169
  def qualify_badge(badge); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#185
  def registered?(badge); end

  # source://rubocop//lib/rubocop/cop/registry.rb#175
  def resolve_badge(given_badge, real_badge, source_path); end

  # source://rubocop//lib/rubocop/cop/registry.rb#165
  def with(cops); end
end

# Common functionality for checking `rescue` nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#6
module RuboCop::Cop::RescueNode
  # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#7
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#16
  def rescue_modifier?(node); end
end

# Common functionality for safe assignment. By safe assignment we mean
# putting parentheses around an assignment to indicate "I know I'm using an
# assignment as a condition. It's not a mistake."
#
# source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#8
module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#13
  def empty_condition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#15
  def safe_assignment?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#14
  def setter_method?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#18
  def safe_assignment_allowed?; end
end

# Common functionality for Rails safe mode.
#
# source://rubocop//lib/rubocop/cop/mixin/safe_mode.rb#6
module RuboCop::Cop::SafeMode
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/safe_mode.rb#17
  def rails?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/safe_mode.rb#9
  def rails_safe_mode?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/safe_mode.rb#13
  def safe_mode?; end
end

# source://rubocop//lib/rubocop/cop/security/eval.rb#5
module RuboCop::Cop::Security; end

# This cop checks for the use of `Kernel#eval` and `Binding#eval`.
#
# @example
#
#   # bad
#
#   eval(something)
#   binding.eval(something)
#
# source://rubocop//lib/rubocop/cop/security/eval.rb#14
class RuboCop::Cop::Security::Eval < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/security/eval.rb#17
  def eval?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/eval.rb#21
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/eval.rb#15
RuboCop::Cop::Security::Eval::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of JSON class methods which have potential
# security issues.
#
# Autocorrect is disabled by default because it's potentially dangerous.
# If using a stream, like `JSON.load(open('file'))`, it will need to call
# `#read` manually, like `JSON.parse(open('file').read)`.
# If reading single values (rather than proper JSON objects), like
# `JSON.load('false')`, it will need to pass the `quirks_mode: true`
# option, like `JSON.parse('false', quirks_mode: true)`.
# Other similar issues may apply.
#
# @example
#   # bad
#   JSON.load("{}")
#   JSON.restore("{}")
#
#   # good
#   JSON.parse("{}")
#
# source://rubocop//lib/rubocop/cop/security/json_load.rb#25
class RuboCop::Cop::Security::JSONLoad < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/security/json_load.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/security/json_load.rb#28
  def json_load(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/json_load.rb#32
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/json_load.rb#26
RuboCop::Cop::Security::JSONLoad::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of Marshal class methods which have
# potential security issues leading to remote code execution when
# loading from an untrusted source.
#
# @example
#   # bad
#   Marshal.load("{}")
#   Marshal.restore("{}")
#
#   # good
#   Marshal.dump("{}")
#
#   # okish - deep copy hack
#   Marshal.load(Marshal.dump({}))
#
# source://rubocop//lib/rubocop/cop/security/marshal_load.rb#21
class RuboCop::Cop::Security::MarshalLoad < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/security/marshal_load.rb#24
  def marshal_load(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/marshal_load.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/marshal_load.rb#22
RuboCop::Cop::Security::MarshalLoad::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of `Kernel#open`.
#
# `Kernel#open` enables not only file access but also process invocation
# by prefixing a pipe symbol (e.g., `open("| ls")`). So, it may lead to
# a serious security risk by using variable input to the argument of
# `Kernel#open`. It would be better to use `File.open`, `IO.popen` or
# `URI#open` explicitly.
#
# @example
#   # bad
#   open(something)
#
#   # good
#   File.open(something)
#   IO.popen(something)
#   URI.parse(something).open
#
# source://rubocop//lib/rubocop/cop/security/open.rb#22
class RuboCop::Cop::Security::Open < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/security/open.rb#29
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/security/open.rb#25
  def open?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#57
  def composite_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#65
  def concatenated_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#61
  def interpolated_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#39
  def safe?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#49
  def safe_argument?(argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#53
  def simple_string?(node); end
end

# source://rubocop//lib/rubocop/cop/security/open.rb#23
RuboCop::Cop::Security::Open::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of YAML class methods which have
# potential security issues leading to remote code execution when
# loading from an untrusted source.
#
# @example
#   # bad
#   YAML.load("--- foo")
#
#   # good
#   YAML.safe_load("--- foo")
#   YAML.dump("foo")
#
# source://rubocop//lib/rubocop/cop/security/yaml_load.rb#18
class RuboCop::Cop::Security::YAMLLoad < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#25
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#21
  def yaml_load(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/security/yaml_load.rb#19
RuboCop::Cop::Security::YAMLLoad::MSG = T.let(T.unsafe(nil), String)

# Severity class is simple value object about severity
#
# source://rubocop//lib/rubocop/cop/severity.rb#6
class RuboCop::Cop::Severity
  include ::Comparable

  # @api private
  # @return [Severity] a new instance of Severity
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#32
  def initialize(name_or_code); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#72
  def <=>(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#58
  def ==(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#48
  def code; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#67
  def hash; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#53
  def level; end

  # @api public
  # @return [Symbol] severity.
  #   any of `:refactor`, `:convention`, `:warning`, `:error` or `:fatal`.
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#23
  def name; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#43
  def to_s; end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/cop/severity.rb#26
    def name_from_code(code); end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/severity.rb#13
RuboCop::Cop::Severity::CODE_TABLE = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://rubocop//lib/rubocop/cop/severity.rb#10
RuboCop::Cop::Severity::NAMES = T.let(T.unsafe(nil), Array)

# Common functionality for cops checking for missing space after
# punctuation.
#
# source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#7
module RuboCop::Cop::SpaceAfterPunctuation
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#10
  def investigate(processed_source); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#39
  def allowed_type?(token); end

  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#19
  def each_missing_space(tokens); end

  # The normal offset, i.e., the distance from the punctuation
  # token where a space should be, is 1.
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#50
  def offset; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#43
  def space_forbidden_before_rcurly?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#29
  def space_missing?(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#34
  def space_required_before?(token); end
end

# source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#8
RuboCop::Cop::SpaceAfterPunctuation::MSG = T.let(T.unsafe(nil), String)

# Common functionality for cops checking for space before
# punctuation.
#
# source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#7
module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#12
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#21
  def each_missing_space(tokens); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#34
  def space_missing?(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#38
  def space_required_after?(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#42
  def space_required_after_lcurly?; end
end

# source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#10
RuboCop::Cop::SpaceBeforePunctuation::MSG = T.let(T.unsafe(nil), String)

# This auto-corrects whitespace
#
# source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#6
class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::SurroundingSpace

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#37
    def add_space(processed_source, corrector, left_token, right_token); end

    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#12
    def empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#10
    def processed_source; end

    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#25
    def remove_space(processed_source, corrector, left_token, right_token); end
  end
end

# Common functionality for modifier cops.
#
# source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#6
module RuboCop::Cop::StatementModifier
  private

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#57
  def indentation_multiplier; end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#43
  def length_in_modifier_form(node, cond, body_length); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#51
  def max_line_length; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#34
  def modifier_fits_on_single_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#23
  def non_eligible_body?(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#30
  def non_eligible_condition?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#17
  def non_eligible_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#9
  def single_line_as_modifier?(node); end
end

# Classes that include this module just implement functions to determine
# what is an offense and how to do auto-correction. They get help with
# adding offenses for the faulty string nodes, and with filtering out
# nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/string_help.rb#9
module RuboCop::Cop::StringHelp
  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#23
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#10
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#29
  def inside_interpolation?(node); end
end

# This auto-corrects string literals
#
# source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#6
class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#10
    def correct(node, style); end
  end
end

# Common functionality for cops checking single/double quotes.
#
# source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#6
module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#11
  def wrong_quotes?(node); end
end

# source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#5
module RuboCop::Cop::Style; end

# Access modifiers should be declared to apply to a group of methods
# or inline before each method, depending on configuration.
#
# @example EnforcedStyle: group (default)
#
#   # bad
#
#   class Foo
#
#   private def bar; end
#   private def baz; end
#
#   end
#
#   # good
#
#   class Foo
#
#   private
#
#   def bar; end
#   def baz; end
#
#   end
# @example EnforcedStyle: inline
#
#   # bad
#
#   class Foo
#
#   private
#
#   def bar; end
#   def baz; end
#
#   end
#
#   # good
#
#   class Foo
#
#   private def bar; end
#   private def baz; end
#
#   end
#
# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#51
class RuboCop::Cop::Style::AccessModifierDeclarations < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#64
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#91
  def access_modifier_is_inlined?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#95
  def access_modifier_is_not_inlined?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#83
  def group_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#87
  def inline_style?; end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#99
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#78
  def offense?(node); end
end

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#54
RuboCop::Cop::Style::AccessModifierDeclarations::GROUP_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#59
RuboCop::Cop::Style::AccessModifierDeclarations::INLINE_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# This cop enforces the use of either `#alias` or `#alias_method`
# depending on configuration.
# It also flags uses of `alias :symbol` rather than `alias bareword`.
#
# @example EnforcedStyle: prefer_alias (default)
#   # bad
#   alias_method :bar, :foo
#   alias :bar :foo
#
#   # good
#   alias bar foo
# @example EnforcedStyle: prefer_alias_method
#   # bad
#   alias :bar :foo
#   alias bar foo
#
#   # good
#   alias_method :bar, :foo
#
# source://rubocop//lib/rubocop/cop/style/alias.rb#25
class RuboCop::Cop::Style::Alias < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/alias.rb#52
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#42
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#34
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/alias.rb#73
  def add_offense_for_args(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#64
  def alias_keyword_possible?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#68
  def alias_method_possible?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#110
  def bareword?(sym_node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#114
  def correct_alias_method_to_alias(send_node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#122
  def correct_alias_to_alias_method(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#131
  def correct_alias_with_symbol_args(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#103
  def lexical_scope_type(node); end

  # In this expression, will `self` be the same as the innermost enclosing
  # class or module block (:lexical)? Or will it be something else
  # (:dynamic)? If we're in an instance_eval block, return that.
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#86
  def scope_type(node); end
end

# source://rubocop//lib/rubocop/cop/style/alias.rb#28
RuboCop::Cop::Style::Alias::MSG_ALIAS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/alias.rb#29
RuboCop::Cop::Style::Alias::MSG_ALIAS_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/alias.rb#31
RuboCop::Cop::Style::Alias::MSG_SYMBOL_ARGS = T.let(T.unsafe(nil), String)

# This cop checks for uses of `and` and `or`, and suggests using `&&` and
# `||` instead. It can be configured to check only in conditions or in
# all contexts.
#
# @example EnforcedStyle: always (default)
#   # bad
#   foo.save and return
#
#   # bad
#   if foo and bar
#   end
#
#   # good
#   foo.save && return
#
#   # good
#   if foo && bar
#   end
# @example EnforcedStyle: conditionals
#   # bad
#   if foo and bar
#   end
#
#   # good
#   foo.save && return
#
#   # good
#   foo.save and return
#
#   # good
#   if foo && bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/and_or.rb#39
class RuboCop::Cop::Style::AndOr < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#45
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#50
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#45
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#50
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#50
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#50
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#50
  def on_while_post(node); end

  private

  # ! is a special case:
  # 'x and !obj.method arg' can be auto-corrected if we
  # recurse down a level and add parens to 'obj.method arg'
  # however, 'not x' also parses as (send x :!)
  #
  # source://rubocop//lib/rubocop/cop/style/and_or.rb#112
  def correct_not(node, receiver, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#124
  def correct_other(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#92
  def correct_send(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#103
  def correct_setter(node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/and_or.rb#131
  def correctable_send?(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#88
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#76
  def on_conditionals(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#82
  def process_logical_operator(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#135
  def whitespace_before_arg(node); end
end

# source://rubocop//lib/rubocop/cop/style/and_or.rb#43
RuboCop::Cop::Style::AndOr::MSG = T.let(T.unsafe(nil), String)

# Common functionality related to annotation comments.
#
# source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7
module RuboCop::Cop::Style::AnnotationComment
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#10
  def annotation?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#27
  def just_first_word_of_sentence?(first_word, colon, space, note); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#31
  def keyword?(word); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#23
  def keyword_appearance?(first_word, colon, space); end

  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#16
  def split_comment(comment); end
end

# This cop checks for uses of "*" as a substitute for *join*.
#
# Not all cases can reliably checked, due to Ruby's dynamic
# types, so we consider only cases when the first argument is an
# array literal or the second is a string literal.
#
# @example
#
#   # bad
#   %w(foo bar baz) * ","
#
#   # good
#   %w(foo bar baz).join(",")
#
# source://rubocop//lib/rubocop/cop/style/array_join.rb#20
class RuboCop::Cop::Style::ArrayJoin < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/array_join.rb#29
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/array_join.rb#23
  def join_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/array_join.rb#25
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/array_join.rb#21
RuboCop::Cop::Style::ArrayJoin::MSG = T.let(T.unsafe(nil), String)

# This cop checks for non-ascii (non-English) characters
# in comments. You could set an array of allowed non-ascii chars in
# AllowedChars attribute (empty by default).
#
# @example
#   # bad
#   # Translates from English to 
#
#   # good
#   # Translates from English to Japanese
#
# source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#18
class RuboCop::Cop::Style::AsciiComments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#23
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#54
  def allowed_non_ascii_chars; end

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#45
  def first_non_ascii_chars(string); end

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#34
  def first_offense_range(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#49
  def only_allowed_non_ascii_chars?(string); end
end

# source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#21
RuboCop::Cop::Style::AsciiComments::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of Module#attr.
#
# @example
#   # bad - creates a single attribute accessor (deprecated in Ruby 1.9)
#   attr :something, true
#   attr :one, :two, :three # behaves as attr_reader
#
#   # good
#   attr_accessor :something
#   attr_reader :one, :two, :three
#
# source://rubocop//lib/rubocop/cop/style/attr.rb#17
class RuboCop::Cop::Style::Attr < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/attr.rb#28
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/attr.rb#22
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/attr.rb#46
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/attr.rb#50
  def replacement_method(node); end
end

# source://rubocop//lib/rubocop/cop/style/attr.rb#20
RuboCop::Cop::Style::Attr::MSG = T.let(T.unsafe(nil), String)

# This cop checks for cases when you could use a block
# accepting version of a method that does automatic
# resource cleanup.
#
# @example
#
#   # bad
#   f = File.open('file')
#
#   # good
#   File.open('file') do |f|
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#19
class RuboCop::Cop::Style::AutoResourceCleanup < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#26
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#43
  def cleanup?(node); end
end

# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#20
RuboCop::Cop::Style::AutoResourceCleanup::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#22
RuboCop::Cop::Style::AutoResourceCleanup::TARGET_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks if usage of %() or %Q() matches configuration.
#
# @example EnforcedStyle: bare_percent (default)
#   # bad
#   %Q(He said: "#{greeting}")
#   %q{She said: 'Hi'}
#
#   # good
#   %(He said: "#{greeting}")
#   %{She said: 'Hi'}
# @example EnforcedStyle: percent_q
#   # bad
#   %|He said: "#{greeting}"|
#   %/She said: 'Hi'/
#
#   # good
#   %Q|He said: "#{greeting}"|
#   %q/She said: 'Hi'/
#
# source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#26
class RuboCop::Cop::Style::BarePercentLiterals < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#39
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#31
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#35
  def on_str(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#70
  def add_offense_for_wrong_style(node, good, bad); end

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#49
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#66
  def requires_bare_percent?(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#62
  def requires_percent_q?(source); end
end

# source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#29
RuboCop::Cop::Style::BarePercentLiterals::MSG = T.let(T.unsafe(nil), String)

# This cop checks for BEGIN blocks.
#
# @example
#   # bad
#   BEGIN { test }
#
# source://rubocop//lib/rubocop/cop/style/begin_block.rb#13
class RuboCop::Cop::Style::BeginBlock < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/begin_block.rb#16
  def on_preexe(node); end
end

# source://rubocop//lib/rubocop/cop/style/begin_block.rb#14
RuboCop::Cop::Style::BeginBlock::MSG = T.let(T.unsafe(nil), String)

# This cop looks for uses of block comments (=begin...=end).
#
# @example
#   # bad
#   =begin
#   Multiple lines
#   of comments...
#   =end
#
#   # good
#   # Multiple lines
#   # of comments...
#
# source://rubocop//lib/rubocop/cop/style/block_comments.rb#19
class RuboCop::Cop::Style::BlockComments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#34
  def autocorrect(comment); end

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#26
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#52
  def parts(comment); end
end

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#23
RuboCop::Cop::Style::BlockComments::BEGIN_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#24
RuboCop::Cop::Style::BlockComments::END_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#22
RuboCop::Cop::Style::BlockComments::MSG = T.let(T.unsafe(nil), String)

# Check for uses of braces or do/end around single line or
# multi-line blocks.
#
# @example EnforcedStyle: line_count_based (default)
#   # bad - single line block
#   items.each do |item| item / 5 end
#
#   # good - single line block
#   items.each { |item| item / 5 }
#
#   # bad - multi-line block
#   things.map { |thing|
#   something = thing.some_method
#   process(something)
#   }
#
#   # good - multi-line block
#   things.map do |thing|
#   something = thing.some_method
#   process(something)
#   end
# @example EnforcedStyle: semantic
#   # Prefer `do...end` over `{...}` for procedural blocks.
#
#   # return value is used/assigned
#   # bad
#   foo = map do |x|
#   x
#   end
#   puts (map do |x|
#   x
#   end)
#
#   # return value is not used out of scope
#   # good
#   map do |x|
#   x
#   end
#
#   # Prefer `{...}` over `do...end` for functional blocks.
#
#   # return value is not used out of scope
#   # bad
#   each { |x|
#   x
#   }
#
#   # return value is used/assigned
#   # good
#   foo = map { |x|
#   x
#   }
#   map { |x|
#   x
#   }.inspect
#
#   # The AllowBracesOnProceduralOneLiners option is ignored unless the
#   # EnforcedStyle is set to `semantic`. If so:
#
#   # If the AllowBracesOnProceduralOneLiners option is unspecified, or
#   # set to `false` or any other falsey value, then semantic purity is
#   # maintained, so one-line procedural blocks must use do-end, not
#   # braces.
#
#   # bad
#   collection.each { |element| puts element }
#
#   # good
#   collection.each do |element| puts element end
#
#   # If the AllowBracesOnProceduralOneLiners option is set to `true`, or
#   # any other truthy value, then one-line procedural blocks may use
#   # either style. (There is no setting for requiring braces on them.)
#
#   # good
#   collection.each { |element| puts element }
#
#   # also good
#   collection.each do |element| puts element end
# @example EnforcedStyle: braces_for_chaining
#   # bad
#   words.each do |word|
#   word.flip.flop
#   end.join("-")
#
#   # good
#   words.each { |word|
#   word.flip.flop
#   }.join("-")
#
# source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#98
class RuboCop::Cop::Style::BlockDelimiters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#122
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#116
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#102
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#309
  def array_or_range?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#152
  def braces_for_chaining_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#250
  def braces_for_chaining_style?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#305
  def conditional?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#264
  def correction_would_break_code?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#274
  def functional_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#270
  def functional_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#206
  def get_blocks(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#235
  def line_count_based_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#134
  def line_count_based_message(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#164
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#282
  def procedural_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#278
  def procedural_oneliners_may_have_braces?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#225
  def proper_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#172
  def replace_braces_with_do_end(loc); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#185
  def replace_do_end_with_braces(loc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#260
  def return_value_chaining?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#298
  def return_value_of_scope?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#286
  def return_value_used?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#239
  def semantic_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#142
  def semantic_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#201
  def whitespace_after?(range, length = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#197
  def whitespace_before?(range); end
end

# This cop checks for braces around the last parameter in a method call
# if the last parameter is a hash.
# It supports `braces`, `no_braces` and `context_dependent` styles.
#
# @example EnforcedStyle: braces
#   # The `braces` style enforces braces around all method
#   # parameters that are hashes.
#
#   # bad
#   some_method(x, y, a: 1, b: 2)
#
#   # good
#   some_method(x, y, {a: 1, b: 2})
# @example EnforcedStyle: no_braces (default)
#   # The `no_braces` style checks that the last parameter doesn't
#   # have braces around it.
#
#   # bad
#   some_method(x, y, {a: 1, b: 2})
#
#   # good
#   some_method(x, y, a: 1, b: 2)
# @example EnforcedStyle: context_dependent
#   # The `context_dependent` style checks that the last parameter
#   # doesn't have braces around it, but requires braces if the
#   # second to last parameter is also a hash literal.
#
#   # bad
#   some_method(x, y, {a: 1, b: 2})
#   some_method(x, y, {a: 1, b: 2}, a: 1, b: 2)
#
#   # good
#   some_method(x, y, a: 1, b: 2)
#   some_method(x, y, {a: 1, b: 2}, {a: 1, b: 2})
#
# source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#42
class RuboCop::Cop::Style::BracesAroundHashParameters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # We let AutocorrectUnlessChangingAST#autocorrect work with the send
  # node, because that context is needed. When parsing the code to see if
  # the AST has changed, a braceless hash would not be parsed as a hash
  # otherwise.
  #
  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#62
  def autocorrect(send_node); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#48
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#48
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#100
  def add_arg_offense(arg, type); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#183
  def add_braces(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#78
  def check(arg, args); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#88
  def check_context_dependent(arg, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#115
  def extra_left_space?(hash_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#122
  def extra_right_space?(hash_node); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#106
  def extra_space(hash_node); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#165
  def left_brace_and_space(loc_begin, space); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#149
  def left_whole_line_range(loc_begin); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#144
  def remove_braces_with_range(corrector, left_range, right_range); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#130
  def remove_braces_with_whitespace(corrector, node, space); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#172
  def right_brace_and_space(loc_end, space); end

  # source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#157
  def right_whole_line_range(loc_end); end
end

# source://rubocop//lib/rubocop/cop/style/braces_around_hash_parameters.rb#46
RuboCop::Cop::Style::BracesAroundHashParameters::MSG = T.let(T.unsafe(nil), String)

# Corrector to correct conditional assignment in `case` statements.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#615
class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#620
    def correct(cop, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#633
    def move_assignment_inside_condition(node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#656
    def extract_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#650
    def extract_tail_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#662
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

# This cop checks for uses of the case equality operator(===).
#
# @example
#   # bad
#   Array === something
#   (1..100) === 7
#   /something/ === some_string
#
#   # good
#   something.is_a?(Array)
#   (1..100).include?(7)
#   some_string =~ /something/
#
# source://rubocop//lib/rubocop/cop/style/case_equality.rb#19
class RuboCop::Cop::Style::CaseEquality < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#22
  def case_equality?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#24
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/case_equality.rb#20
RuboCop::Cop::Style::CaseEquality::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of the character literal ?x.
#
# @example
#   # bad
#   ?x
#
#   # good
#   'x'
#
#   # good
#   ?\C-\M-d
#
# source://rubocop//lib/rubocop/cop/style/character_literal.rb#17
class RuboCop::Cop::Style::CharacterLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StringHelp

  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#29
  def autocorrect(node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#49
  def correct_style_detected; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#23
  def offense?(node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#45
  def opposite_style_detected; end
end

# source://rubocop//lib/rubocop/cop/style/character_literal.rb#20
RuboCop::Cop::Style::CharacterLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop checks the style of children definitions at classes and
# modules. Basically there are two different styles:
#
# The compact style is only forced for classes/modules with one child.
#
# @example EnforcedStyle: nested (default)
#   # good
#   # have each child on its own line
#   class Foo
#   class Bar
#   end
#   end
# @example EnforcedStyle: compact
#   # good
#   # combine definitions as much as possible
#   class Foo::Bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#24
class RuboCop::Cop::Style::ClassAndModuleChildren < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#45
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#33
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#40
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#89
  def add_trailing_end(corrector, node, padding); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#137
  def check_compact_style(node, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#131
  def check_nested_style(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#123
  def check_style(node, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#94
  def compact_definition(corrector, node, name, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#99
  def compact_node(corrector, node, name, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#147
  def compact_node_name?(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#119
  def indent_width; end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#115
  def leading_spaces(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#67
  def nest_definition(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#59
  def nest_or_compact(corrector, node, name, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#143
  def one_child?(body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#107
  def remove_end(corrector, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#76
  def replace_keyword_with_module(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#80
  def split_on_double_colon(corrector, node, padding); end
end

# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#30
RuboCop::Cop::Style::ClassAndModuleChildren::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#28
RuboCop::Cop::Style::ClassAndModuleChildren::NESTED_MSG = T.let(T.unsafe(nil), String)

# This cop enforces consistent use of `Object#is_a?` or `Object#kind_of?`.
#
# @example EnforcedStyle: is_a? (default)
#   # bad
#   var.kind_of?(Date)
#   var.kind_of?(Integer)
#
#   # good
#   var.is_a?(Date)
#   var.is_a?(Integer)
# @example EnforcedStyle: kind_of?
#   # bad
#   var.is_a?(Time)
#   var.is_a?(String)
#
#   # good
#   var.kind_of?(Time)
#   var.kind_of?(String)
#
# source://rubocop//lib/rubocop/cop/style/class_check.rb#26
class RuboCop::Cop::Style::ClassCheck < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#31
  def class_check?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#49
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#33
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/class_check.rb#29
RuboCop::Cop::Style::ClassCheck::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of the class/module name instead of
# self, when defining class/module methods.
#
# @example
#   # bad
#   class SomeClass
#   def SomeClass.class_method
#   # ...
#   end
#   end
#
#   # good
#   class SomeClass
#   def self.class_method
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_methods.rb#23
class RuboCop::Cop::Style::ClassMethods < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#26
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#31
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#42
  def check(name, node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#52
  def check_defs(name, node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#62
  def message(class_name, method_name); end
end

# source://rubocop//lib/rubocop/cop/style/class_methods.rb#24
RuboCop::Cop::Style::ClassMethods::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of class variables. Offenses
# are signaled only on assignment to class variables to
# reduce the number of offenses that would be reported.
#
# You have to be careful when setting a value for a class
# variable; if a class has been inherited, changing the
# value of a class variable also affects the inheriting
# classes. This means that it's almost always better to
# use a class instance variable instead.
#
# @example
#   # bad
#   class A
#   @@test = 10
#   end
#
#   # good
#   class A
#   @test = 10
#   end
#
#   class A
#   def test
#   @@test # you can access class variable without offense
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_vars.rb#33
class RuboCop::Cop::Style::ClassVars < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/class_vars.rb#41
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/class_vars.rb#37
  def on_cvasgn(node); end
end

# source://rubocop//lib/rubocop/cop/style/class_vars.rb#34
RuboCop::Cop::Style::ClassVars::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the use of consistent method names
# from the Enumerable module.
#
# Unfortunately we cannot actually know if a method is from
# Enumerable or not (static analysis limitation), so this cop
# can yield some false positives.
#
# You can customize the mapping from undesired method to desired method.
#
# e.g. to use `detect` over `find`:
#
#   Style/CollectionMethods:
#     PreferredMethods:
#       find: detect
#
# The default mapping for `PreferredMethods` behaves as follows.
#
# @example
#   # bad
#   items.collect
#   items.collect!
#   items.inject
#   items.detect
#   items.find_all
#
#   # good
#   items.map
#   items.map!
#   items.reduce
#   items.find
#   items.select
#
# source://rubocop//lib/rubocop/cop/style/collection_methods.rb#38
class RuboCop::Cop::Style::CollectionMethods < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::MethodPreference

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#54
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#43
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#47
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#69
  def check_method_node(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#63
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/style/collection_methods.rb#41
RuboCop::Cop::Style::CollectionMethods::MSG = T.let(T.unsafe(nil), String)

# This cop checks for methods invoked via the :: operator instead
# of the . operator (like FileUtils::rmdir instead of FileUtils.rmdir).
#
# @example
#   # bad
#   Timeout::timeout(500) { do_something }
#   FileUtils::rmdir(dir)
#   Marshal::dump(obj)
#
#   # good
#   Timeout.timeout(500) { do_something }
#   FileUtils.rmdir(dir)
#   Marshal.dump(obj)
#
# source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#20
class RuboCop::Cop::Style::ColonMethodCall < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#23
  def java_type_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#32
  def on_send(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#28
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#21
RuboCop::Cop::Style::ColonMethodCall::MSG = T.let(T.unsafe(nil), String)

# This cop checks for class methods that are defined using the `::`
# operator instead of the `.` operator.
#
# @example
#   # bad
#   class Foo
#   def self::bar
#   end
#   end
#
#   # good
#   class Foo
#   def self.bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#22
class RuboCop::Cop::Style::ColonMethodDefinition < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#25
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#23
RuboCop::Cop::Style::ColonMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# This cop enforces using `` or %x around command literals.
#
# @example EnforcedStyle: backticks (default)
#   # bad
#   folders = %x(find . -type d).split
#
#   # bad
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
#
#   # good
#   folders = `find . -type d`.split
#
#   # good
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
# @example EnforcedStyle: mixed
#   # bad
#   folders = %x(find . -type d).split
#
#   # bad
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
#
#   # good
#   folders = `find . -type d`.split
#
#   # good
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
# @example EnforcedStyle: percent_x
#   # bad
#   folders = `find . -type d`.split
#
#   # bad
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
#
#   # good
#   folders = %x(find . -type d).split
#
#   # good
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
# @example AllowInnerBackticks: false (default)
#   # If `false`, the cop will always recommend using `%x` if one or more
#   # backticks are found in the command string.
#
#   # bad
#   `echo \`ls\``
#
#   # good
#   %x(echo `ls`)
# @example AllowInnerBackticks: true
#   # good
#   `echo \`ls\``
#
# source://rubocop//lib/rubocop/cop/style/command_literal.rb#78
class RuboCop::Cop::Style::CommandLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#94
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#84
  def on_xstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#151
  def allow_inner_backticks?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#127
  def allowed_backtick_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#136
  def allowed_percent_x_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#164
  def backtick_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#111
  def check_backtick_literal(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#117
  def check_percent_x_literal(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#172
  def command_delimiter; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#155
  def contains_backtick?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#147
  def contains_disallowed_backtick?(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#176
  def default_delimiter; end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#123
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#159
  def node_body(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#168
  def preferred_delimiter; end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#180
  def preferred_delimiters_config; end
end

# source://rubocop//lib/rubocop/cop/style/command_literal.rb#81
RuboCop::Cop::Style::CommandLiteral::MSG_USE_BACKTICKS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/command_literal.rb#82
RuboCop::Cop::Style::CommandLiteral::MSG_USE_PERCENT_X = T.let(T.unsafe(nil), String)

# This cop checks that comment annotation keywords are written according
# to guidelines.
#
# @example
#   # bad
#   # TODO make better
#
#   # good
#   # TODO: make better
#
#   # bad
#   # TODO:make better
#
#   # good
#   # TODO: make better
#
#   # bad
#   # fixme: does not work
#
#   # good
#   # FIXME: does not work
#
#   # bad
#   # Optimize does not work
#
#   # good
#   # OPTIMIZE: does not work
#
# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#33
class RuboCop::Cop::Style::CommentAnnotation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#61
  def autocorrect(comment); end

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#43
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#82
  def annotation_range(comment, margin, length); end

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#87
  def concat_length(*args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#91
  def correct_annotation?(first_word, colon, space, note); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#73
  def first_comment_line?(comments, index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#78
  def inline_comment?(comment); end
end

# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#40
RuboCop::Cop::Style::CommentAnnotation::MISSING_NOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#37
RuboCop::Cop::Style::CommentAnnotation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for comments put on the same line as some keywords.
# These keywords are: `begin`, `class`, `def`, `end`, `module`.
#
# are allowed.
#
# @example
#   # bad
#   if condition
#   statement
#   end # end if
#
#   # bad
#   class X # comment
#   statement
#   end
#
#   # bad
#   def x; end # comment
#
#   # good
#   if condition
#   statement
#   end
#
#   # good
#   class X # :nodoc:
#   y
#   end
#
# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#35
class RuboCop::Cop::Style::CommentedKeyword < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#41
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#76
  def extract_heredoc_lines(ast); end

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#70
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#64
  def offensive?(line); end
end

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#62
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#61
RuboCop::Cop::Style::CommentedKeyword::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#38
RuboCop::Cop::Style::CommentedKeyword::MSG = T.let(T.unsafe(nil), String)

# Check for `if` and `case` statements where each branch is used for
# assignment to the same variable when using the return of the
# condition can be used instead.
#
# @example EnforcedStyle: assign_to_condition (default)
#   # bad
#   if foo
#   bar = 1
#   else
#   bar = 2
#   end
#
#   case foo
#   when 'a'
#   bar += 1
#   else
#   bar += 2
#   end
#
#   if foo
#   some_method
#   bar = 1
#   else
#   some_other_method
#   bar = 2
#   end
#
#   # good
#   bar = if foo
#   1
#   else
#   2
#   end
#
#   bar += case foo
#   when 'a'
#   1
#   else
#   2
#   end
#
#   bar << if foo
#   some_method
#   1
#   else
#   some_other_method
#   2
#   end
# @example EnforcedStyle: assign_inside_condition
#   # bad
#   bar = if foo
#   1
#   else
#   2
#   end
#
#   bar += case foo
#   when 'a'
#   1
#   else
#   2
#   end
#
#   bar << if foo
#   some_method
#   1
#   else
#   some_other_method
#   2
#   end
#
#   # good
#   if foo
#   bar = 1
#   else
#   bar = 2
#   end
#
#   case foo
#   when 'a'
#   bar += 1
#   else
#   bar += 2
#   end
#
#   if foo
#   some_method
#   bar = 1
#   else
#   some_other_method
#   bar = 2
#   end
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#202
class RuboCop::Cop::Style::ConditionalAssignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#226
  def assignment_type?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#271
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#301
  def candidate_condition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#222
  def condition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#261
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#247
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#234
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#241
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#307
  def allowed_single_line?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#374
  def allowed_statements?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#303
  def allowed_ternary?(assignment); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#311
  def assignment_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#359
  def assignment_types_match?(*nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#297
  def candidate_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#281
  def check_assignment_to_condition(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#365
  def check_node(node, branches); end

  # If `Metrics/LineLength` is enabled, we do not want to introduce an
  # offense by auto-correcting this cop. Find the max configured line
  # length. Find the longest line of condition. Remove the assignment
  # from lines that contain the offending assignment because after
  # correcting, this will not be on the line anymore. Check if the length
  # of the longest line + the length of the corrected assignment is
  # greater than the max configured line length
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#390
  def correction_exceeds_line_limit?(node, branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#427
  def include_ternary?; end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#419
  def indentation_width; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#352
  def lhs_all_match?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#411
  def line_length_cop_enabled?; end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#402
  def longest_line(node, assignment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#398
  def longest_line_exceeds_line_limit?(node, assignment); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#415
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#336
  def move_assignment_inside_condition(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#324
  def move_assignment_outside_condition(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#423
  def single_line_conditions_only?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#348
  def ternary_condition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#213
RuboCop::Cop::Style::ConditionalAssignment::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#209
RuboCop::Cop::Style::ConditionalAssignment::ASSIGN_TO_CONDITION_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#217
RuboCop::Cop::Style::ConditionalAssignment::ENABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#216
RuboCop::Cop::Style::ConditionalAssignment::INDENTATION_WIDTH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#215
RuboCop::Cop::Style::ConditionalAssignment::LINE_LENGTH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#218
RuboCop::Cop::Style::ConditionalAssignment::MAX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#207
RuboCop::Cop::Style::ConditionalAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#219
RuboCop::Cop::Style::ConditionalAssignment::SINGLE_LINE_CONDITIONS_ONLY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#211
RuboCop::Cop::Style::ConditionalAssignment::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#220
RuboCop::Cop::Style::ConditionalAssignment::WIDTH = T.let(T.unsafe(nil), String)

# Helper module to provide common methods to classes needed for the
# ConditionalAssignment Cop.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#8
module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#64
  def end_with_eq?(sym); end

  # `elsif` branches show up in the `node` as an `else`. We need
  # to recursively iterate over all `else` branches and consider all
  # but the last `node` an `elsif` branch and consider the last `node`
  # the actual `else` branch.
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#20
  def expand_elses(branch); end

  # `when` nodes contain the entire branch including the condition.
  # We only need the contents of the branch, not the condition.
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#28
  def expand_when_branches(when_branches); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#55
  def indent(cop, source); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#37
  def lhs(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#32
  def tail(branch); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#101
  def assignment_rhs_exist?(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#70
  def expand_elsif(node, elsif_branches = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#83
  def lhs_for_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#96
  def setter_method?(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#13
RuboCop::Cop::Style::ConditionalAssignmentHelper::ALIGN_WITH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#12
RuboCop::Cop::Style::ConditionalAssignmentHelper::END_ALIGNMENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#11
RuboCop::Cop::Style::ConditionalAssignmentHelper::EQUAL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#14
RuboCop::Cop::Style::ConditionalAssignmentHelper::KEYWORD = T.let(T.unsafe(nil), String)

# Helper module to provide common methods to ConditionalAssignment
# correctors
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#434
module RuboCop::Cop::Style::ConditionalCorrectorHelper
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#455
  def assignment(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#485
  def correct_branches(corrector, branches); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#462
  def correct_if_branches(corrector, cop, node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#435
  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#472
  def replace_branch_assignment(corrector, branch); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#446
  def white_space_range(node, column); end
end

# This cop checks that constants defined in classes and modules have
# an explicit visibility declaration. By default, Ruby makes all class-
# and module constants public, which litters the public API of the
# class or module. Explicitly declaring a visibility makes intent more
# clear, and prevents outside actors from touching private state.
#
# @example
#
#   # bad
#   class Foo
#   BAR = 42
#   BAZ = 43
#   end
#
#   # good
#   class Foo
#   BAR = 42
#   private_constant :BAR
#
#   BAZ = 43
#   public_constant :BAZ
#   end
#
# source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#29
class RuboCop::Cop::Style::ConstantVisibility < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#33
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#60
  def visibility_declaration_for?(node = T.unsafe(nil), param1); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#48
  def class_or_module_scope?(node); end

  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#42
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#52
  def visibility_declaration?(node); end
end

# source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#30
RuboCop::Cop::Style::ConstantVisibility::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/copyright.rb#18
class RuboCop::Cop::Style::Copyright < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # @raise [Warning]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#35
  def autocorrect(token); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#26
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#56
  def autocorrect_notice; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#74
  def encoding_token?(processed_source, token_index); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#60
  def insert_notice_before(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#52
  def notice; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#81
  def notice_found?(processed_source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#67
  def shebang_token?(processed_source, token_index); end
end

# source://rubocop//lib/rubocop/cop/style/copyright.rb#23
RuboCop::Cop::Style::Copyright::AUTOCORRECT_EMPTY_WARNING = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/copyright.rb#21
RuboCop::Cop::Style::Copyright::MSG = T.let(T.unsafe(nil), String)

# This cop checks for consistent usage of the `DateTime` class over the
# `Time` class. This cop is disabled by default since these classes,
# although highly overlapping, have particularities that make them not
# replaceable in certain situations when dealing with multiple timezones
# and/or DST.
#
# @example
#
#   # bad - uses `DateTime` for current time
#   DateTime.now
#
#   # good - uses `Time` for current time
#   Time.now
#
#   # bad - uses `DateTime` for modern date
#   DateTime.iso8601('2016-06-29')
#
#   # good - uses `Time` for modern date
#   Time.iso8601('2016-06-29')
#
#   # good - uses `DateTime` with start argument for historical date
#   DateTime.iso8601('1751-04-23', Date::ENGLAND)
# @example AllowCoercion: false (default)
#
#   # bad - coerces to `DateTime`
#   something.to_datetime
#
#   # good - coerces to `Time`
#   something.to_time
# @example AllowCoercion: true
#
#   # good
#   something.to_datetime
#
#   # good
#   something.to_time
#
# source://rubocop//lib/rubocop/cop/style/date_time.rb#44
class RuboCop::Cop::Style::DateTime < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/date_time.rb#48
  def date_time?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#52
  def historic_date?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#60
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#56
  def to_datetime?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/date_time.rb#71
  def disallow_coercion?; end
end

# source://rubocop//lib/rubocop/cop/style/date_time.rb#45
RuboCop::Cop::Style::DateTime::CLASS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/date_time.rb#46
RuboCop::Cop::Style::DateTime::COERCION_MSG = T.let(T.unsafe(nil), String)

# This cop checks for parentheses in the definition of a method,
# that does not take any arguments. Both instance and
# class/singleton methods are checked.
#
# @example
#
#   # bad
#   def foo()
#   # does a thing
#   end
#
#   # good
#   def foo
#   # does a thing
#   end
#
#   # also good
#   def foo() does_a_thing end
# @example
#
#   # bad
#   def Baz.foo()
#   # does a thing
#   end
#
#   # good
#   def Baz.foo
#   # does a thing
#   end
#
# source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#36
class RuboCop::Cop::Style::DefWithParentheses < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#48
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#40
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#40
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#37
RuboCop::Cop::Style::DefWithParentheses::MSG = T.let(T.unsafe(nil), String)

# This cop checks for places where the `#__dir__` method can replace more
# complex constructs to retrieve a canonicalized absolute path to the
# current file.
#
# @example
#   # bad
#   path = File.expand_path(File.dirname(__FILE__))
#
#   # bad
#   path = File.dirname(File.realpath(__FILE__))
#
#   # good
#   path = __dir__
#
# source://rubocop//lib/rubocop/cop/style/dir.rb#19
class RuboCop::Cop::Style::Dir < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/dir.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/dir.rb#23
  def dir_replacement?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/dir.rb#28
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/dir.rb#42
  def file_keyword?(node); end
end

# source://rubocop//lib/rubocop/cop/style/dir.rb#20
RuboCop::Cop::Style::Dir::MSG = T.let(T.unsafe(nil), String)

# This cop checks for missing top-level documentation of
# classes and modules. Classes with no body are exempt from the
# check and so are namespace modules - modules that have nothing in
# their bodies except classes, other modules, or constant definitions.
#
# The documentation requirement is annulled if the class or module has
# same for all its children.
#
# @example
#   # bad
#   class Person
#   # ...
#   end
#
#   # good
#   # Description/Explanation of Person class
#   class Person
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/documentation.rb#27
class RuboCop::Cop::Style::Documentation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DocumentationComment

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#32
  def constant_definition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#35
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#43
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#33
  def outer_module(node0); end

  private

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#51
  def check(node, body, type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#72
  def compact_namespace?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#62
  def namespace?(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#95
  def nodoc(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#91
  def nodoc?(comment, require_all = T.unsafe(nil)); end

  # Note: How end-of-line comments are associated with code changed in
  # parser-2.2.0.4.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#81
  def nodoc_comment?(node, require_all = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/documentation.rb#30
RuboCop::Cop::Style::Documentation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for missing documentation comment for public methods.
# It can optionally be configured to also require documentation for
# non-public methods.
#
# @example
#
#   # bad
#
#   class Foo
#   def bar
#   puts baz
#   end
#   end
#
#   module Foo
#   def bar
#   puts baz
#   end
#   end
#
#   def foo.bar
#   puts baz
#   end
#
#   # good
#
#   class Foo
#   # Documentation
#   def bar
#   puts baz
#   end
#   end
#
#   module Foo
#   # Documentation
#   def bar
#   puts baz
#   end
#   end
#
#   # Documentation
#   def foo.bar
#   puts baz
#   end
#
# source://rubocop//lib/rubocop/cop/style/documentation_method.rb#50
class RuboCop::Cop::Style::DocumentationMethod < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::DefNode

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#56
  def module_function_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#60
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#60
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#68
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#75
  def require_for_non_public_methods?; end
end

# source://rubocop//lib/rubocop/cop/style/documentation_method.rb#54
RuboCop::Cop::Style::DocumentationMethod::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of double negation (!!) to convert something
# to a boolean value. As this is both cryptic and usually redundant, it
# should be avoided.
#
# Please, note that when something is a boolean value
# !!something and !something.nil? are not the same thing.
# As you're unlikely to write code that can accept values of any type
# this is rarely a problem in practice.
#
# @example
#
#   # bad
#   !!something
#
#   # good
#   !something.nil?
#
# source://rubocop//lib/rubocop/cop/style/double_negation.rb#22
class RuboCop::Cop::Style::DoubleNegation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#25
  def double_negative?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#27
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/double_negation.rb#23
RuboCop::Cop::Style::DoubleNegation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for loops which iterate a constant number of times,
# using a Range literal and `#each`. This can be done more readably using
# `Integer#times`.
#
# This check only applies if the block takes no parameters.
#
# @example
#   # bad
#   (1..5).each { }
#
#   # good
#   5.times { }
# @example
#   # bad
#   (0...10).each {}
#
#   # good
#   10.times {}
#
# source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#25
class RuboCop::Cop::Style::EachForSimpleLoop < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#39
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#52
  def offending_each_range(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#29
  def on_block(node); end
end

# source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#26
RuboCop::Cop::Style::EachForSimpleLoop::MSG = T.let(T.unsafe(nil), String)

# This cop looks for inject / reduce calls where the passed in object is
# returned at the end and so could be replaced by each_with_object without
# the need to return the object at the end.
#
# However, we can't replace with each_with_object if the accumulator
# parameter is assigned to within the block.
#
# @example
#   # bad
#   [1, 2].inject({}) { |a, e| a[e] = e; a }
#
#   # good
#   [1, 2].each_with_object({}) { |e, a| a[e] = e }
#
# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#19
class RuboCop::Cop::Style::EachWithObject < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#45
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#25
  def each_with_object_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#29
  def on_block(node); end

  private

  # if the accumulator parameter is assigned to in the block,
  # then we can't convert to each_with_object
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#73
  def accumulator_param_assigned_to?(body, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#92
  def first_argument_returned?(args, return_value); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#85
  def return_value(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#100
  def return_value_occupies_whole_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#67
  def simple_method_arg?(method_arg); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#104
  def whole_line_expression(node); end
end

# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#23
RuboCop::Cop::Style::EachWithObject::METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#22
RuboCop::Cop::Style::EachWithObject::MSG = T.let(T.unsafe(nil), String)

# This cop checks for pipes for empty block parameters. Pipes for empty
# block parameters do not cause syntax errors, but they are redundant.
#
# @example
#   # bad
#   a do ||
#   do_something
#   end
#
#   # bad
#   a { || do_something }
#
#   # good
#   a do
#   end
#
#   # good
#   a { do_something }
#
# source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#24
class RuboCop::Cop::Style::EmptyBlockParameter < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#30
  def on_block(node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#28
RuboCop::Cop::Style::EmptyBlockParameter::MSG = T.let(T.unsafe(nil), String)

# This cop checks for case statements with an empty condition.
#
# @example
#
#   # bad:
#   case
#   when x == 0
#   puts 'x is 0'
#   when y == 0
#   puts 'y is 0'
#   else
#   puts 'neither is 0'
#   end
#
#   # good:
#   if x == 0
#   puts 'x is 0'
#   elsif y == 0
#   puts 'y is 0'
#   else
#   puts 'neither is 0'
#   end
#
#   # good: (the case condition node is not empty)
#   case n
#   when 0
#   puts 'zero'
#   when 1
#   puts 'one'
#   else
#   puts 'more'
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#38
class RuboCop::Cop::Style::EmptyCaseCondition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#58
  def autocorrect(case_node); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#44
  def on_case(case_node); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#69
  def correct_case_when(corrector, case_node, when_nodes); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#81
  def correct_when_conditions(corrector, when_nodes); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#94
  def keep_first_when_comment(case_node, first_when_node, corrector); end
end

# source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#41
RuboCop::Cop::Style::EmptyCaseCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for empty else-clauses, possibly including comments and/or an
# explicit `nil` depending on the EnforcedStyle.
#
# @example EnforcedStyle: empty
#   # warn only on empty else
#
#   # bad
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
# @example EnforcedStyle: nil
#   # warn on else with nil in it
#
#   # bad
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # good
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
# @example EnforcedStyle: both (default)
#   # warn on empty else and else with nil in it
#
#   # bad
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # bad
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_else.rb#92
class RuboCop::Cop::Style::EmptyElse < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#107
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#103
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#99
  def on_normal_if_unless(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#164
  def autocorrect_forbidden?(type); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#155
  def base_node(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#119
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#144
  def comment_in_else?(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#149
  def else_line_range(loc); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#132
  def empty_check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#128
  def empty_style?; end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#168
  def missing_else_style; end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#138
  def nil_check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#124
  def nil_style?; end
end

# source://rubocop//lib/rubocop/cop/style/empty_else.rb#97
RuboCop::Cop::Style::EmptyElse::MSG = T.let(T.unsafe(nil), String)

# This cop checks for parentheses for empty lambda parameters. Parentheses
# for empty lambda parameters do not cause syntax errors, but they are
# redundant.
#
# @example
#   # bad
#   -> () { do_something }
#
#   # good
#   -> { do_something }
#
#   # good
#   -> (arg) { do_something(arg) }
#
# source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#19
class RuboCop::Cop::Style::EmptyLambdaParameter < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#32
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#25
  def on_block(node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#23
RuboCop::Cop::Style::EmptyLambdaParameter::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of a method, the result of which
# would be a literal, like an empty array, hash, or string.
#
# @example
#   # bad
#   a = Array.new
#   h = Hash.new
#   s = String.new
#
#   # good
#   a = []
#   h = {}
#   s = ''
#
# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#19
class RuboCop::Cop::Style::EmptyLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#28
  def array_node(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#31
  def array_with_block(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#49
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#29
  def hash_node(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#33
  def hash_with_block(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#36
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#30
  def str_node(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#103
  def correction(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#61
  def enforce_double_quotes?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#69
  def first_argument_unparenthesized?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#94
  def offense_array_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#98
  def offense_hash_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#57
  def preferred_string_literal; end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#79
  def replacement_range(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#65
  def string_literals_config; end
end

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#23
RuboCop::Cop::Style::EmptyLiteral::ARR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#24
RuboCop::Cop::Style::EmptyLiteral::HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#25
RuboCop::Cop::Style::EmptyLiteral::STR_MSG = T.let(T.unsafe(nil), String)

# This cop checks for the formatting of empty method definitions.
# By default it enforces empty method definitions to go on a single
# line (compact style), but it can be configured to enforce the `end`
# to go on its own line (expanded style).
#
# Note: A method definition is not considered empty if it contains
#       comments.
#
# @example EnforcedStyle: compact (default)
#   # bad
#   def foo(bar)
#   end
#
#   def self.foo(bar)
#   end
#
#   # good
#   def foo(bar); end
#
#   def foo(bar)
#   # baz
#   end
#
#   def self.foo(bar); end
# @example EnforcedStyle: expanded
#   # bad
#   def foo(bar); end
#
#   def self.foo(bar); end
#
#   # good
#   def foo(bar)
#   end
#
#   def self.foo(bar)
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_method.rb#43
class RuboCop::Cop::Style::EmptyMethod < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#50
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#50
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#93
  def comment_lines?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#97
  def compact?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#105
  def compact_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#70
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#75
  def corrected(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#101
  def expanded?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#109
  def expanded_style?; end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#87
  def joint(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#66
  def message(_node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_method.rb#46
RuboCop::Cop::Style::EmptyMethod::MSG_COMPACT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_method.rb#47
RuboCop::Cop::Style::EmptyMethod::MSG_EXPANDED = T.let(T.unsafe(nil), String)

# This cop checks ensures source files have no utf-8 encoding comments.
#
# @example
#   # bad
#   # encoding: UTF-8
#   # coding: UTF-8
#   # -*- coding: UTF-8 -*-
#
# source://rubocop//lib/rubocop/cop/style/encoding.rb#12
class RuboCop::Cop::Style::Encoding < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#29
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#19
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#48
  def encoding_line_number(processed_source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/encoding.rb#44
  def encoding_omitable?(line); end

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#38
  def offense(processed_source, line_number); end
end

# source://rubocop//lib/rubocop/cop/style/encoding.rb#16
RuboCop::Cop::Style::Encoding::ENCODING_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/encoding.rb#15
RuboCop::Cop::Style::Encoding::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/encoding.rb#17
RuboCop::Cop::Style::Encoding::SHEBANG = T.let(T.unsafe(nil), String)

# This cop checks for END blocks.
#
# @example
#   # bad
#   END { puts 'Goodbye!' }
#
#   # good
#   at_exit { puts 'Goodbye!' }
#
# source://rubocop//lib/rubocop/cop/style/end_block.rb#15
class RuboCop::Cop::Style::EndBlock < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/end_block.rb#19
  def on_postexe(node); end
end

# source://rubocop//lib/rubocop/cop/style/end_block.rb#16
RuboCop::Cop::Style::EndBlock::MSG = T.let(T.unsafe(nil), String)

# This cop checks `eval` method usage. `eval` can receive source location
# metadata, that are filename and line number. The metadata is used by
# backtraces. This cop recommends to pass the metadata to `eval` method.
#
# @example
#   # bad
#   eval <<-RUBY
#   def do_something
#   end
#   RUBY
#
#   # bad
#   C.class_eval <<-RUBY
#   def do_something
#   end
#   RUBY
#
#   # good
#   eval <<-RUBY, binding, __FILE__, __LINE__ + 1
#   def do_something
#   end
#   RUBY
#
#   # good
#   C.class_eval <<-RUBY, __FILE__, __LINE__ + 1
#   def do_something
#   end
#   RUBY
#
# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#34
class RuboCop::Cop::Style::EvalWithLocation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#40
  def eval_without_location?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#56
  def line_with_offset?(node = T.unsafe(nil), param1, param2); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#63
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#135
  def add_offense_for_different_line(node, line_node, line_diff); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#125
  def add_offense_for_same_line(node, line_node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#96
  def message_incorrect_line(actual, sign, line_diff); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#106
  def on_with_lineno(node, code); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#75
  def special_file_keyword?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#80
  def special_line_keyword?(node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#117
  def string_first_line(str_node); end

  # FIXME: It's a Style/ConditionalAssignment's false positive.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#87
  def with_lineno?(node); end
end

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#35
RuboCop::Cop::Style::EvalWithLocation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#37
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_LINE = T.let(T.unsafe(nil), String)

# This cop checks for places where `Integer#even?` or `Integer#odd?`
# can be used.
#
# @example
#
#   # bad
#   if x % 2 == 0
#   end
#
#   # good
#   if x.even?
#   end
#
# source://rubocop//lib/rubocop/cop/style/even_odd.rb#18
class RuboCop::Cop::Style::EvenOdd < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#21
  def even_odd_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#29
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#47
  def replacement_method(arg, method); end
end

# source://rubocop//lib/rubocop/cop/style/even_odd.rb#19
RuboCop::Cop::Style::EvenOdd::MSG = T.let(T.unsafe(nil), String)

# This cop checks for use of the `File.expand_path` arguments.
# Likewise, it also checks for the `Pathname.new` argument.
#
# Contrastive bad case and good case are alternately shown in
# the following examples.
#
# @example
#   # bad
#   File.expand_path('..', __FILE__)
#
#   # good
#   File.expand_path(__dir__)
#
#   # bad
#   File.expand_path('../..', __FILE__)
#
#   # good
#   File.expand_path('..', __dir__)
#
#   # bad
#   File.expand_path('.', __FILE__)
#
#   # good
#   File.expand_path(__FILE__)
#
#   # bad
#   Pathname(__FILE__).parent.expand_path
#
#   # good
#   Pathname(__dir__).expand_path
#
#   # bad
#   Pathname.new(__FILE__).parent.expand_path
#
#   # good
#   Pathname.new(__dir__).expand_path
#
# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#43
class RuboCop::Cop::Style::ExpandPathArguments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#92
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#54
  def file_expand_path(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#76
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#68
  def pathname_new_parent_expand_path(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#61
  def pathname_parent_expand_path(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#187
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#133
  def autocorrect_expand_path(corrector, current_path, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#160
  def depth(current_path); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#112
  def inspect_offense_for_expand_path(node, current_path, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#166
  def parent_path(current_path); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#180
  def remove_parent_method(corrector, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#153
  def strip_surrounded_quotes!(path_string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#108
  def unrecommended_argument?(default_dir); end
end

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#46
RuboCop::Cop::Style::ExpandPathArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#48
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#50
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_NEW_MSG = T.let(T.unsafe(nil), String)

# This cop looks for uses of the `for` keyword or `each` method. The
# preferred alternative is set in the EnforcedStyle configuration
# parameter. An `each` call with a block on a single line is always
# allowed.
#
# @example EnforcedStyle: each (default)
#   # bad
#   def foo
#   for n in [1, 2, 3] do
#   puts n
#   end
#   end
#
#   # good
#   def foo
#   [1, 2, 3].each do |n|
#   puts n
#   end
#   end
# @example EnforcedStyle: for
#   # bad
#   def foo
#   [1, 2, 3].each do |n|
#   puts n
#   end
#   end
#
#   # good
#   def foo
#   for n in [1, 2, 3] do
#   puts n
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/for.rb#41
class RuboCop::Cop::Style::For < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/for.rb#71
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/for.rb#59
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/for.rb#49
  def on_for(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/for.rb#81
  def suspect_enumerable?(node); end
end

# source://rubocop//lib/rubocop/cop/style/for.rb#45
RuboCop::Cop::Style::For::EACH_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/for.rb#46
RuboCop::Cop::Style::For::PREFER_EACH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/for.rb#47
RuboCop::Cop::Style::For::PREFER_FOR = T.let(T.unsafe(nil), String)

# This cop enforces the use of a single string formatting utility.
# Valid options include Kernel#format, Kernel#sprintf and String#%.
#
# The detection of String#% cannot be implemented in a reliable
# manner for all cases, so only two scenarios are considered -
# if the first argument is a string literal and if the second
# argument is an array literal.
#
# @example EnforcedStyle: format (default)
#   # bad
#   puts sprintf('%10s', 'hoge')
#   puts '%10s' % 'hoge'
#
#   # good
#   puts format('%10s', 'hoge')
# @example EnforcedStyle: sprintf
#   # bad
#   puts format('%10s', 'hoge')
#   puts '%10s' % 'hoge'
#
#   # good
#   puts sprintf('%10s', 'hoge')
# @example EnforcedStyle: percent
#   # bad
#   puts format('%10s', 'hoge')
#   puts sprintf('%10s', 'hoge')
#
#   # good
#   puts '%10s' % 'hoge'
#
# source://rubocop//lib/rubocop/cop/style/format_string.rb#38
class RuboCop::Cop::Style::FormatString < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#72
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#43
  def formatter(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#62
  def message(detected_style); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#68
  def method_name(style_name); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#51
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#92
  def autocorrect_from_percent(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#104
  def autocorrect_to_percent(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/format_string.rb#41
RuboCop::Cop::Style::FormatString::MSG = T.let(T.unsafe(nil), String)

# Use a consistent style for named format string tokens.
#
# **Note:**
# `unannotated` style cop only works for strings
# which are passed as arguments to those methods:
# `sprintf`, `format`, `%`.
# The reason is that *unannotated* format is very similar
# to encoded URLs or Date/Time formatting strings.
#
# @example EnforcedStyle: annotated (default)
#
#   # bad
#   format('%{greeting}', greeting: 'Hello')
#   format('%s', 'Hello')
#
#   # good
#   format('%<greeting>s', greeting: 'Hello')
# @example EnforcedStyle: template
#
#   # bad
#   format('%<greeting>s', greeting: 'Hello')
#   format('%s', 'Hello')
#
#   # good
#   format('%{greeting}', greeting: 'Hello')
# @example EnforcedStyle: unannotated
#
#   # bad
#   format('%<greeting>s', greeting: 'Hello')
#   format('%{greeting}', 'Hello')
#
#   # good
#   format('%s', 'Hello')
#
# source://rubocop//lib/rubocop/cop/style/format_string_token.rb#41
class RuboCop::Cop::Style::FormatStringToken < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#53
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#71
  def includes_format_methods?(node); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#123
  def match_token(source_range); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#81
  def message(detected_style); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#86
  def message_text(style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#161
  def placeholder_argument?(node); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#153
  def slice_source(source_range, new_begin, new_end); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#135
  def split_token(source_range, match_begin, match_end); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#101
  def str_contents(source_map); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#115
  def token_ranges(contents); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#95
  def tokens(str_node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#77
  def unannotated_format?(node, detected_style); end
end

# source://rubocop//lib/rubocop/cop/style/format_string_token.rb#44
RuboCop::Cop::Style::FormatStringToken::FIELD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/format_string_token.rb#45
RuboCop::Cop::Style::FormatStringToken::FORMAT_STRING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/format_string_token.rb#47
RuboCop::Cop::Style::FormatStringToken::STYLE_PATTERNS = T.let(T.unsafe(nil), Hash)

# This cop is designed to help upgrade to after Ruby 3.0. It will add the
# enable frozen string literals. Frozen string literals may be default
# after Ruby 3.0. The comment will be added below a shebang and encoding
# comment. The frozen string literal comment is only valid in Ruby 2.3+.
#
# @example EnforcedStyle: when_needed (default)
#   # The `when_needed` style will add the frozen string literal comment
#   # to files only when the `TargetRubyVersion` is set to 2.3+.
#   # bad
#   module Foo
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: true
#
#   module Foo
#   # ...
#   end
# @example EnforcedStyle: always
#   # The `always` style will always add the frozen string literal comment
#   # to a file, regardless of the Ruby version or if `freeze` or `<<` are
#   # called on a string literal.
#   # bad
#   module Bar
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: true
#
#   module Bar
#   # ...
#   end
# @example EnforcedStyle: never
#   # The `never` will enforce that the frozen string literal comment does
#   # not exist in a file.
#   # bad
#   # frozen_string_literal: true
#
#   module Baz
#   # ...
#   end
#
#   # good
#   module Baz
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#57
class RuboCop::Cop::Style::FrozenStringLiteralComment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#77
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#66
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#93
  def check_for_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#89
  def check_for_no_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#167
  def correction_range; end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#112
  def frozen_string_literal_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#139
  def insert_comment(corrector); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#97
  def last_special_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#118
  def offense(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#148
  def preceding_comment; end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#156
  def proceeding_comment; end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#134
  def remove_comment(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#125
  def unnecessary_comment_offense(processed_source); end
end

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#62
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#63
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#64
RuboCop::Cop::Style::FrozenStringLiteralComment::SHEBANG = T.let(T.unsafe(nil), String)

# This cop looks for uses of global variables.
# It does not report offenses for built-in global variables.
# Built-in global variables are allowed by default. Additionally
# users can allow additional variables via the AllowedVariables option.
#
# Note that backreferences like $1, $2, etc are not global variables.
#
# @example
#   # bad
#   $foo = 2
#   bar = $foo + 5
#
#   # good
#   FOO = 2
#   foo = 2
#   $stdin.read
#
# source://rubocop//lib/rubocop/cop/style/global_vars.rb#22
class RuboCop::Cop::Style::GlobalVars < ::RuboCop::Cop::Cop
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#60
  def allowed_var?(global_var); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#72
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#64
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#68
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#56
  def user_vars; end
end

# built-in global variables and their English aliases
# https://www.zenspider.com/ruby/quickref.html
#
# source://rubocop//lib/rubocop/cop/style/global_vars.rb#27
RuboCop::Cop::Style::GlobalVars::BUILT_IN_VARS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/global_vars.rb#23
RuboCop::Cop::Style::GlobalVars::MSG = T.let(T.unsafe(nil), String)

# Use a guard clause instead of wrapping the code inside a conditional
# expression
#
# @example
#   # bad
#   def test
#   if something
#   work
#   end
#   end
#
#   # good
#   def test
#   return unless something
#   work
#   end
#
#   # also good
#   def test
#   work if something
#   end
#
#   # bad
#   if something
#   raise 'exception'
#   else
#   ok
#   end
#
#   # good
#   raise 'exception' if something
#   ok
#
# source://rubocop//lib/rubocop/cop/style/guard_clause.rb#38
class RuboCop::Cop::Style::GuardClause < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::MinBodyLength

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#44
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#44
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#57
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#71
  def accepted_form?(node, ending = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#75
  def accepted_if?(node, ending); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#65
  def check_ending_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#85
  def contains_guard_clause?(node); end
end

# source://rubocop//lib/rubocop/cop/style/guard_clause.rb#41
RuboCop::Cop::Style::GuardClause::MSG = T.let(T.unsafe(nil), String)

# This cop checks hash literal syntax.
#
# It can enforce either the use of the class hash rocket syntax or
# the use of the newer Ruby 1.9 syntax (when applicable).
#
# A separate offense is registered for each problematic pair.
#
# The supported styles are:
#
# * ruby19 - forces use of the 1.9 syntax (e.g. `{a: 1}`) when hashes have
#   all symbols for keys
# * hash_rockets - forces use of hash rockets for all hashes
# * no_mixed_keys - simply checks for hashes with mixed syntaxes
# * ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed
#   syntax hashes
#
# @example EnforcedStyle: ruby19 (default)
#   # bad
#   {:a => 2}
#   {b: 1, :c => 2}
#
#   # good
#   {a: 2, b: 1}
#   {:c => 2, 'd' => 2} # acceptable since 'd' isn't a symbol
#   {d: 1, 'e' => 2} # technically not forbidden
# @example EnforcedStyle: hash_rockets
#   # bad
#   {a: 1, b: 2}
#   {c: 1, 'd' => 5}
#
#   # good
#   {:a => 1, :b => 2}
# @example EnforcedStyle: no_mixed_keys
#   # bad
#   {:a => 1, b: 2}
#   {c: 1, 'd' => 2}
#
#   # good
#   {:a => 1, :b => 2}
#   {c: 1, d: 2}
# @example EnforcedStyle: ruby19_no_mixed_keys
#   # bad
#   {:a => 1, :b => 2}
#   {c: 2, 'd' => 3} # should just use hash rockets
#
#   # good
#   {a: 1, b: 2}
#   {:c => 3, 'd' => 4}
#
# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#57
class RuboCop::Cop::Style::HashSyntax < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#119
  def alternative_style; end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#107
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#85
  def hash_rockets_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#99
  def no_mixed_keys_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#65
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#81
  def ruby19_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#89
  def ruby19_no_mixed_keys_check(pairs); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#140
  def acceptable_19_syntax_symbol?(sym_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#185
  def argument_without_space?(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#190
  def autocorrect_hash_rockets(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#199
  def autocorrect_no_mixed_keys(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#170
  def autocorrect_ruby19(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#157
  def check(pairs, delim, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#207
  def force_hash_rockets?(pairs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#130
  def sym_indices?(pairs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#134
  def word_symbol_pair?(pair); end
end

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#61
RuboCop::Cop::Style::HashSyntax::MSG_19 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#63
RuboCop::Cop::Style::HashSyntax::MSG_HASH_ROCKETS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#62
RuboCop::Cop::Style::HashSyntax::MSG_NO_MIXED_KEYS = T.let(T.unsafe(nil), String)

# This cop checks for identical lines at the beginning or end of
# each branch of a conditional statement.
#
# @example
#   # bad
#   if condition
#   do_x
#   do_z
#   else
#   do_y
#   do_z
#   end
#
#   # good
#   if condition
#   do_x
#   else
#   do_y
#   end
#   do_z
#
#   # bad
#   if condition
#   do_z
#   do_x
#   else
#   do_z
#   do_y
#   end
#
#   # good
#   do_z
#   if condition
#   do_x
#   else
#   do_y
#   end
#
#   # bad
#   case foo
#   when 1
#   do_x
#   when 2
#   do_x
#   else
#   do_x
#   end
#
#   # good
#   case foo
#   when 1
#   do_x
#   do_y
#   when 2
#   # nothing
#   else
#   do_x
#   do_z
#   end
#
# source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#65
class RuboCop::Cop::Style::IdenticalConditionalBranches < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#75
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#68
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#84
  def check_branches(branches); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#95
  def check_expressions(expressions); end

  # `elsif` branches show up in the if node as nested `else` branches. We
  # need to recursively iterate over all `else` branches.
  #
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#109
  def expand_elses(branch); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#124
  def head(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#103
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#120
  def tail(node); end
end

# source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#66
RuboCop::Cop::Style::IdenticalConditionalBranches::MSG = T.let(T.unsafe(nil), String)

# Corrector to correct conditional assignment in `if` statements.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#560
class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#565
    def correct(cop, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#569
    def move_assignment_inside_condition(node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#593
    def extract_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#586
    def extract_tail_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#600
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

# If the `else` branch of a conditional consists solely of an `if` node,
# it can be combined with the `else` to become an `elsif`.
# This helps to keep the nesting level from getting too deep.
#
# @example
#   # bad
#   if condition_a
#   action_a
#   else
#   if condition_b
#   action_b
#   else
#   action_c
#   end
#   end
#
#   # good
#   if condition_a
#   action_a
#   elsif condition_b
#   action_b
#   else
#   action_c
#   end
#
# source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#30
class RuboCop::Cop::Style::IfInsideElse < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#33
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#31
RuboCop::Cop::Style::IfInsideElse::MSG = T.let(T.unsafe(nil), String)

# Checks for if and unless statements that would fit on one line
# if written as a modifier if/unless. The maximum line length is
# configured in the `Metrics/LineLength` cop. The tab size is configured
# in the `IndentationWidth` of the `Layout/Tab` cop.
#
# @example
#   # bad
#   if condition
#   do_stuff(bar)
#   end
#
#   unless qux.empty?
#   Foo.do_something
#   end
#
#   # good
#   do_stuff(bar) if condition
#   Foo.do_something unless qux.empty?
#
# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#24
class RuboCop::Cop::Style::IfUnlessModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StatementModifier

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#34
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#54
  def eligible_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#82
  def first_line_comment(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#50
  def named_capture_in_condition?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#59
  def non_eligible_if?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#63
  def parenthesize?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#73
  def to_modifier_form(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#31
RuboCop::Cop::Style::IfUnlessModifier::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#27
RuboCop::Cop::Style::IfUnlessModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for if and unless statements used as modifiers of other if or
# unless statements.
#
# @example
#
#   # bad
#   tired? ? 'stop' : 'go faster' if running?
#
#   # bad
#   if tired?
#   "please stop"
#   else
#   "keep going"
#   end if running?
#
#   # good
#   if running?
#   tired? ? 'stop' : 'go faster'
#   end
#
# source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#25
class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StatementModifier

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#30
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#28
RuboCop::Cop::Style::IfUnlessModifierOfIfUnless::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of semicolon in if statements.
#
# @example
#
#   # bad
#   result = if some_condition; something else another_thing end
#
#   # good
#   result = some_condition ? something : another_thing
#
# source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#16
class RuboCop::Cop::Style::IfWithSemicolon < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::OnNormalIfUnless

  # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#21
  def on_normal_if_unless(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#19
RuboCop::Cop::Style::IfWithSemicolon::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `raise` or `fail` statements which do not specify an
# explicit exception class. (This raises a `RuntimeError`. Some projects
# might prefer to use exception classes which more precisely identify the
# nature of the error.)
#
# @example
#   # bad
#   raise 'Error message here'
#
#   # good
#   raise ArgumentError, 'Error message here'
#
# source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#17
class RuboCop::Cop::Style::ImplicitRuntimeError < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#21
  def implicit_runtime_error_raise_or_fail(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#24
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#18
RuboCop::Cop::Style::ImplicitRuntimeError::MSG = T.let(T.unsafe(nil), String)

# Use `Kernel#loop` for infinite loops.
#
# @example
#   # bad
#   while true
#   work
#   end
#
#   # good
#   loop do
#   work
#   end
#
# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#18
class RuboCop::Cop::Style::InfiniteLoop < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#27
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#43
  def autocorrect(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#23
  def join_force?(force_class); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#36
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#36
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#32
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#32
  def on_while_post(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#76
  def assigned_before_loop?(var, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#72
  def assigned_inside_loop?(var, range); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#121
  def configured_indent; end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#99
  def modifier_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#110
  def non_modifier_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#81
  def referenced_after_loop?(var, range); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#86
  def replace_begin_end_with_modifier(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#93
  def replace_source(range, replacement); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#55
  def while_or_until(node); end
end

# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#19
RuboCop::Cop::Style::InfiniteLoop::LEADING_SPACE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#21
RuboCop::Cop::Style::InfiniteLoop::MSG = T.let(T.unsafe(nil), String)

# This cop checks for trailing inline comments.
#
# @example
#
#   # good
#   foo.each do |f|
#   # Standalone comment
#   f.bar
#   end
#
#   # bad
#   foo.each do |f|
#   f.bar # Trailing inline comment
#   end
#
# source://rubocop//lib/rubocop/cop/style/inline_comment.rb#20
class RuboCop::Cop::Style::InlineComment < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/inline_comment.rb#23
  def investigate(processed_source); end
end

# source://rubocop//lib/rubocop/cop/style/inline_comment.rb#21
RuboCop::Cop::Style::InlineComment::MSG = T.let(T.unsafe(nil), String)

# This cop check for usages of not (`not` or `!`) called on a method
# when an inverse of that method can be used instead.
# Methods that can be inverted by a not (`not` or `!`) should be defined
# in `InverseMethods`
# Methods that are inverted by inverting the return
# of the block that is passed to the method should be defined in
# `InverseBlocks`
#
# @example
#   # bad
#   !foo.none?
#   !foo.any? { |f| f.even? }
#   !foo.blank?
#   !(foo == bar)
#   foo.select { |f| !f.even? }
#   foo.reject { |f| f != 7 }
#
#   # good
#   foo.none?
#   foo.blank?
#   foo.any? { |f| f.even? }
#   foo != bar
#   foo == bar
#   !!('foo' =~ /^\w+$/)
#   !(foo.class < Numeric) # Checking class hierarchy is allowed
#
# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#31
class RuboCop::Cop::Style::InverseMethods < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#85
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#103
  def correct_inverse_block(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#113
  def correct_inverse_selector(block, corrector); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#48
  def inverse_block?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#40
  def inverse_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#70
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#56
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#161
  def camel_case_constant?(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#146
  def end_parentheses(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#131
  def inverse_blocks; end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#126
  def inverse_methods; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#136
  def negated?(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#140
  def not_to_receiver(node, method_call); end

  # When comparing classes, `!(Integer < Numeric)` is not the same as
  # `Integer > Numeric`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#154
  def possible_class_hierarchy_check?(lhs, rhs, method); end
end

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#38
RuboCop::Cop::Style::InverseMethods::CAMEL_CASE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#35
RuboCop::Cop::Style::InverseMethods::CLASS_COMPARISON_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#36
RuboCop::Cop::Style::InverseMethods::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#34
RuboCop::Cop::Style::InverseMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#37
RuboCop::Cop::Style::InverseMethods::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for hardcoded IP addresses, which can make code
# brittle. IP addresses are likely to need to be changed when code
# is deployed to a different server or environment, which may break
# a deployment if forgotten. Prefer setting IP addresses in ENV or
# other configuration.
#
# @example
#
#   # bad
#   ip_address = '127.59.241.29'
#
#   # good
#   ip_address = ENV['DEPLOYMENT_IP_ADDRESS']
#
# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#21
class RuboCop::Cop::Style::IpAddresses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StringHelp

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#46
  def correct_style_detected; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#27
  def offense?(node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#42
  def opposite_style_detected; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#55
  def could_be_ip?(str); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#68
  def starts_with_hex_or_colon?(str); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#64
  def too_long?(str); end

  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#50
  def whitelist; end
end

# IPv4-mapped IPv6 is the longest
#
# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#24
RuboCop::Cop::Style::IpAddresses::IPV6_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#25
RuboCop::Cop::Style::IpAddresses::MSG = T.let(T.unsafe(nil), String)

# This cop (by default) checks for uses of the lambda literal syntax for
# single line lambdas, and the method call syntax for multiline lambdas.
# It is configurable to enforce one of the styles for both single line
# and multiline lambdas as well.
#
# @example EnforcedStyle: line_count_dependent (default)
#   # bad
#   f = lambda { |x| x }
#   f = ->(x) do
#   x
#   end
#
#   # good
#   f = ->(x) { x }
#   f = lambda do |x|
#   x
#   end
# @example EnforcedStyle: lambda
#   # bad
#   f = ->(x) { x }
#   f = ->(x) do
#   x
#   end
#
#   # good
#   f = lambda { |x| x }
#   f = lambda do |x|
#   x
#   end
# @example EnforcedStyle: literal
#   # bad
#   f = lambda { |x| x }
#   f = lambda do |x|
#   x
#   end
#
#   # good
#   f = ->(x) { x }
#   f = ->(x) do
#   x
#   end
#
# source://rubocop//lib/rubocop/cop/style/lambda.rb#49
class RuboCop::Cop::Style::Lambda < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#79
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#65
  def lambda_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#67
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#112
  def autocorrect_method_to_literal(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#123
  def lambda_arg_string(args); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#97
  def message(node, selector); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#103
  def message_line_modifier(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda.rb#91
  def offending_selector?(node, selector); end
end

# source://rubocop//lib/rubocop/cop/style/lambda.rb#52
RuboCop::Cop::Style::Lambda::LITERAL_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/lambda.rb#54
RuboCop::Cop::Style::Lambda::METHOD_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/lambda.rb#57
RuboCop::Cop::Style::Lambda::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

# This cop checks for use of the lambda.(args) syntax.
#
# @example EnforcedStyle: call (default)
#   # bad
#   lambda.(x, y)
#
#   # good
#   lambda.call(x, y)
# @example EnforcedStyle: braces
#   # bad
#   lambda.call(x, y)
#
#   # good
#   lambda.(x, y)
#
# source://rubocop//lib/rubocop/cop/style/lambda_call.rb#21
class RuboCop::Cop::Style::LambdaCall < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#24
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#55
  def add_parentheses(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#64
  def args_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#71
  def args_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#87
  def explicit_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#83
  def implicit_style?; end

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#75
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#50
  def offense?(node); end
end

# This cop checks for string literal concatenation at
# the end of a line.
#
# @example
#
#   # bad
#   some_str = 'ala' +
#   'bala'
#
#   some_str = 'ala' <<
#   'bala'
#
#   # good
#   some_str = 'ala' \
#   'bala'
#
# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#22
class RuboCop::Cop::Style::LineEndConcatenation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#44
  def autocorrect(operator_range); end

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#38
  def investigate(processed_source); end

  private

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#59
  def check_token_set(index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#83
  def eligible_next_successor?(next_successor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#79
  def eligible_operator?(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#88
  def eligible_predecessor?(predecessor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#75
  def eligible_successor?(successor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#108
  def standard_string_literal?(token); end

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#92
  def token_after_last_string(successor, base_index); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#34
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#29
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_EDGE_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#27
RuboCop::Cop::Style::LineEndConcatenation::CONCAT_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#30
RuboCop::Cop::Style::LineEndConcatenation::HIGH_PRECEDENCE_OP_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#25
RuboCop::Cop::Style::LineEndConcatenation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#32
RuboCop::Cop::Style::LineEndConcatenation::QUOTE_DELIMITERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#28
RuboCop::Cop::Style::LineEndConcatenation::SIMPLE_STRING_TOKEN_TYPE = T.let(T.unsafe(nil), Symbol)

# This cop enforces the presence (default) or absence of parentheses in
# method calls containing parameters.
#
# In the default style (require_parentheses), macro methods are ignored.
# Additional methods can be added to the `IgnoredMethods` list. This
# option is valid only in the default style. Macros can be included by
# either setting `IgnoreMacros` to false or adding specific macros to
# the `IncludedMacros` list. If a method is listed in both
# `IncludedMacros` and `IgnoredMethods`, then the latter takes
# precedence (that is, the method is ignored).
#
# In the alternative style (omit_parentheses), there are three additional
# options.
#
# 1. `AllowParenthesesInChaining` is `false` by default. Setting it to
#    `true` allows the presence of parentheses in the last call during
#    method chaining.
#
# 2. `AllowParenthesesInMultilineCall` is `false` by default. Setting it
#     to `true` allows the presence of parentheses in multi-line method
#     calls.
#
# 3. `AllowParenthesesInCamelCaseMethod` is `false` by default. This
#     allows the presence of parentheses when calling a method whose name
#     begins with a capital letter and which has no arguments. Setting it
#     to `true` allows the presence of parentheses in such a method call
#     even with arguments.
#
# @example EnforcedStyle: require_parentheses (default)
#
#   # bad
#   array.delete e
#
#   # good
#   array.delete(e)
#
#   # good
#   # Operators don't need parens
#   foo == bar
#
#   # good
#   # Setter methods don't need parens
#   foo.bar = baz
#
#   # okay with `puts` listed in `IgnoredMethods`
#   puts 'test'
#
#   # IgnoreMacros: true (default)
#
#   # good
#   class Foo
#   bar :baz
#   end
#
#   # IgnoreMacros: false
#
#   # bad
#   class Foo
#   bar :baz
#   end
# @example EnforcedStyle: omit_parentheses
#
#   # bad
#   array.delete(e)
#
#   # good
#   array.delete e
#
#   # bad
#   foo.enforce(strict: true)
#
#   # good
#   foo.enforce strict: true
#
#   # AllowParenthesesInMultilineCall: false (default)
#
#   # bad
#   foo.enforce(
#   strict: true
#   )
#
#   # good
#   foo.enforce \
#   strict: true
#
#   # AllowParenthesesInMultilineCall: true
#
#   # good
#   foo.enforce(
#   strict: true
#   )
#
#   # good
#   foo.enforce \
#   strict: true
#
#   # AllowParenthesesInChaining: false (default)
#
#   # bad
#   foo().bar(1)
#
#   # good
#   foo().bar 1
#
#   # AllowParenthesesInChaining: true
#
#   # good
#   foo().bar(1)
#
#   # good
#   foo().bar 1
#
#   # AllowParenthesesInCamelCaseMethod: false (default)
#
#   # bad
#   Array(1)
#
#   # good
#   Array 1
#
#   # AllowParenthesesInCamelCaseMethod: true
#
#   # good
#   Array(1)
#
#   # good
#   Array 1
#
# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#136
class RuboCop::Cop::Style::MethodCallWithArgsParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#154
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#163
  def message(_node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#142
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#142
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#142
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#142
  def on_yield(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#182
  def add_offense_for_omit_parentheses(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#174
  def add_offense_for_require_parentheses(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#258
  def allowed_camel_case_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#326
  def allowed_chained_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#322
  def allowed_multiline_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#336
  def ambigious_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#227
  def args_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#236
  def args_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#240
  def args_parenthesized?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#360
  def assigned_before?(node, target); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#202
  def autocorrect_for_omit_parentheses(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#192
  def autocorrect_for_require_parentheses(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#309
  def call_as_argument_or_chain?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#273
  def call_in_literals?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#282
  def call_in_logical_operators?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#289
  def call_in_optional_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#294
  def call_with_ambiguous_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#304
  def call_with_braced_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#213
  def eligible_for_parentheses_omission?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#352
  def hash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#315
  def hash_literal_in_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#221
  def ignored_macro?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#217
  def included_macros_list; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#264
  def legitimate_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#348
  def logical_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#247
  def parentheses_at_the_end_of_multiline_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#356
  def regexp_slash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#340
  def splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#254
  def super_call_without_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#344
  def ternary_if?(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#140
RuboCop::Cop::Style::MethodCallWithArgsParentheses::TRAILING_WHITESPACE_REGEX = T.let(T.unsafe(nil), Regexp)

# This cop checks for unwanted parentheses in parameterless method calls.
#
# @example
#   # bad
#   object.some_method()
#
#   # good
#   object.some_method
#
# source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#14
class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::IgnoredMethods

  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#29
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#20
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#52
  def any_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#38
  def ineligible_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#42
  def same_name_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#68
  def variable_in_mass_assignment?(variable_name, node); end
end

# source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#17
RuboCop::Cop::Style::MethodCallWithoutArgsParentheses::MSG = T.let(T.unsafe(nil), String)

# This cop checks for methods called on a do...end block. The point of
# this check is that it's easy to miss the call tacked on to the block
# when reading code.
#
# @example
#
#   a do
#   b
#   end.c
#
# source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#15
class RuboCop::Cop::Style::MethodCalledOnDoEndBlock < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#20
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#18
RuboCop::Cop::Style::MethodCalledOnDoEndBlock::MSG = T.let(T.unsafe(nil), String)

# This cop checks for parentheses around the arguments in method
# definitions. Both instance and class/singleton methods are checked.
#
# @example EnforcedStyle: require_parentheses (default)
#   # The `require_parentheses` style requires method definitions
#   # to always use parentheses
#
#   # bad
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
#
#   # good
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
# @example EnforcedStyle: require_no_parentheses
#   # The `require_no_parentheses` style requires method definitions
#   # to never use parentheses
#
#   # bad
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
#
#   # good
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
# @example EnforcedStyle: require_no_parentheses_except_multiline
#   # The `require_no_parentheses_except_multiline` style prefers no
#   # parentheses when method definition arguments fit on single line,
#   # but prefers parentheses when arguments span multiple lines.
#
#   # bad
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
#
#   # good
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#87
class RuboCop::Cop::Style::MethodDefParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#112
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#95
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#95
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#138
  def arguments_without_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#142
  def missing_parentheses(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#132
  def require_parentheses?(args); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#150
  def unwanted_parentheses(args); end
end

# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#92
RuboCop::Cop::Style::MethodDefParentheses::MSG_MISSING = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#91
RuboCop::Cop::Style::MethodDefParentheses::MSG_PRESENT = T.let(T.unsafe(nil), String)

# This cop checks for the presence of `method_missing` without
# falling back on `super`.
#
# @example
#   #bad
#   def method_missing(name, *args)
#   # ...
#   end
#
#   #good
#
#   def method_missing(name, *args)
#   # ...
#   super
#   end
#
# source://rubocop//lib/rubocop/cop/style/method_missing_super.rb#21
class RuboCop::Cop::Style::MethodMissingSuper < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/method_missing_super.rb#24
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/method_missing_super.rb#24
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_missing_super.rb#22
RuboCop::Cop::Style::MethodMissingSuper::MSG = T.let(T.unsafe(nil), String)

# This cop checks for potential uses of `Enumerable#minmax`.
#
# @example
#
#   # bad
#   bar = [foo.min, foo.max]
#   return foo.min, foo.max
#
#   # good
#   bar = foo.minmax
#   return foo.minmax
#
# source://rubocop//lib/rubocop/cop/style/min_max.rb#17
class RuboCop::Cop::Style::MinMax < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/min_max.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#41
  def min_max_candidate(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#20
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#20
  def on_return(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#59
  def argument_range(node); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#45
  def message(offender, receiver); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#50
  def offending_range(node); end
end

# source://rubocop//lib/rubocop/cop/style/min_max.rb#18
RuboCop::Cop::Style::MinMax::MSG = T.let(T.unsafe(nil), String)

# Checks for `if` expressions that do not have an `else` branch.
#
# Supported styles are: if, case, both.
#
# @example EnforcedStyle: if
#   # warn when an `if` expression is missing an `else` branch.
#
#   # bad
#   if condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
# @example EnforcedStyle: case
#   # warn when a `case` expression is missing an `else` branch.
#
#   # bad
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   if condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
# @example EnforcedStyle: both (default)
#   # warn when an `if` or `case` expression is missing an `else` branch.
#
#   # bad
#   if condition
#   statement
#   end
#
#   # bad
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
# source://rubocop//lib/rubocop/cop/style/missing_else.rb#96
class RuboCop::Cop::Style::MissingElse < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#113
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#106
  def on_normal_if_unless(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#152
  def case_style?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#121
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#174
  def empty_else_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#164
  def empty_else_cop_enabled?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#168
  def empty_else_style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#148
  def if_style?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#135
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#160
  def unless_else_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#156
  def unless_else_cop_enabled?; end
end

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#100
RuboCop::Cop::Style::MissingElse::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#103
RuboCop::Cop::Style::MissingElse::MSG_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#101
RuboCop::Cop::Style::MissingElse::MSG_NIL = T.let(T.unsafe(nil), String)

# This cop checks for the presence of `method_missing` without also
# defining `respond_to_missing?`.
#
# @example
#   #bad
#   def method_missing(name, *args)
#   # ...
#   end
#
#   #good
#   def respond_to_missing?(name, include_private)
#   # ...
#   end
#
#   def method_missing(name, *args)
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#24
class RuboCop::Cop::Style::MissingRespondToMissing < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#28
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#28
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#38
  def implements_respond_to_missing?(node); end
end

# source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#25
RuboCop::Cop::Style::MissingRespondToMissing::MSG = T.let(T.unsafe(nil), String)

# This cop checks for grouping of mixins in `class` and `module` bodies.
# By default it enforces mixins to be placed in separate declarations,
# but it can be configured to enforce grouping them in one declaration.
#
# @example EnforcedStyle: separated (default)
#   # bad
#   class Foo
#   include Bar, Qox
#   end
#
#   # good
#   class Foo
#   include Qox
#   include Bar
#   end
# @example EnforcedStyle: grouped
#   # bad
#   class Foo
#   extend Bar
#   extend Qox
#   end
#
#   # good
#   class Foo
#   extend Qox, Bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#33
class RuboCop::Cop::Style::MixinGrouping < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#50
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#39
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#39
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#81
  def check(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#89
  def check_grouped_style(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#95
  def check_separated_style(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#135
  def group_mixins(node, mixins); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#117
  def grouped_style?; end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#144
  def indent(node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#110
  def message(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#69
  def range_to_remove_for_subsequent_mixin(mixins, node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#125
  def separate_mixins(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#121
  def separated_style?; end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#101
  def sibling_mixins(send_node); end
end

# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#36
RuboCop::Cop::Style::MixinGrouping::MIXIN_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#37
RuboCop::Cop::Style::MixinGrouping::MSG = T.let(T.unsafe(nil), String)

# This cop checks that `include`, `extend` and `prepend` statements appear
# inside classes and modules, not at the top level, so as to not affect
# the behavior of `Object`.
#
# @example
#   # bad
#   include M
#
#   class C
#   end
#
#   # bad
#   extend M
#
#   class C
#   end
#
#   # bad
#   prepend M
#
#   class C
#   end
#
#   # good
#   class C
#   include M
#   end
#
#   # good
#   class C
#   extend M
#   end
#
#   # good
#   class C
#   prepend M
#   end
#
# source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#43
class RuboCop::Cop::Style::MixinUsage < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#47
  def include_statement(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#52
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#64
  def accepted_include?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#68
  def belongs_to_class_or_module?(node); end
end

# source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#44
RuboCop::Cop::Style::MixinUsage::MSG = T.let(T.unsafe(nil), String)

# This cop checks for use of `extend self` or `module_function` in a
# module.
#
# Supported styles are: module_function, extend_self.
#
# In case there are private methods, the cop won't be activated.
# Otherwise, it forces to change the flow of the default code.
#
# These offenses are not safe to auto-correct since there are different
# implications to each approach.
#
# @example EnforcedStyle: module_function (default)
#   # bad
#   module Test
#   extend self
#   # ...
#   end
#
#   # good
#   module Test
#   module_function
#   # ...
#   end
# @example EnforcedStyle: module_function (default)
#   # good
#   module Test
#   extend self
#   # ...
#   private
#   # ...
#   end
# @example EnforcedStyle: extend_self
#   # bad
#   module Test
#   module_function
#   # ...
#   end
#
#   # good
#   module Test
#   extend self
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/module_function.rb#51
class RuboCop::Cop::Style::ModuleFunction < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#72
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#60
  def extend_self_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#59
  def module_function_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#63
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#61
  def private_directive?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#84
  def each_wrong_style(nodes); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#99
  def message(_node); end
end

# source://rubocop//lib/rubocop/cop/style/module_function.rb#56
RuboCop::Cop::Style::ModuleFunction::EXTEND_SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/module_function.rb#54
RuboCop::Cop::Style::ModuleFunction::MODULE_FUNCTION_MSG = T.let(T.unsafe(nil), String)

# This cop checks for chaining of a block after another block that spans
# multiple lines.
#
# @example
#
#   Thread.list.find_all do |t|
#   t.alive?
#   end.map do |t|
#   t.object_id
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#16
class RuboCop::Cop::Style::MultilineBlockChain < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#21
  def on_block(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#19
RuboCop::Cop::Style::MultilineBlockChain::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of if/unless modifiers with multiple-lines bodies.
#
# @example
#
#   # bad
#   {
#   result: 'this should not happen'
#   } unless cond
#
#   # good
#   { result: 'ok' } if cond
#
# source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#17
class RuboCop::Cop::Style::MultilineIfModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#24
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#50
  def configured_indentation_width; end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#54
  def indented_body(body, node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#38
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#42
  def to_normal_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#21
RuboCop::Cop::Style::MultilineIfModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of the `then` keyword in multi-line if statements.
#
# @example
#   # bad
#   # This is considered bad practice.
#   if cond then
#   end
#
#   # good
#   # If statements can contain `then` on the same line.
#   if cond then a
#   elsif cond then b
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#19
class RuboCop::Cop::Style::MultilineIfThen < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#27
  def on_normal_if_unless(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#44
  def non_modifier_then?(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#25
RuboCop::Cop::Style::MultilineIfThen::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#23
RuboCop::Cop::Style::MultilineIfThen::NON_MODIFIER_THEN = T.let(T.unsafe(nil), Regexp)

# This cop checks expressions wrapping styles for multiline memoization.
#
# @example EnforcedStyle: keyword (default)
#   # bad
#   foo ||= (
#   bar
#   baz
#   )
#
#   # good
#   foo ||= begin
#   bar
#   baz
#   end
# @example EnforcedStyle: braces
#   # bad
#   foo ||= begin
#   bar
#   baz
#   end
#
#   # good
#   foo ||= (
#   bar
#   baz
#   )
#
# source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#33
class RuboCop::Cop::Style::MultilineMemoization < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#38
  def on_or_asgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#59
  def bad_rhs?(rhs); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#69
  def keyword_autocorrect(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#75
  def keyword_begin_str(node, node_buf); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#84
  def keyword_end_str(node, node_buf); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#36
RuboCop::Cop::Style::MultilineMemoization::MSG = T.let(T.unsafe(nil), String)

# This cop checks for method signatures that span multiple lines.
#
# @example
#
#   # good
#
#   def foo(bar, baz)
#   end
#
#   # bad
#
#   def foo(bar,
#   baz)
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#21
class RuboCop::Cop::Style::MultilineMethodSignature < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#24
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#24
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#39
  def closing_line(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#43
  def correction_exceeds_max_line_length?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#51
  def definition_width(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#47
  def indentation_width(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#55
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#35
  def opening_line(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#22
RuboCop::Cop::Style::MultilineMethodSignature::MSG = T.let(T.unsafe(nil), String)

# This cop checks for multi-line ternary op expressions.
#
# @example
#   # bad
#   a = cond ?
#   b : c
#   a = cond ? b :
#   c
#   a = cond ?
#   b :
#   c
#
#   # good
#   a = cond ? b : c
#   a =
#   if cond
#   b
#   else
#   c
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#26
class RuboCop::Cop::Style::MultilineTernaryOperator < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#30
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#27
RuboCop::Cop::Style::MultilineTernaryOperator::MSG = T.let(T.unsafe(nil), String)

# This cop checks against comparing a variable with multiple items, where
# `Array#include?` could be used instead to avoid code repetition.
#
# @example
#   # bad
#   a = 'a'
#   foo if a == 'a' || a == 'b' || a == 'c'
#
#   # good
#   a = 'a'
#   foo if ['a', 'b', 'c'].include?(a)
#
# source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#17
class RuboCop::Cop::Style::MultipleComparison < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#21
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#33
  def simple_comparison?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#32
  def simple_double_comparison?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#76
  def comparison?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#68
  def nested_comparison?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#38
  def nested_variable_comparison?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#80
  def root_of_or_node(or_node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#64
  def variable_name(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#44
  def variables_in_node(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#54
  def variables_in_simple_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#18
RuboCop::Cop::Style::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether some constant value isn't a
# mutable literal (e.g. array or hash).
#
# Strict mode can be used to freeze all constants, rather than
# just literals.
# Strict mode is considered an experimental feature. It has not been
# updated with an exhaustive list of all methods that will produce
# frozen objects so there is a decent chance of getting some false
# positives. Luckily, there is no harm in freezing an already
# frozen object.
#
# @example EnforcedStyle: literals (default)
#   # bad
#   CONST = [1, 2, 3]
#
#   # good
#   CONST = [1, 2, 3].freeze
#
#   # good
#   CONST = <<~TESTING.freeze
#   This is a heredoc
#   TESTING
#
#   # good
#   CONST = Something.new
# @example EnforcedStyle: strict
#   # bad
#   CONST = Something.new
#
#   # bad
#   CONST = Struct.new do
#   def foo
#   puts 1
#   end
#   end
#
#   # good
#   CONST = Something.new.freeze
#
#   # good
#   CONST = Struct.new do
#   def foo
#   puts 1
#   end
#   end.freeze
#
# source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#53
class RuboCop::Cop::Style::MutableConstant < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#72
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#59
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#64
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#152
  def operation_produces_immutable_object?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#168
  def range_enclosed_in_parentheses?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#146
  def splat_value(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#109
  def check(value); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#138
  def correct_splat_expansion(corrector, expr, splat_value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#128
  def frozen_string_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#124
  def immutable_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#120
  def mutable_literal?(value); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#93
  def on_assignment(value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#133
  def requires_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#101
  def strict_check(value); end
end

# source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#57
RuboCop::Cop::Style::MutableConstant::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of if with a negated condition. Only ifs
# without else are considered. There are three different styles:
#
#   - both
#   - prefix
#   - postfix
#
# @example EnforcedStyle: both (default)
#   # enforces `unless` for `prefix` and `postfix` conditionals
#
#   # bad
#
#   if !foo
#   bar
#   end
#
#   # good
#
#   unless foo
#   bar
#   end
#
#   # bad
#
#   bar if !foo
#
#   # good
#
#   bar unless foo
# @example EnforcedStyle: prefix
#   # enforces `unless` for just `prefix` conditionals
#
#   # bad
#
#   if !foo
#   bar
#   end
#
#   # good
#
#   unless foo
#   bar
#   end
#
#   # good
#
#   bar if !foo
# @example EnforcedStyle: postfix
#   # enforces `unless` for just `postfix` conditionals
#
#   # bad
#
#   bar if !foo
#
#   # good
#
#   bar unless foo
#
#   # good
#
#   if !foo
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/negated_if.rb#71
class RuboCop::Cop::Style::NegatedIf < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional

  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#82
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#75
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#92
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#88
  def message(node); end
end

# Checks for uses of while with a negated condition.
#
# @example
#   # bad
#   while !foo
#   bar
#   end
#
#   # good
#   until foo
#   bar
#   end
#
#   # bad
#   bar until !foo
#
#   # good
#   bar while foo
#   bar while !foo && baz
#
# source://rubocop//lib/rubocop/cop/style/negated_while.rb#25
class RuboCop::Cop::Style::NegatedWhile < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::NegativeConditional

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#32
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#28
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#42
  def message(node); end
end

# This cop checks for nested use of if, unless, while and until in their
# modifier form.
#
# @example
#
#   # bad
#   something if a if b
#
#   # good
#   something if b && a
#
# source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#16
class RuboCop::Cop::Style::NestedModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#45
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#33
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#68
  def left_hand_operand(node, operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#41
  def modifier?(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#56
  def new_expression(outer_node, inner_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#29
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#25
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#21
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#64
  def replacement_operator(keyword); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#82
  def requires_parens?(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#75
  def right_hand_operand(node, left_hand_keyword); end
end

# source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#19
RuboCop::Cop::Style::NestedModifier::MSG = T.let(T.unsafe(nil), String)

# This cop checks for unparenthesized method calls in the argument list
# of a parenthesized method call.
#
# @example
#   # good
#   method1(method2(arg), method3(arg))
#
#   # bad
#   method1(method2 arg, method3, arg)
#
# source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#15
class RuboCop::Cop::Style::NestedParenthesizedCalls < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#33
  def autocorrect(nested); end

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#20
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#20
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#49
  def allowed_omission?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#55
  def whitelisted?(send_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#61
  def whitelisted_methods; end
end

# source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#18
RuboCop::Cop::Style::NestedParenthesizedCalls::MSG = T.let(T.unsafe(nil), String)

# This cop checks for nested ternary op expressions.
#
# @example
#   # bad
#   a ? (b ? b1 : b2) : a2
#
#   # good
#   if a
#   b ? b1 : b2
#   else
#   a2
#   end
#
# source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#18
class RuboCop::Cop::Style::NestedTernaryOperator < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#22
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#19
RuboCop::Cop::Style::NestedTernaryOperator::MSG = T.let(T.unsafe(nil), String)

# Use `next` to skip iteration instead of a condition at the end.
#
# @example EnforcedStyle: skip_modifier_ifs (default)
#   # bad
#   [1, 2].each do |a|
#   if a == 1
#   puts a
#   end
#   end
#
#   # good
#   [1, 2].each do |a|
#   next unless a == 1
#   puts a
#   end
#
#   # good
#   [1, 2].each do |o|
#   puts o unless o == 1
#   end
# @example EnforcedStyle: always
#   # With `always` all conditions at the end of an iteration needs to be
#   # replaced by next - with `skip_modifier_ifs` the modifier if like
#   # this one are ignored: `[1, 2].each { |a| return 'yes' if a == 1 }`
#
#   # bad
#   [1, 2].each do |o|
#   puts o unless o == 1
#   end
#
#   # bad
#   [1, 2].each do |a|
#   if a == 1
#   puts a
#   end
#   end
#
#   # good
#   [1, 2].each do |a|
#   next unless a == 1
#   puts a
#   end
#
# source://rubocop//lib/rubocop/cop/style/next.rb#49
class RuboCop::Cop::Style::Next < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/next.rb#76
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#57
  def investigate(_processed_source); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#63
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#70
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#70
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#70
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/next.rb#219
  def actual_indent(lines, buffer); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#111
  def allowed_modifier_if?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#154
  def autocorrect_block(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#144
  def autocorrect_modifier(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#88
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#173
  def cond_range(node, cond); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#193
  def end_followed_by_whitespace_only?(source_buffer, end_pos); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#183
  def end_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#97
  def ends_with_condition?(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#127
  def exit_body_type?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#223
  def heredoc_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#119
  def if_else_children?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#123
  def if_without_else?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#138
  def offense_location(offense_node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#133
  def offense_node(body); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#169
  def opposite_kw(if_body); end

  # Adjust indentation of `lines` to match `node`
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#208
  def reindent(lines, node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#230
  def reindent_line(corrector, lineno, delta, buffer); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#197
  def reindentable_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#103
  def simple_if_without_break?(node); end
end

# source://rubocop//lib/rubocop/cop/style/next.rb#55
RuboCop::Cop::Style::Next::EXIT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/next.rb#54
RuboCop::Cop::Style::Next::MSG = T.let(T.unsafe(nil), String)

# This cop checks for comparison of something with nil using `==` and
# `nil?`.
#
# Supported styles are: predicate, comparison.
#
# @example EnforcedStyle: predicate (default)
#
#   # bad
#   if x == nil
#   end
#
#   # good
#   if x.nil?
#   end
# @example EnforcedStyle: comparison
#
#   # bad
#   if x.nil?
#   end
#
#   # good
#   if x == nil
#   end
#
# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#31
class RuboCop::Cop::Style::NilComparison < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#38
  def nil_check?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#37
  def nil_comparison?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#40
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#57
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#69
  def prefer_comparison?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#61
  def style_check?(node, &block); end
end

# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#35
RuboCop::Cop::Style::NilComparison::EXPLICIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#34
RuboCop::Cop::Style::NilComparison::PREDICATE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for non-nil checks, which are usually redundant.
#
# Non-nil checks are allowed if they are the final nodes of predicate.
#
#   # good
#   def signed_in?
#     !current_user.nil?
#   end
#
# @example
#
#   # bad
#   if x != nil
#   end
#
#   # good (when not allowing semantic changes)
#   # bad (when allowing semantic changes)
#   if !x.nil?
#   end
#
#   # good (when allowing semantic changes)
#   if x
#   end
#
# source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#29
class RuboCop::Cop::Style::NonNilCheck < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#59
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#32
  def nil_check?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#33
  def not_and_nil_check?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#30
  def not_equal_to_nil?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#46
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#46
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#35
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#31
  def unless_check?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#91
  def autocorrect_comparison(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#105
  def autocorrect_non_nil(node, inner_node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#115
  def autocorrect_unless_nil(node, receiver); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#87
  def include_semantic_changes?; end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#79
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#72
  def unless_and_nil_check?(send_node); end
end

# This cop checks for uses of the keyword `not` instead of `!`.
#
# @example
#
#   # bad - parentheses are required because of op precedence
#   x = (not something)
#
#   # good
#   x = !something
#
# source://rubocop//lib/rubocop/cop/style/not.rb#16
class RuboCop::Cop::Style::Not < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/not.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/not.rb#30
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/not.rb#61
  def correct_opposite_method(range, child); end

  # source://rubocop//lib/rubocop/cop/style/not.rb#69
  def correct_with_parens(range, node); end

  # source://rubocop//lib/rubocop/cop/style/not.rb#76
  def correct_without_parens(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/not.rb#51
  def opposite_method?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/not.rb#55
  def requires_parens?(child); end
end

# source://rubocop//lib/rubocop/cop/style/not.rb#19
RuboCop::Cop::Style::Not::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/not.rb#21
RuboCop::Cop::Style::Not::OPPOSITE_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks for octal, hex, binary, and decimal literals using
# uppercase prefixes and corrects them to lowercase prefix
# or no prefix (in case of decimals).
#
# @example EnforcedOctalStyle: zero_with_o (default)
#   # bad - missing octal prefix
#   num = 01234
#
#   # bad - uppercase prefix
#   num = 0O1234
#   num = 0X12AB
#   num = 0B10101
#
#   # bad - redundant decimal prefix
#   num = 0D1234
#   num = 0d1234
#
#   # good
#   num = 0o1234
#   num = 0x12AB
#   num = 0b10101
#   num = 1234
# @example EnforcedOctalStyle: zero_only
#   # bad
#   num = 0o1234
#   num = 0O1234
#
#   # good
#   num = 01234
#
# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#36
class RuboCop::Cop::Style::NumericLiteralPrefix < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::IntegerNode

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#59
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#51
  def on_int(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#114
  def format_binary(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#118
  def format_decimal(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#110
  def format_hex(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#102
  def format_octal(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#106
  def format_octal_zero_only(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#87
  def hex_bin_dec_literal_type(literal); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#73
  def literal_type(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#69
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#79
  def octal_literal_type(literal); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#98
  def octal_zero_only?; end
end

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#48
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#42
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#49
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#43
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#47
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#41
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#46
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#40
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#45
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#39
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_REGEX = T.let(T.unsafe(nil), Regexp)

# This cop checks for big numeric literals without _ between groups
# of digits in them.
#
# @example
#
#   # bad
#
#   1000000
#   1_00_000
#   1_0000
#
#   # good
#
#   1_000_000
#   1000
#
#   # good unless Strict is set
#
#   10_000_00 # typical representation of $10,000 in cents
#
# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#26
class RuboCop::Cop::Style::NumericLiterals < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#45
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#41
  def on_float(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#37
  def on_int(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#57
  def check(node); end

  # @param int_part [String]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#92
  def format_int_part(int_part); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#78
  def format_number(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#53
  def max_parameter_name; end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#104
  def min_digits; end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#74
  def short_group_regex; end
end

# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#35
RuboCop::Cop::Style::NumericLiterals::DELIMITER_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#33
RuboCop::Cop::Style::NumericLiterals::MSG = T.let(T.unsafe(nil), String)

# This cop checks for usage of comparison operators (`==`,
# `>`, `<`) to test numbers as zero, positive, or negative.
# These can be replaced by their respective predicate methods.
# The cop can also be configured to do the reverse.
#
# The cop disregards `#nonzero?` as it its value is truthy or falsey,
# but not `true` and `false`, and thus not always interchangeable with
# `!= 0`.
#
# The cop ignores comparisons to global variables, since they are often
# populated with objects which can be compared with integers, but are
# not themselves `Integer` polymorphic.
#
# @example EnforcedStyle: predicate (default)
#   # bad
#
#   foo == 0
#   0 > foo
#   bar.baz > 0
#
#   # good
#
#   foo.zero?
#   foo.negative?
#   bar.baz.positive?
# @example EnforcedStyle: comparison
#   # bad
#
#   foo.zero?
#   foo.negative?
#   bar.baz.positive?
#
#   # good
#
#   foo == 0
#   0 > foo
#   bar.baz > 0
#
# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#44
class RuboCop::Cop::Style::NumericPredicate < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#71
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#135
  def comparison(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#139
  def inverted_comparison(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#56
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#131
  def predicate(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#81
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#123
  def invert; end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#103
  def parenthesized_source(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#94
  def replacement(numeric, operation); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#115
  def replacement_supported?(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#111
  def require_parentheses?(node); end
end

# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#48
RuboCop::Cop::Style::NumericPredicate::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#50
RuboCop::Cop::Style::NumericPredicate::REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# TODO: Make configurable.
# Checks for uses of if/then/else/end on a single line.
#
# @example
#   # bad
#   if foo then boo else doo end
#   unless foo then boo else goo end
#
#   # good
#   foo ? boo : doo
#   boo if foo
#   if foo then boo end
#
#   # good
#   if foo
#   boo
#   else
#   doo
#   end
#
# source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#25
class RuboCop::Cop::Style::OneLineConditional < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::OnNormalIfUnless

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#37
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#31
  def on_normal_if_unless(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#69
  def expr_replacement(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#90
  def keyword_with_changed_precedence?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#45
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#83
  def method_call_with_changed_precedence?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#49
  def replacement(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#75
  def requires_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#63
  def to_ternary(node); end
end

# source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#28
RuboCop::Cop::Style::OneLineConditional::MSG = T.let(T.unsafe(nil), String)

# This cop checks for options hashes and discourages them if the
# current Ruby version supports keyword arguments.
#
# @example
#
#   # bad
#   def fry(options = {})
#   temperature = options.fetch(:temperature, 300)
#   # ...
#   end
#
#   # good
#   def fry(temperature: 300)
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/option_hash.rb#22
class RuboCop::Cop::Style::OptionHash < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#29
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#25
  def option_hash(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#49
  def super_used?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#44
  def suspicious_name?(arg_name); end

  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#40
  def whitelist; end
end

# source://rubocop//lib/rubocop/cop/style/option_hash.rb#23
RuboCop::Cop::Style::OptionHash::MSG = T.let(T.unsafe(nil), String)

# This cop checks for optional arguments to methods
# that do not come at the end of the argument list
#
# @example
#   # bad
#   def foo(a = 1, b, c)
#   end
#
#   # good
#   def baz(a, b, c = 1)
#   end
#
#   def foobar(a = 1, b = 2, c = 3)
#   end
#
# source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#20
class RuboCop::Cop::Style::OptionalArguments < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#24
  def on_def(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#47
  def argument_positions(arguments); end

  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#35
  def each_misplaced_optional_arg(arguments); end
end

# source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#21
RuboCop::Cop::Style::OptionalArguments::MSG = T.let(T.unsafe(nil), String)

# This cop checks for potential usage of the `||=` operator.
#
# @example
#   # bad
#   name = name ? name : 'Bozhidar'
#
#   # bad
#   name = if name
#   name
#   else
#   'Bozhidar'
#   end
#
#   # bad
#   unless name
#   name = 'Bozhidar'
#   end
#
#   # bad
#   name = 'Bozhidar' unless name
#
#   # good - set name to 'Bozhidar', only if it's nil or false
#   name ||= 'Bozhidar'
#
# source://rubocop//lib/rubocop/cop/style/or_assignment.rb#29
class RuboCop::Cop::Style::OrAssignment < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#63
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#53
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#53
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#47
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#53
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#53
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#32
  def ternary_assignment?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#40
  def unless_assignment?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#78
  def take_variable_and_default_from_ternary(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#83
  def take_variable_and_default_from_unless(node); end
end

# source://rubocop//lib/rubocop/cop/style/or_assignment.rb#30
RuboCop::Cop::Style::OrAssignment::MSG = T.let(T.unsafe(nil), String)

# Checks for simple usages of parallel assignment.
# This will only complain when the number of variables
# being assigned matched the number of assigning variables.
#
# @example
#   # bad
#   a, b, c = 1, 2, 3
#   a, b, c = [1, 2, 3]
#
#   # good
#   one, two = *foo
#   a, b = foo()
#   a, b = b, a
#
#   a = 1
#   b = 2
#   c = 3
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#25
class RuboCop::Cop::Style::ParallelAssignment < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RescueNode

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#118
  def implicit_self_getter?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#30
  def on_masgn(node); end

  private

  # Converts (send nil :something) nodes to (send (:self) :something).
  # This makes the sorting algorithm work for expressions such as
  # `self.a, self.b = b, a`.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#112
  def add_self_to_getters(right_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#62
  def allowed_lhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#56
  def allowed_masign?(lhs_elements, rhs_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#70
  def allowed_rhs?(node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#84
  def assignment_corrector(node, order); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#95
  def find_valid_order(left_elements, right_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#171
  def modifier_statement?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#80
  def return_of_method_call?(node); end
end

# Helper class necessitated by silly design of TSort prior to Ruby 2.1
# Newer versions have a better API, but that doesn't help us
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#122
class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  extend ::RuboCop::NodePattern::Macros

  # @return [AssignmentSorter] a new instance of AssignmentSorter
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#130
  def initialize(assignments); end

  # `lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`.
  # Does `rhs` access the same value which is assigned by `lhs`?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#159
  def accesses?(rhs, lhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#152
  def dependency?(lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#128
  def matching_calls(node0, param1, param2); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#138
  def tsort_each_child(assignment); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#134
  def tsort_each_node; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#127
  def uses_var?(node0, param1); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#126
  def var_name(node = T.unsafe(nil)); end
end

# An internal class for correcting parallel assignment
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#176
class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment

  # @return [GenericCorrector] a new instance of GenericCorrector
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#181
  def initialize(node, config, new_elements); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#179
  def config; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#187
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#191
  def correction_range; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#179
  def node; end

  protected

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#197
  def assignment; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#217
  def cop_config; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#213
  def extract_sources(node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#203
  def source(node); end
end

# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#28
RuboCop::Cop::Style::ParallelAssignment::MSG = T.let(T.unsafe(nil), String)

# An internal class for correcting parallel assignment
# guarded by if, unless, while, or until
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#262
class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#263
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#272
  def correction_range; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#278
  def modifier_range(node); end
end

# An internal class for correcting parallel assignment
# protected by rescue
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#224
class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#225
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#239
  def correction_range; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#250
  def begin_correction(rescue_result); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#245
  def def_correction(rescue_result); end
end

# This cop checks for the presence of superfluous parentheses around the
# condition of if/unless/while/until.
#
# @example
#   # bad
#   x += 1 while (x < 10)
#   foo unless (bar || baz)
#
#   if (x > 10)
#   elsif (x < 3)
#   end
#
#   # good
#   x += 1 while x < 10
#   foo unless bar || baz
#
#   if x > 10
#   elsif x < 3
#   end
# @example AllowInMultilineConditions: false (default)
#   # bad
#   if (x > 10 &&
#   y > 10)
#   end
#
#   # good
#   if x > 10 &&
#   y > 10
#   end
# @example AllowInMultilineConditions: true
#   # good
#   if (x > 10 &&
#   y > 10)
#   end
#
# source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#42
class RuboCop::Cop::Style::ParenthesesAroundCondition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#57
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#63
  def control_op_condition(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#46
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#52
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#52
  def on_while(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#97
  def allow_multiline_conditions?; end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#85
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#78
  def modifier_op?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#91
  def parens_allowed?(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#67
  def process_control_op(node); end
end

# This cop enforces the consistent usage of `%`-literal delimiters.
#
# Specify the 'default' key to set all preferred delimiters at once. You
# can continue to specify individual preferred delimiters to override the
# default.
#
# @example
#   # Style/PercentLiteralDelimiters:
#   #   PreferredDelimiters:
#   #     default: '[]'
#   #     '%i':    '()'
#
#   # good
#   %w[alpha beta] + %i(gamma delta)
#
#   # bad
#   %W(alpha #{beta})
#
#   # bad
#   %I(alpha beta)
#
# source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#26
class RuboCop::Cop::Style::PercentLiteralDelimiters < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#58
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#50
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#29
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#37
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#33
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#37
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#42
  def on_sym(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#46
  def on_xstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#90
  def contains_preferred_delimiter?(node, type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#97
  def include_same_character_as_used_for_delimiter?(node, type); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#116
  def matchpairs(begin_delimiter); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#71
  def on_percent_literal(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#80
  def preferred_delimiters_for(type); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#108
  def string_source(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#86
  def uses_preferred_delimiter?(node, type); end
end

# This cop checks for usage of the %Q() syntax when %q() would do.
#
# @example EnforcedStyle: lower_case_q (default)
#   # The `lower_case_q` style prefers `%q` unless
#   # interpolation is needed.
#   # bad
#   %Q[Mix the foo into the baz.]
#   %Q(They all said: 'Hooray!')
#
#   # good
#   %q[Mix the foo into the baz]
#   %q(They all said: 'Hooray!')
# @example EnforcedStyle: upper_case_q
#   # The `upper_case_q` style requires the sole use of `%Q`.
#   # bad
#   %q/Mix the foo into the baz./
#   %q{They all said: 'Hooray!'}
#
#   # good
#   %Q/Mix the foo into the baz./
#   %Q{They all said: 'Hooray!'}
#
# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#28
class RuboCop::Cop::Style::PercentQLiterals < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#36
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#58
  def correct_literal_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#67
  def corrected(src); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#63
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#48
  def on_percent_literal(node); end
end

# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#32
RuboCop::Cop::Style::PercentQLiterals::LOWER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#34
RuboCop::Cop::Style::PercentQLiterals::UPPER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

# This cop looks for uses of Perl-style regexp match
# backreferences like $1, $2, etc.
#
# @example
#   # bad
#   puts $1
#
#   # good
#   puts Regexp.last_match(1)
#
# source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#15
class RuboCop::Cop::Style::PerlBackrefs < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#22
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#18
  def on_nth_ref(node); end
end

# source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#16
RuboCop::Cop::Style::PerlBackrefs::MSG = T.let(T.unsafe(nil), String)

# This cop (by default) checks for uses of methods Hash#has_key? and
# Hash#has_value? where it enforces Hash#key? and Hash#value?
# It is configurable to enforce the inverse, using `verbose` method
# names also.
#
# @example EnforcedStyle: short (default)
#   # bad
#   Hash#has_key?
#   Hash#has_value?
#
#   # good
#   Hash#key?
#   Hash#value?
# @example EnforcedStyle: verbose
#   # bad
#   Hash#key?
#   Hash#value?
#
#   # good
#   Hash#has_key?
#   Hash#has_value?
#
# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#28
class RuboCop::Cop::Style::PreferredHashMethods < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#38
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#38
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#55
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#69
  def offending_selector?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#61
  def proper_method_name(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#31
RuboCop::Cop::Style::PreferredHashMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#33
RuboCop::Cop::Style::PreferredHashMethods::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

# This cop checks for uses of Proc.new where Kernel#proc
# would be more appropriate.
#
# @example
#   # bad
#   p = Proc.new { |n| puts n }
#
#   # good
#   p = proc { |n| puts n }
#
# source://rubocop//lib/rubocop/cop/style/proc.rb#16
class RuboCop::Cop::Style::Proc < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/proc.rb#28
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/proc.rb#22
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/proc.rb#19
  def proc_new?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/proc.rb#17
RuboCop::Cop::Style::Proc::MSG = T.let(T.unsafe(nil), String)

# This cop checks the args passed to `fail` and `raise`. For exploded
# style (default), it recommends passing the exception class and message
# to `raise`, rather than construct an instance of the error. It will
# still allow passing just a message, or the construction of an error
# with more than one argument.
#
# The exploded style works identically, but with the addition that it
# will also suggest constructing error objects when the exception is
# passed multiple arguments.
#
# @example EnforcedStyle: exploded (default)
#   # bad
#   raise StandardError.new("message")
#
#   # good
#   raise StandardError, "message"
#   fail "message"
#   raise MyCustomError.new(arg1, arg2, arg3)
#   raise MyKwArgError.new(key1: val1, key2: val2)
# @example EnforcedStyle: compact
#   # bad
#   raise StandardError, "message"
#   raise RuntimeError, arg1, arg2, arg3
#
#   # good
#   raise StandardError.new("message")
#   raise MyCustomError.new(arg1, arg2, arg3)
#   fail "message"
#
# source://rubocop//lib/rubocop/cop/style/raise_args.rb#35
class RuboCop::Cop::Style::RaiseArgs < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#54
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#43
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#116
  def acceptable_exploded_args?(args); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#92
  def check_compact(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#102
  def check_exploded(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#66
  def correction_compact_to_exploded(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#79
  def correction_exploded_to_compact(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#135
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#130
  def requires_parens?(parent); end
end

# source://rubocop//lib/rubocop/cop/style/raise_args.rb#40
RuboCop::Cop::Style::RaiseArgs::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/raise_args.rb#38
RuboCop::Cop::Style::RaiseArgs::EXPLODED_MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of randomly generated numbers,
# added/subtracted with integer literals, as well as those with
# Integer#succ and Integer#pred methods. Prefer using ranges instead,
# as it clearly states the intentions.
#
# @example
#   # bad
#   rand(6) + 1
#   1 + rand(6)
#   rand(6) - 1
#   1 - rand(6)
#   rand(6).succ
#   rand(6).pred
#   Random.rand(6) + 1
#   Kernel.rand(6) + 1
#   rand(0..5) + 1
#
#   # good
#   rand(1..6)
#   rand(1...7)
#
# source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#26
class RuboCop::Cop::Style::RandomWithOffset < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#66
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#30
  def integer_op_rand?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#58
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#49
  def rand_modified?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#39
  def rand_op_integer?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#140
  def boundaries_from_random_node(random_node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#83
  def corrected_integer_op_rand(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#117
  def corrected_rand_modified(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#100
  def corrected_rand_op_integer(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#155
  def int_from_int_node(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#131
  def prefix_from_prefix_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#27
RuboCop::Cop::Style::RandomWithOffset::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant `begin` blocks.
#
# Currently it checks for code like this:
#
# @example
#
#   # bad
#   def redundant
#   begin
#   ala
#   bala
#   rescue StandardError => e
#   something
#   end
#   end
#
#   # good
#   def preferred
#   ala
#   bala
#   rescue StandardError => e
#   something
#   end
#
#   # bad
#   # When using Ruby 2.5 or later.
#   do_something do
#   begin
#   something
#   rescue => ex
#   anything
#   end
#   end
#
#   # good
#   # In Ruby 2.5 or later, you can omit `begin` in `do-end` block.
#   do_something do
#   something
#   rescue => ex
#   anything
#   end
#
#   # good
#   # Stabby lambdas don't support implicit `begin` in `do-end` blocks.
#   -> do
#   begin
#   foo
#   rescue Bar
#   baz
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#57
class RuboCop::Cop::Style::RedundantBegin < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#74
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#65
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#60
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#60
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#83
  def check(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#58
RuboCop::Cop::Style::RedundantBegin::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant returning of true/false in conditionals.
#
# @example
#   # bad
#   x == y ? true : false
#
#   # bad
#   if x == y
#   true
#   else
#   false
#   end
#
#   # good
#   x == y
#
#   # bad
#   x == y ? false : true
#
#   # good
#   x != y
#
# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#27
class RuboCop::Cop::Style::RedundantConditional < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#35
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#56
  def redundant_condition?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#60
  def redundant_condition_inverted?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#91
  def configured_indentation_width; end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#87
  def indented_else_node(expression, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#77
  def invert_expression?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#49
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#64
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#70
  def replacement_condition(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#30
RuboCop::Cop::Style::RedundantConditional::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#32
RuboCop::Cop::Style::RedundantConditional::MSG = T.let(T.unsafe(nil), String)

# This cop checks for RuntimeError as the argument of raise/fail.
#
# It checks for code like this:
#
# @example
#   # Bad
#   raise RuntimeError, 'message'
#
#   # Bad
#   raise RuntimeError.new('message')
#
#   # Good
#   raise 'message'
#
# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#19
class RuboCop::Cop::Style::RedundantException < ::RuboCop::Cop::Cop
  # Switch `raise RuntimeError, 'message'` to `raise 'message'`, and
  # `raise RuntimeError.new('message')` to `raise 'message'`.
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#54
  def compact?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#50
  def exploded?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#24
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#20
RuboCop::Cop::Style::RedundantException::MSG_1 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#21
RuboCop::Cop::Style::RedundantException::MSG_2 = T.let(T.unsafe(nil), String)

# This cop check for uses of Object#freeze on immutable objects.
#
# @example
#   # bad
#   CONST = 1.freeze
#
#   # good
#   CONST = 1
#
# source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#14
class RuboCop::Cop::Style::RedundantFreeze < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::FrozenStringLiteral

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#28
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#20
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#54
  def operation_produces_immutable_object?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#37
  def immutable_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#46
  def strip_parenthesis(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#17
RuboCop::Cop::Style::RedundantFreeze::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant parentheses.
#
# @example
#
#   # bad
#   (x) if ((y.z).nil?)
#
#   # good
#   x if y.z.nil?
#
# source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#16
class RuboCop::Cop::Style::RedundantParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Parentheses

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#26
  def arg_in_call_with_block?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#206
  def first_send_argument?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#210
  def first_super_argument?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#24
  def method_node_and_args(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#29
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#23
  def range_end?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#25
  def rescue?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#21
  def square_brackets?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#55
  def allowed_ancestor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#132
  def allowed_array_or_hash_element?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#48
  def allowed_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#60
  def allowed_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#65
  def allowed_multiple_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#146
  def array_element?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#214
  def call_chain_starts_with_int?(begin_node, send_node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#85
  def check(begin_node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#99
  def check_send(begin_node, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#108
  def check_unary(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#157
  def disallowed_literal?(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#74
  def empty_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#202
  def first_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#142
  def hash_element?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#79
  def hash_literal_as_first_arg?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#128
  def keyword_ancestor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#175
  def keyword_with_redundant_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#188
  def method_call_with_redundant_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#120
  def offense(node, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#198
  def only_begin_arg?(args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#150
  def only_closing_paren_before_comma?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#41
  def parens_allowed?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#163
  def raised_to_power_negative_numeric?(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#124
  def suspect_unary?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#19
RuboCop::Cop::Style::RedundantParentheses::ALLOWED_LITERALS = T.let(T.unsafe(nil), Array)

# This cop checks for redundant `return` expressions.
#
# @example
#   # These bad cases should be extended to handle methods whose body is
#   # if/else or a case expression with a default branch.
#
#   # bad
#   def test
#   return something
#   end
#
#   # bad
#   def test
#   one
#   two
#   three
#   return something
#   end
#
#   # good
#   def test
#   return something if something_else
#   end
#
#   # good
#   def test
#   if x
#   elsif y
#   else
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#38
class RuboCop::Cop::Style::RedundantReturn < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#51
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#44
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#44
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#78
  def add_braces(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#72
  def add_brackets(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#155
  def allow_multiple_return_values?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#84
  def arguments?(args); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#146
  def check_begin_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#92
  def check_branch(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#113
  def check_case_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#141
  def check_ensure_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#126
  def check_if_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#135
  def check_rescue_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#106
  def check_return_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#119
  def check_when_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#159
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#41
RuboCop::Cop::Style::RedundantReturn::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#42
RuboCop::Cop::Style::RedundantReturn::MULTI_RETURN_MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant uses of `self`.
#
# The usage of `self` is only needed when:
#
# * Sending a message to same object with zero arguments in
#   presence of a method name clash with an argument or a local
#   variable.
#
# * Calling an attribute writer to prevent an local variable assignment.
#
# Note, with using explicit self you can only send messages with public or
# protected scope, you cannot send private messages this way.
#
# Note we allow uses of `self` with operators because it would be awkward
# otherwise.
#
# @example
#
#   # bad
#   def foo(bar)
#   self.baz
#   end
#
#   # good
#   def foo(bar)
#   self.bar  # Resolves name clash with the argument.
#   end
#
#   def foo
#   bar = 1
#   self.bar  # Resolves name clash with the local variable.
#   end
#
#   def foo
#   %w[x y z].select do |bar|
#   self.bar == bar  # Resolves name clash with argument of the block.
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#44
class RuboCop::Cop::Style::RedundantSelf < ::RuboCop::Cop::Cop
  # @return [RedundantSelf] a new instance of RedundantSelf
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#52
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#104
  def autocorrect(node); end

  # Assignment of self.x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#60
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#78
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#100
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#82
  def on_blockarg(node); end

  # Using self.x to distinguish from local variable x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#73
  def on_def(node); end

  # Using self.x to distinguish from local variable x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#73
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#86
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#66
  def on_op_asgn(node); end

  # Assignment of self.x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#60
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#91
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#113
  def add_scope(node, local_variables = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#146
  def allow_self(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#119
  def allowed_send_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#138
  def keyword?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#133
  def on_argument(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#125
  def regular_method_call?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#48
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#46
RuboCop::Cop::Style::RedundantSelf::KERNEL_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#45
RuboCop::Cop::Style::RedundantSelf::MSG = T.let(T.unsafe(nil), String)

# This cop enforces using // or %r around regular expressions.
#
# @example EnforcedStyle: slashes (default)
#   # bad
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # bad
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
#
#   # good
#   snake_case = /^[\dA-Z_]+$/
#
#   # good
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
# @example EnforcedStyle: percent_r
#   # bad
#   snake_case = /^[\dA-Z_]+$/
#
#   # bad
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
#
#   # good
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # good
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
# @example EnforcedStyle: mixed
#   # bad
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # bad
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
#
#   # good
#   snake_case = /^[\dA-Z_]+$/
#
#   # good
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
# @example AllowInnerSlashes: false (default)
#   # If `false`, the cop will always recommend using `%r` if one or more
#   # slashes are found in the regexp string.
#
#   # bad
#   x =~ /home\//
#
#   # good
#   x =~ %r{home/}
# @example AllowInnerSlashes: true
#   # good
#   x =~ /home\//
#
# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#84
class RuboCop::Cop::Style::RegexpLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#99
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#91
  def on_regexp(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#149
  def allow_inner_slashes?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#136
  def allowed_mixed_percent_r?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#125
  def allowed_mixed_slash?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#130
  def allowed_percent_r_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#120
  def allowed_slash_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#218
  def calculate_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#114
  def check_percent_r_literal(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#108
  def check_slash_literal(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#141
  def contains_disallowed_slash?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#145
  def contains_slash?(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#167
  def correct_delimiters(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#173
  def correct_inner_slashes(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#206
  def inner_slash_after_correction(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#202
  def inner_slash_before_correction(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#210
  def inner_slash_for(opening_delimiter); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#189
  def inner_slash_indices(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#153
  def node_body(node, include_begin_nodes: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#162
  def preferred_delimiters; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#158
  def slash_literal?(node); end
end

# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#89
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_PERCENT_R = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#88
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_SLASHES = T.let(T.unsafe(nil), String)

# This cop checks for uses of rescue in its modifier form.
#
# @example
#   # bad
#   some_method rescue handle_error
#
#   # good
#   begin
#   some_method
#   rescue
#   handle_error
#   end
#
# source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#18
class RuboCop::Cop::Style::RescueModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode

  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#24
  def on_resbody(node); end
end

# source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#22
RuboCop::Cop::Style::RescueModifier::MSG = T.let(T.unsafe(nil), String)

# This cop checks for rescuing `StandardError`. There are two supported
# styles `implicit` and `explicit`. This cop will not register an offense
# if any error other than `StandardError` is specified.
#
# @example EnforcedStyle: implicit
#   # `implicit` will enforce using `rescue` instead of
#   # `rescue StandardError`.
#
#   # bad
#   begin
#   foo
#   rescue StandardError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue OtherError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError, SecurityError
#   bar
#   end
# @example EnforcedStyle: explicit (default)
#   # `explicit` will enforce using `rescue StandardError`
#   # instead of `rescue`.
#
#   # bad
#   begin
#   foo
#   rescue
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue OtherError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError, SecurityError
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#73
class RuboCop::Cop::Style::RescueStandardError < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#108
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#91
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#87
  def rescue_standard_error?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#83
  def rescue_without_error_class?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#80
RuboCop::Cop::Style::RescueStandardError::MSG_EXPLICIT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#78
RuboCop::Cop::Style::RescueStandardError::MSG_IMPLICIT = T.let(T.unsafe(nil), String)

# This cop enforces consistency between 'return nil' and 'return'.
#
# Supported styles are: return, return_nil.
#
# @example EnforcedStyle: return (default)
#   # bad
#   def foo(arg)
#   return nil if arg
#   end
#
#   # good
#   def foo(arg)
#   return if arg
#   end
# @example EnforcedStyle: return_nil
#   # bad
#   def foo(arg)
#   return if arg
#   end
#
#   # good
#   def foo(arg)
#   return nil if arg
#   end
#
# source://rubocop//lib/rubocop/cop/style/return_nil.rb#31
class RuboCop::Cop::Style::ReturnNil < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#60
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#82
  def chained_send?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#83
  def define_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#40
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#38
  def return_nil_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#37
  def return_node?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#73
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#69
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#78
  def scoped_node?(node); end
end

# source://rubocop//lib/rubocop/cop/style/return_nil.rb#34
RuboCop::Cop::Style::ReturnNil::RETURN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/return_nil.rb#35
RuboCop::Cop::Style::ReturnNil::RETURN_NIL_MSG = T.let(T.unsafe(nil), String)

# This cop transforms usages of a method call safeguarded by a non `nil`
# check for the variable whose method is being called to
# safe navigation (`&.`). If there is a method chain, all of the methods
# in the chain need to be checked for safety, and all of the methods will
# need to be changed to use safe navigation. We have limited the cop to
# not register an offense for method chains that exceed 2 methods.
#
# Configuration option: ConvertCodeThatCanStartToReturnNil
# The default for this is `false`. When configured to `true`, this will
# check for code in the format `!foo.nil? && foo.bar`. As it is written,
# the return of this code is limited to `false` and whatever the return
# of the method is. If this is converted to safe navigation,
# `foo&.bar` can start returning `nil` as well as what the method
# returns.
#
# @example
#   # bad
#   foo.bar if foo
#   foo.bar.baz if foo
#   foo.bar(param1, param2) if foo
#   foo.bar { |e| e.something } if foo
#   foo.bar(param) { |e| e.something } if foo
#
#   foo.bar if !foo.nil?
#   foo.bar unless !foo
#   foo.bar unless foo.nil?
#
#   foo && foo.bar
#   foo && foo.bar.baz
#   foo && foo.bar(param1, param2)
#   foo && foo.bar { |e| e.something }
#   foo && foo.bar(param) { |e| e.something }
#
#   # good
#   foo&.bar
#   foo&.bar&.baz
#   foo&.bar(param1, param2)
#   foo&.bar { |e| e.something }
#   foo&.bar(param) { |e| e.something }
#   foo && foo.bar.baz.qux # method chain with more than 2 methods
#   foo && foo.nil? # method that `nil` responds to
#
#   # Method calls that do not use `.`
#   foo && foo < bar
#   foo < bar if foo
#
#   # This could start returning `nil` as well as the return of the method
#   foo.nil? || foo.bar
#   !foo || foo.bar
#
#   # Methods that are used on assignment, arithmetic operation or
#   # comparison should not be converted to use safe navigation
#   foo.baz = bar if foo
#   foo.baz + bar if foo
#   foo.bar > 2 if foo
#
# source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#61
class RuboCop::Cop::Style::SafeNavigation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#117
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#99
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#73
  def modifier_if_safe_navigation_candidate?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#87
  def not_nil_check?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#95
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#89
  def on_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#113
  def use_var_only_in_unless_modifier?(node, variable); end

  private

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#238
  def add_safe_nav_to_all_methods_in_chain(corrector, start_method, method_chain); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#133
  def allowed_if_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#228
  def begin_range(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#190
  def chain_size(method_chain, method); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#233
  def end_range(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#167
  def extract_common_parts(method_chain, checked_variable); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#137
  def extract_parts(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#155
  def extract_parts_from_and(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#146
  def extract_parts_from_if(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#176
  def find_matching_receiver_invocation(method_chain, checked_variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#224
  def method_called?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#216
  def negated?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#212
  def unsafe_method?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#198
  def unsafe_method_used?(method_chain, method); end
end

# source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#66
RuboCop::Cop::Style::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the use the shorthand for self-assignment.
#
# @example
#
#   # bad
#   x = x + 1
#
#   # good
#   x += 1
#
# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#15
class RuboCop::Cop::Style::SelfAssignment < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#31
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#27
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#23
  def on_lvasgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#88
  def apply_autocorrect(node, rhs, operator, new_rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#83
  def autocorrect_boolean_node(node, rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#78
  def autocorrect_send_node(node, rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#47
  def check(node, var_type); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#68
  def check_boolean_node(node, rhs, var_name, var_type); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#58
  def check_send_node(node, rhs, var_name, var_type); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#19
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#16
RuboCop::Cop::Style::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#17
RuboCop::Cop::Style::SelfAssignment::OPS = T.let(T.unsafe(nil), Array)

# This cop checks for multiple expressions placed on the same line.
# It also checks for lines terminated with a semicolon.
#
# @example
#   # bad
#   foo = 1; bar = 2;
#   baz = 3;
#
#   # good
#   foo = 1
#   bar = 2
#   baz = 3
#
# source://rubocop//lib/rubocop/cop/style/semicolon.rb#18
class RuboCop::Cop::Style::Semicolon < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#58
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#23
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#31
  def on_begin(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#66
  def check_for_line_terminator_or_opener; end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#81
  def convention_on(line, column, autocorrect); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#70
  def each_semicolon; end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#77
  def tokens_for_lines; end
end

# source://rubocop//lib/rubocop/cop/style/semicolon.rb#21
RuboCop::Cop::Style::Semicolon::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of the send method.
#
# @example
#   # bad
#   Foo.send(:bar)
#   quuz.send(:fred)
#
#   # good
#   Foo.__send__(:bar)
#   quuz.public_send(:fred)
#
# source://rubocop//lib/rubocop/cop/style/send.rb#16
class RuboCop::Cop::Style::Send < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/send.rb#22
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/send.rb#22
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/send.rb#20
  def sending?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/send.rb#17
RuboCop::Cop::Style::Send::MSG = T.let(T.unsafe(nil), String)

# This cop checks for uses of `fail` and `raise`.
#
# @example EnforcedStyle: only_raise (default)
#   # The `only_raise` style enforces the sole use of `raise`.
#   # bad
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.fail
#
#   # good
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.raise
# @example EnforcedStyle: only_fail
#   # The `only_fail` style enforces the sole use of `fail`.
#   # bad
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.raise
#
#   # good
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.fail
# @example EnforcedStyle: semantic
#   # The `semantic` style enforces the use of `fail` to signal an
#   # exception, then will use `raise` to trigger an offense after
#   # it has been rescued.
#   # bad
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   # Error thrown
#   rescue Exception
#   fail
#   end
#
#   Kernel.fail
#   Kernel.raise
#
#   # good
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   raise 'Preferably with descriptive message'
#   end
#
#   explicit_receiver.fail
#   explicit_receiver.raise
#
# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#107
class RuboCop::Cop::Style::SignalException < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#148
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#115
  def custom_fail_methods(node0); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#118
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#114
  def kernel_call?(node = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#123
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#135
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#197
  def allow(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#175
  def check_scope(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#187
  def check_send(method_name, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#193
  def command_or_kernel_call?(name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#203
  def each_command_or_kernel_call(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#164
  def message(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#110
RuboCop::Cop::Style::SignalException::FAIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#111
RuboCop::Cop::Style::SignalException::RAISE_MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the block parameters of a single-line
# method accepting a block match the names specified via configuration.
#
# For instance one can configure `reduce`(`inject`) to use |a, e| as
# parameters.
#
# Configuration option: Methods
# Should be set to use this cop. Array of hashes, where each key is the
# method name and value - array of argument names.
#
# @example Methods: [{reduce: %w[a b]}]
#   # bad
#   foo.reduce { |c, d| c + d }
#   foo.reduce { |_, _d| 1 }
#
#   # good
#   foo.reduce { |a, b| a + b }
#   foo.reduce { |a, _b| a }
#   foo.reduce { |a, (id, _)| a + id }
#   foo.reduce { true }
#
#   # good
#   foo.reduce do |c, d|
#   c + d
#   end
#
# source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#31
class RuboCop::Cop::Style::SingleLineBlockParams < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#34
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#81
  def args_match?(method_name, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#54
  def eligible_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#58
  def eligible_method?(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#47
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#71
  def method_name(method); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#67
  def method_names; end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#63
  def methods; end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#75
  def target_args(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#32
RuboCop::Cop::Style::SingleLineBlockParams::MSG = T.let(T.unsafe(nil), String)

# This cop checks for single-line method definitions that contain a body.
# It will accept single-line methods with no body.
#
# @example
#   # bad
#   def some_method; body end
#   def link_to(url); {:name => url}; end
#   def @table.columns; super; end
#
#   # good
#   def no_op; end
#   def self.resource_class=(klass); end
#   def @table.columns; end
#
# source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#20
class RuboCop::Cop::Style::SingleLineMethods < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#33
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#25
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#25
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#53
  def allow_empty?; end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#57
  def each_part(body); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#67
  def move_comment(node, corrector); end
end

# source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#23
RuboCop::Cop::Style::SingleLineMethods::MSG = T.let(T.unsafe(nil), String)

# This cop looks for uses of Perl-style global variables.
#
# @example EnforcedStyle: use_english_names (default)
#   # good
#   puts $LOAD_PATH
#   puts $LOADED_FEATURES
#   puts $PROGRAM_NAME
#   puts $ERROR_INFO
#   puts $ERROR_POSITION
#   puts $FIELD_SEPARATOR # or $FS
#   puts $OUTPUT_FIELD_SEPARATOR # or $OFS
#   puts $INPUT_RECORD_SEPARATOR # or $RS
#   puts $OUTPUT_RECORD_SEPARATOR # or $ORS
#   puts $INPUT_LINE_NUMBER # or $NR
#   puts $LAST_READ_LINE
#   puts $DEFAULT_OUTPUT
#   puts $DEFAULT_INPUT
#   puts $PROCESS_ID # or $PID
#   puts $CHILD_STATUS
#   puts $LAST_MATCH_INFO
#   puts $IGNORECASE
#   puts $ARGV # or ARGV
#   puts $MATCH
#   puts $PREMATCH
#   puts $POSTMATCH
#   puts $LAST_PAREN_MATCH
# @example EnforcedStyle: use_perl_names
#   # good
#   puts $:
#   puts $"
#   puts $0
#   puts $!
#   puts $@
#   puts $;
#   puts $,
#   puts $/
#   puts $\
#   puts $.
#   puts $_
#   puts $>
#   puts $<
#   puts $$
#   puts $?
#   puts $~
#   puts $=
#   puts $*
#   puts $&
#   puts $`
#   puts $'
#   puts $+
#
# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#59
class RuboCop::Cop::Style::SpecialGlobalVars < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#139
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#127
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#114
  def on_gvar(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#205
  def english_name_replacement(preferred_name, node); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#154
  def format_english_message(global_var); end

  # For now, we assume that lists are 2 items or less. Easy grammar!
  #
  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#178
  def format_list(items); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#162
  def format_message(english, regular, global); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#197
  def preferred_names(global); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#182
  def replacement(node, global_var); end
end

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#69
RuboCop::Cop::Style::SpecialGlobalVars::ENGLISH_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#62
RuboCop::Cop::Style::SpecialGlobalVars::MSG_BOTH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#65
RuboCop::Cop::Style::SpecialGlobalVars::MSG_ENGLISH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#67
RuboCop::Cop::Style::SpecialGlobalVars::MSG_REGULAR = T.let(T.unsafe(nil), String)

# Anything *not* in this set is provided by the English library.
#
# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#107
RuboCop::Cop::Style::SpecialGlobalVars::NON_ENGLISH_VARS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#94
RuboCop::Cop::Style::SpecialGlobalVars::PERL_VARS = T.let(T.unsafe(nil), Hash)

# Check for parentheses around stabby lambda arguments.
# There are two different styles. Defaults to `require_parentheses`.
#
# @example EnforcedStyle: require_parentheses (default)
#   # bad
#   ->a,b,c { a + b + c }
#
#   # good
#   ->(a,b,c) { a + b + c}
# @example EnforcedStyle: require_no_parentheses
#   # bad
#   ->(a,b,c) { a + b + c }
#
#   # good
#   ->a,b,c { a + b + c}
#
# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#22
class RuboCop::Cop::Style::StabbyLambdaParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#36
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#28
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#54
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#46
  def missing_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#58
  def missing_parentheses_corrector(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#80
  def parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#50
  def redundant_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#76
  def stabby_lambda_with_args?(node); end

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#67
  def unwanted_parentheses_corrector(node); end
end

# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#26
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_NO_REQUIRE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#25
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_REQUIRE = T.let(T.unsafe(nil), String)

# This cop identifies places where `$stderr.puts` can be replaced by
# `warn`. The latter has the advantage of easily being disabled by,
# the `-W0` interpreter flag or setting `$VERBOSE` to `nil`.
#
# @example
#   # bad
#   $stderr.puts('hello')
#
#   # good
#   warn('hello')
#
# source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#17
class RuboCop::Cop::Style::StderrPuts < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#35
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#29
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#23
  def stderr_puts?(node = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#43
  def stderr_gvar?(sym); end

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#47
  def stderr_puts_range(send); end
end

# source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#20
RuboCop::Cop::Style::StderrPuts::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of strings as keys in hashes. The use of
# symbols is preferred instead.
#
# @example
#   # bad
#   { 'one' => 1, 'two' => 2, 'three' => 3 }
#
#   # good
#   { one: 1, two: 2, three: 3 }
#
# source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#15
class RuboCop::Cop::Style::StringHashKeys < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#40
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#33
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#22
  def receive_environments_method?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#18
  def string_hash_key?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#16
RuboCop::Cop::Style::StringHashKeys::MSG = T.let(T.unsafe(nil), String)

# Checks if uses of quotes match the configured preference.
#
# @example EnforcedStyle: single_quotes (default)
#   # bad
#   "No special symbols"
#   "No string interpolation"
#   "Just text"
#
#   # good
#   'No special symbols'
#   'No string interpolation'
#   'Just text'
#   "Wait! What's #{this}!"
# @example EnforcedStyle: double_quotes
#   # bad
#   'Just some text'
#   'No special chars or interpolation'
#
#   # good
#   "Just some text"
#   "No special chars or interpolation"
#   "Every string in #{project} uses double_quotes"
#
# source://rubocop//lib/rubocop/cop/style/string_literals.rb#29
class RuboCop::Cop::Style::StringLiterals < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringHelp
  include ::RuboCop::Cop::StringLiteralsHelp

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#57
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#35
  def on_dstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#121
  def accept_child_double_quotes?(nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#63
  def all_string_literals?(nodes); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#101
  def check_multiline_quote_style(node, quote); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#97
  def consistent_multiline?; end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#67
  def detect_quote_styles(node); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#79
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#89
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#117
  def unexpected_double_quotes?(quote); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#113
  def unexpected_single_quotes?(quote); end
end

# source://rubocop//lib/rubocop/cop/style/string_literals.rb#33
RuboCop::Cop::Style::StringLiterals::MSG_INCONSISTENT = T.let(T.unsafe(nil), String)

# This cop checks that quotes inside the string interpolation
# match the configured preference.
#
# @example EnforcedStyle: single_quotes (default)
#   # bad
#   result = "Tests #{success ? "PASS" : "FAIL"}"
#
#   # good
#   result = "Tests #{success ? 'PASS' : 'FAIL'}"
# @example EnforcedStyle: double_quotes
#   # bad
#   result = "Tests #{success ? 'PASS' : 'FAIL'}"
#
#   # good
#   result = "Tests #{success ? "PASS" : "FAIL"}"
#
# source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#22
class RuboCop::Cop::Style::StringLiteralsInInterpolation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringHelp
  include ::RuboCop::Cop::StringLiteralsHelp

  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#26
  def autocorrect(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#32
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#39
  def offense?(node); end
end

# This cop enforces the use of consistent method names
# from the String class.
#
# @example
#   # bad
#   'name'.intern
#   'var'.unfavored_method
#
#   # good
#   'name'.to_sym
#   'var'.preferred_method
#
# source://rubocop//lib/rubocop/cop/style/string_methods.rb#17
class RuboCop::Cop::Style::StringMethods < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::MethodPreference

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#29
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#22
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#22
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#38
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/style/string_methods.rb#20
RuboCop::Cop::Style::StringMethods::MSG = T.let(T.unsafe(nil), String)

# This cop checks for inheritance from Struct.new.
#
# @example
#   # bad
#   class Person < Struct.new(:first_name, :last_name)
#   end
#
#   # good
#   Person = Struct.new(:first_name, :last_name)
#
# source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#15
class RuboCop::Cop::Style::StructInheritance < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#18
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#25
  def struct_constructor?(node = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#16
RuboCop::Cop::Style::StructInheritance::MSG = T.let(T.unsafe(nil), String)

# This cop can check for array literals made up of symbols that are not
# using the %i() syntax.
#
# Alternatively, it checks for symbol arrays using the %i() syntax on
# projects which do not want to use that syntax.
#
# Configuration option: MinSize
# If set, arrays with fewer elements than this value will not trigger the
# cop. For example, a `MinSize of `3` will not enforce a style on an array
# of 2 or fewer elements.
#
# @example EnforcedStyle: percent (default)
#   # good
#   %i[foo bar baz]
#
#   # bad
#   [:foo, :bar, :baz]
# @example EnforcedStyle: brackets
#   # good
#   [:foo, :bar, :baz]
#
#   # bad
#   %i[foo bar baz]
#
# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#30
class RuboCop::Cop::Style::SymbolArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#53
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#43
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#72
  def correct_bracketed(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#96
  def symbol_without_quote?(string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#65
  def symbols_contain_spaces?(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#88
  def to_symbol_literal(string); end

  class << self
    # Returns the value of attribute largest_brackets.
    #
    # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#40
    def largest_brackets; end

    # Sets the attribute largest_brackets
    #
    # @param value the value to set the attribute largest_brackets to.
    #
    # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#40
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#37
RuboCop::Cop::Style::SymbolArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#36
RuboCop::Cop::Style::SymbolArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

# This cop checks symbol literal syntax.
#
# @example
#
#   # bad
#   :"symbol"
#
#   # good
#   :symbol
#
# source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#15
class RuboCop::Cop::Style::SymbolLiteral < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#24
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#18
  def on_sym(node); end
end

# source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#16
RuboCop::Cop::Style::SymbolLiteral::MSG = T.let(T.unsafe(nil), String)

# Use symbols as procs when possible.
#
# @example
#   # bad
#   something.map { |s| s.upcase }
#
#   # good
#   something.map(&:upcase)
#
# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#14
class RuboCop::Cop::Style::SymbolProc < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#51
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#34
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#22
  def proc_node?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#23
  def symbol_proc?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#86
  def autocorrect_method(corrector, node, args, method_name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#94
  def autocorrect_no_args(corrector, node, method_name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#98
  def autocorrect_with_args(corrector, node, args, method_name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#113
  def begin_pos_for_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#107
  def block_range_with_space(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#74
  def offense(node, method_name, block_method_name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#67
  def resolve_block_method_name(block_send_or_super); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#124
  def super?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#30
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#18
RuboCop::Cop::Style::SymbolProc::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#20
RuboCop::Cop::Style::SymbolProc::SUPER_TYPES = T.let(T.unsafe(nil), Array)

# Corrector to correct conditional assignment in ternary conditions.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#494
class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#499
    def correct(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#505
    def move_assignment_inside_condition(node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#521
    def correction(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#536
    def element_assignment?(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#540
    def extract_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#553
    def move_branch_inside_condition(corrector, branch, assignment); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#548
    def remove_parentheses(corrector, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#527
    def ternary(condition, if_branch, else_branch); end
  end
end

# This cop checks for the presence of parentheses around ternary
# conditions. It is configurable to enforce inclusion or omission of
# parentheses using `EnforcedStyle`. Omission is only enforced when
# removing the parentheses won't cause a different behavior.
#
# @example EnforcedStyle: require_no_parentheses (default)
#   # bad
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = (bar && baz) ? a : b
#
#   # good
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = bar && baz ? a : b
# @example EnforcedStyle: require_parentheses
#   # bad
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = bar && baz ? a : b
#
#   # good
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = (bar && baz) ? a : b
# @example EnforcedStyle: require_parentheses_when_complex
#   # bad
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = bar && baz ? a : b
#
#   # good
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = (bar && baz) ? a : b
#
# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#43
class RuboCop::Cop::Style::TernaryParentheses < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#61
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#160
  def method_name(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#55
  def on_if(node); end

  private

  # If the condition is parenthesized we recurse and check for any
  # complex expressions within it.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#95
  def complex_condition?(condition); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#165
  def correct_parenthesized(condition); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#179
  def correct_unparenthesized(condition); end

  # When this cop is configured to enforce parentheses and the
  # `RedundantParentheses` cop is enabled, it will cause an infinite loop
  # as they compete to add and remove the parentheses respectively.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#145
  def infinite_loop?; end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#116
  def message(node); end

  # Anything that is not a variable, constant, or method/.method call
  # will be counted as a complex expression.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#105
  def non_complex_expression?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#110
  def non_complex_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#77
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#138
  def parenthesized?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#134
  def redundant_parentheses_enabled?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#126
  def require_parentheses?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#130
  def require_parentheses_when_complex?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#156
  def unparenthesized_method_call?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#150
  def unsafe_autocorrect?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#186
  def whitespace_after?(node); end
end

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#51
RuboCop::Cop::Style::TernaryParentheses::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#52
RuboCop::Cop::Style::TernaryParentheses::MSG_COMPLEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#49
RuboCop::Cop::Style::TernaryParentheses::NON_COMPLEX_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#48
RuboCop::Cop::Style::TernaryParentheses::VARIABLE_TYPES = T.let(T.unsafe(nil), Array)

# This cop checks for trailing code after the class definition.
#
# @example
#   # bad
#   class Foo; def foo; end
#   end
#
#   # good
#   class Foo
#   def foo; end
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#18
class RuboCop::Cop::Style::TrailingBodyOnClass < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#24
  def on_class(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#22
RuboCop::Cop::Style::TrailingBodyOnClass::MSG = T.let(T.unsafe(nil), String)

# This cop checks for trailing code after the method definition.
#
# @example
#   # bad
#   def some_method; do_stuff
#   end
#
#   def f(x); b = foo
#   b[c: x]
#   end
#
#   # good
#   def some_method
#   do_stuff
#   end
#
#   def f(x)
#   b = foo
#   b[c: x]
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#27
class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#34
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#34
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#31
RuboCop::Cop::Style::TrailingBodyOnMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# This cop checks for trailing code after the module definition.
#
# @example
#   # bad
#   module Foo extend self
#   end
#
#   # good
#   module Foo
#   extend self
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#18
class RuboCop::Cop::Style::TrailingBodyOnModule < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#30
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#24
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#22
RuboCop::Cop::Style::TrailingBodyOnModule::MSG = T.let(T.unsafe(nil), String)

# This cop checks for trailing comma in argument lists.
#
# @example EnforcedStyleForMultiline: consistent_comma
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # good
#   method(
#   1, 2,
#   3,
#   )
#
#   # good
#   method(
#   1,
#   2,
#   )
# @example EnforcedStyleForMultiline: comma
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # good
#   method(
#   1,
#   2,
#   )
# @example EnforcedStyleForMultiline: no_comma (default)
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # good
#   method(
#   1,
#   2
#   )
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#52
class RuboCop::Cop::Style::TrailingCommaInArguments < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#64
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#55
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#55
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#70
  def avoid_autocorrect?(args); end

  # Returns true if running with --auto-correct would remove the braces
  # of the last argument.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#77
  def braces_will_be_removed?(args); end
end

# This cop checks for trailing comma in array literals.
#
# @example EnforcedStyleForMultiline: consistent_comma
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [
#   1, 2,
#   3,
#   ]
#
#   # good
#   a = [
#   1,
#   2,
#   ]
# @example EnforcedStyleForMultiline: comma
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [
#   1,
#   2,
#   ]
# @example EnforcedStyleForMultiline: no_comma (default)
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [
#   1,
#   2
#   ]
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#43
class RuboCop::Cop::Style::TrailingCommaInArrayLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#52
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#46
  def on_array(node); end
end

# This cop checks for trailing comma in hash literals.
#
# @example EnforcedStyleForMultiline: consistent_comma
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = {
#   foo: 1, bar: 2,
#   qux: 3,
#   }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2,
#   }
# @example EnforcedStyleForMultiline: comma
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2,
#   }
# @example EnforcedStyleForMultiline: no_comma (default)
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2
#   }
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#43
class RuboCop::Cop::Style::TrailingCommaInHashLiteral < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#50
  def autocorrect(range); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#46
  def on_hash(node); end
end

# This cop checks for trailing code after the method definition.
#
# @example
#   # bad
#   def some_method
#   do_stuff; end
#
#   def do_this(x)
#   baz.map { |b| b.this(x) } end
#
#   def foo
#   block do
#   bar
#   end end
#
#   # good
#   def some_method
#   do_stuff
#   end
#
#   def do_this(x)
#   baz.map { |b| b.this(x) }
#   end
#
#   def foo
#   block do
#   bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#36
class RuboCop::Cop::Style::TrailingMethodEndStatement < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::Alignment

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#48
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#42
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#67
  def body_and_end_on_same_line?(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#78
  def break_line_before_end(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#63
  def end_token(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#85
  def remove_semicolon(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#71
  def token_before_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#57
  def trailing_end?(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#39
RuboCop::Cop::Style::TrailingMethodEndStatement::MSG = T.let(T.unsafe(nil), String)

# This cop checks for extra underscores in variable assignment.
#
# @example
#   # bad
#   a, b, _ = foo()
#   a, b, _, = foo()
#   a, _, _ = foo()
#   a, _, _, = foo()
#
#   # good
#   a, b, = foo()
#   a, = foo()
#   *a, b, _ = foo()
#   # => We need to know to not include 2 variables in a
#   a, *b, _ = foo()
#   # => The correction `a, *b, = foo()` is a syntax error
#
#   # good if AllowNamedUnderscoreVariables is true
#   a, b, _something = foo()
#
# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#25
class RuboCop::Cop::Style::TrailingUnderscoreVariable < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#47
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#33
  def on_masgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#94
  def allow_named_underscore_variables; end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#131
  def children_offenses(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#57
  def find_first_offense(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#66
  def find_first_possible_offense(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#111
  def main_node_offense(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#152
  def range_for_parentheses(offense, left); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#90
  def reverse_index(collection, item); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#82
  def splat_variable_before?(first_offense, variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#99
  def unneeded_ranges(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#139
  def unused_range(node_type, mlhs_node, right); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#135
  def unused_variables_only?(offense, variables); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#29
RuboCop::Cop::Style::TrailingUnderscoreVariable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#31
RuboCop::Cop::Style::TrailingUnderscoreVariable::UNDERSCORE = T.let(T.unsafe(nil), String)

# This cop looks for trivial reader/writer methods, that could
# have been created with the attr_* family of functions automatically.
#
# @example
#   # bad
#   def foo
#   @foo
#   end
#
#   def bar=(val)
#   @bar = val
#   end
#
#   def self.baz
#   @baz
#   end
#
#   # good
#   attr_reader :foo
#   attr_writer :bar
#
#   class << self
#   attr_reader :baz
#   end
#
# source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#30
class RuboCop::Cop::Style::TrivialAccessors < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#42
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#121
  def looks_like_trivial_writer?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#33
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#33
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#154
  def accessor(kind, method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#90
  def allow_dsl_writers?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#86
  def allow_predicates?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#126
  def allowed_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#135
  def allowed_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#131
  def allowed_writer?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#169
  def autocorrect_class(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#158
  def autocorrect_instance(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#103
  def dsl_writer?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#82
  def exact_name_match?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#94
  def ignore_class_methods?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#55
  def in_module_or_instance_eval?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#112
  def looks_like_trivial_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#139
  def names_match?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#69
  def on_method_def(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#185
  def top_level_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#145
  def trivial_accessor_kind(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#107
  def trivial_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#116
  def trivial_writer?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#98
  def whitelist; end
end

# source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#31
RuboCop::Cop::Style::TrivialAccessors::MSG = T.let(T.unsafe(nil), String)

# Corrector to correct conditional assignment in `unless` statements.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#678
class RuboCop::Cop::Style::UnlessCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#683
    def correct(cop, node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#689
    def extract_tail_branches(node); end
  end
end

# This cop looks for *unless* expressions with *else* clauses.
#
# @example
#   # bad
#   unless foo_bar.nil?
#   # do something...
#   else
#   # do a different thing...
#   end
#
#   # good
#   if foo_bar.present?
#   # do something...
#   else
#   # do a different thing...
#   end
#
# source://rubocop//lib/rubocop/cop/style/unless_else.rb#22
class RuboCop::Cop::Style::UnlessElse < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#28
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#46
  def range_between_condition_and_else(node, condition); end

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#50
  def range_between_else_and_end(node); end
end

# source://rubocop//lib/rubocop/cop/style/unless_else.rb#25
RuboCop::Cop::Style::UnlessElse::MSG = T.let(T.unsafe(nil), String)

# This cop checks for usage of the %W() syntax when %w() would do.
#
# @example
#   # bad
#   %W(cat dog pig)
#   %W[door wall floor]
#
#   # good
#   %w/swim run bike/
#   %w[shirt pants shoes]
#   %W(apple #{fruit} grape)
#
# source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#17
class RuboCop::Cop::Style::UnneededCapitalW < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#27
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#23
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#36
  def on_percent_literal(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#42
  def requires_interpolation?(node); end
end

# source://rubocop//lib/rubocop/cop/style/unneeded_capital_w.rb#20
RuboCop::Cop::Style::UnneededCapitalW::MSG = T.let(T.unsafe(nil), String)

# This cop checks for unnecessary conditional expressions.
#
# @example
#   # bad
#   a = b ? b : c
#
#   # good
#   a = b || c
# @example
#   # bad
#   if b
#   b
#   else
#   c
#   end
#
#   # good
#   b || c
#
#   # good
#   if b
#   b
#   elsif cond
#   c
#   end
#
# source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#33
class RuboCop::Cop::Style::UnneededCondition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#39
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#92
  def else_source(else_branch); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#98
  def make_ternary_form(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#62
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#76
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#70
  def range_of_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#88
  def use_if_branch?(else_branch); end
end

# source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#36
RuboCop::Cop::Style::UnneededCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_condition.rb#37
RuboCop::Cop::Style::UnneededCondition::UNNEEDED_CONDITION = T.let(T.unsafe(nil), String)

# This cop checks for strings that are just an interpolated expression.
#
# @example
#
#   # bad
#   "#{@var}"
#
#   # good
#   @var.to_s
#
#   # good if @var is already a String
#   @var
#
# source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#18
class RuboCop::Cop::Style::UnneededInterpolation < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#31
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#27
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#84
  def autocorrect_other(embedded_node, node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#78
  def autocorrect_single_variable_interpolation(embedded_node, node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#73
  def autocorrect_variable_interpolation(embedded_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#68
  def embedded_in_percent_array?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#64
  def implicit_concatenation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#56
  def interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#45
  def single_interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#52
  def single_variable_interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#60
  def variable_interpolation?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#23
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/unneeded_interpolation.rb#21
RuboCop::Cop::Style::UnneededInterpolation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for usage of the %q/%Q syntax when '' or "" would do.
#
# @example
#
#   # bad
#   name = %q(Bruce Wayne)
#   time = %q(8 o'clock)
#   question = %q("What did you say?")
#
#   # good
#   name = 'Bruce Wayne'
#   time = "8 o'clock"
#   question = '"What did you say?"'
#
# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#20
class RuboCop::Cop::Style::UnneededPercentQ < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#48
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#33
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#39
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#103
  def acceptable_capital_q?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#95
  def acceptable_q?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#70
  def allowed_percent_q?(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#59
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#66
  def interpolated_quotes?(node); end

  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#76
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#91
  def start_with_percent_q_variant?(string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#86
  def string_literal?(node); end
end

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#23
RuboCop::Cop::Style::UnneededPercentQ::DYNAMIC_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#27
RuboCop::Cop::Style::UnneededPercentQ::EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#31
RuboCop::Cop::Style::UnneededPercentQ::ESCAPED_NON_BACKSLASH = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#21
RuboCop::Cop::Style::UnneededPercentQ::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#29
RuboCop::Cop::Style::UnneededPercentQ::PERCENT_CAPITAL_Q = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#28
RuboCop::Cop::Style::UnneededPercentQ::PERCENT_Q = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#26
RuboCop::Cop::Style::UnneededPercentQ::QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#25
RuboCop::Cop::Style::UnneededPercentQ::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unneeded_percent_q.rb#30
RuboCop::Cop::Style::UnneededPercentQ::STRING_INTERPOLATION_REGEXP = T.let(T.unsafe(nil), Regexp)

# This cop checks for accessing the first element of `String#unpack`
# which can be replaced with the shorter method `unpack1`.
#
# @example
#
#   # bad
#   'foo'.unpack('h*').first
#   'foo'.unpack('h*')[0]
#   'foo'.unpack('h*').slice(0)
#   'foo'.unpack('h*').at(0)
#
#   # good
#   'foo'.unpack1('h*')
#
# source://rubocop//lib/rubocop/cop/style/unpack_first.rb#20
class RuboCop::Cop::Style::UnpackFirst < ::RuboCop::Cop::Cop
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#46
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#35
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#28
  def unpack_and_first_element?(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#57
  def first_element_range(node, unpack_call); end
end

# source://rubocop//lib/rubocop/cop/style/unpack_first.rb#25
RuboCop::Cop::Style::UnpackFirst::MSG = T.let(T.unsafe(nil), String)

# This cop checks for variable interpolation (like "#@ivar").
#
# @example
#   # bad
#   "His name is #$name"
#   /check #$pattern/
#   "Let's go to the #@store"
#
#   # good
#   "His name is #{$name}"
#   /check #{$pattern}/
#   "Let's go to the #{@store}"
#
# source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#18
class RuboCop::Cop::Style::VariableInterpolation < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#34
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#22
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#26
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#30
  def on_xstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#42
  def check_for_interpolation(node); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#48
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#52
  def var_nodes(nodes); end
end

# source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#19
RuboCop::Cop::Style::VariableInterpolation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for *when;* uses in *case* expressions.
#
# @example
#   # bad
#   case foo
#   when 1; 'baz'
#   when 2; 'bar'
#   end
#
#   # good
#   case foo
#   when 1 then 'baz'
#   when 2 then 'bar'
#   end
#
# source://rubocop//lib/rubocop/cop/style/when_then.rb#20
class RuboCop::Cop::Style::WhenThen < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/when_then.rb#29
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/when_then.rb#23
  def on_when(node); end
end

# source://rubocop//lib/rubocop/cop/style/when_then.rb#21
RuboCop::Cop::Style::WhenThen::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of `do` in multi-line `while/until` statements.
#
# @example
#
#   # bad
#   while x.any? do
#   do_something(x.pop)
#   end
#
#   # good
#   while x.any?
#   do_something(x.pop)
#   end
# @example
#
#   # bad
#   until x.empty? do
#   do_something(x.pop)
#   end
#
#   # good
#   until x.empty?
#   do_something(x.pop)
#   end
#
# source://rubocop//lib/rubocop/cop/style/while_until_do.rb#31
class RuboCop::Cop::Style::WhileUntilDo < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#49
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#42
  def handle(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#38
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#34
  def on_while(node); end
end

# source://rubocop//lib/rubocop/cop/style/while_until_do.rb#32
RuboCop::Cop::Style::WhileUntilDo::MSG = T.let(T.unsafe(nil), String)

# Checks for while and until statements that would fit on one line
# if written as a modifier while/until. The maximum line length is
# configured in the `Metrics/LineLength` cop.
#
# @example
#   # bad
#   while x < 10
#   x += 1
#   end
#
#   # good
#   x += 1 while x < 10
# @example
#   # bad
#   until x > 10
#   x += 1
#   end
#
#   # good
#   x += 1 until x > 10
#
# source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#27
class RuboCop::Cop::Style::WhileUntilModifier < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::StatementModifier

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#41
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#37
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#33
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#52
  def check(node); end
end

# source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#30
RuboCop::Cop::Style::WhileUntilModifier::MSG = T.let(T.unsafe(nil), String)

# This cop can check for array literals made up of word-like
# strings, that are not using the %w() syntax.
#
# Alternatively, it can check for uses of the %w() syntax, in projects
# which do not want to include that syntax.
#
# Configuration option: MinSize
# If set, arrays with fewer elements than this value will not trigger the
# cop. For example, a `MinSize` of `3` will not enforce a style on an
# array of 2 or fewer elements.
#
# @example EnforcedStyle: percent (default)
#   # good
#   %w[foo bar baz]
#
#   # bad
#   ['foo', 'bar', 'baz']
# @example EnforcedStyle: brackets
#   # good
#   ['foo', 'bar', 'baz']
#
#   # bad
#   %w[foo bar baz]
#
# source://rubocop//lib/rubocop/cop/style/word_array.rb#30
class RuboCop::Cop::Style::WordArray < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#53
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#43
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#65
  def check_bracketed_array(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/word_array.rb#72
  def complex_content?(strings); end

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#84
  def correct_bracketed(node); end

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#80
  def word_regex; end

  class << self
    # Returns the value of attribute largest_brackets.
    #
    # source://rubocop//lib/rubocop/cop/style/word_array.rb#40
    def largest_brackets; end

    # Sets the attribute largest_brackets
    #
    # @param value the value to set the attribute largest_brackets to.
    #
    # source://rubocop//lib/rubocop/cop/style/word_array.rb#40
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/style/word_array.rb#37
RuboCop::Cop::Style::WordArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/word_array.rb#36
RuboCop::Cop::Style::WordArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

# This cop can either enforce or forbid Yoda conditions,
# i.e. comparison operations where the order of expression is reversed.
# eg. `5 == x`
#
# @example EnforcedStyle: forbid_for_all_comparison_operators (default)
#   # bad
#   99 == foo
#   "bar" != foo
#   42 >= foo
#   10 < bar
#
#   # good
#   foo == 99
#   foo == "bar"
#   foo <= 42
#   bar > 10
# @example EnforcedStyle: forbid_for_equality_operators_only
#   # bad
#   99 == foo
#   "bar" != foo
#
#   # good
#   99 >= foo
#   3 < a && a < 5
# @example EnforcedStyle: require_for_all_comparison_operators
#   # bad
#   foo == 99
#   foo == "bar"
#   foo <= 42
#   bar > 10
#
#   # good
#   99 == foo
#   "bar" != foo
#   42 >= foo
#   10 < bar
# @example EnforcedStyle: require_for_equality_operators_only
#   # bad
#   99 >= foo
#   3 < a && a < 5
#
#   # good
#   99 == foo
#   "bar" != foo
#
# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#53
class RuboCop::Cop::Style::YodaCondition < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#77
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#70
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#118
  def actual_code_range(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#113
  def corrected_code(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#85
  def enforce_yoda?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#90
  def equality_only?; end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#109
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#128
  def non_equality_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#133
  def noncommutative_operator?(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#124
  def reverse_comparison(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#100
  def valid_yoda?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#95
  def yoda_compatible_condition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#66
RuboCop::Cop::Style::YodaCondition::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#57
RuboCop::Cop::Style::YodaCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#68
RuboCop::Cop::Style::YodaCondition::NONCOMMUTATIVE_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#59
RuboCop::Cop::Style::YodaCondition::REVERSE_COMPARISON = T.let(T.unsafe(nil), Hash)

# This cop checks for numeric comparisons that can be replaced
# by a predicate method, such as receiver.length == 0,
# receiver.length > 0, receiver.length != 0,
# receiver.length < 1 and receiver.size == 0 that can be
# replaced by receiver.empty? and !receiver.empty.
#
# @example
#   # bad
#   [1, 2, 3].length == 0
#   0 == "foobar".length
#   array.length < 1
#   {a: 1, b: 2}.length != 0
#   string.length > 0
#   hash.size > 0
#
#   # good
#   [1, 2, 3].empty?
#   "foobar".empty?
#   array.empty?
#   !{a: 1, b: 2}.empty?
#   !string.empty?
#   !hash.empty?
#
# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#28
class RuboCop::Cop::Style::ZeroLengthPredicate < ::RuboCop::Cop::Cop
  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#38
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#110
  def non_polymorphic_collection?(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#83
  def nonzero_length_predicate(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#33
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#102
  def other_receiver(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#76
  def zero_length_predicate(node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#95
  def zero_length_receiver(node = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#61
  def check_nonzero_length_predicate(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#46
  def check_zero_length_predicate(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#88
  def replacement(node); end
end

# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#30
RuboCop::Cop::Style::ZeroLengthPredicate::NONZERO_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#29
RuboCop::Cop::Style::ZeroLengthPredicate::ZERO_MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking and correcting surrounding whitespace.
#
# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#6
module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#121
  def empty_brackets?(left_bracket_token, right_bracket_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#116
  def empty_offense(node, range, message, command); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#106
  def empty_offenses(node, left, right, message); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#84
  def extra_space?(token, side); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#31
  def index_of_first_token(node); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#36
  def index_of_last_token(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#139
  def no_space_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#56
  def no_space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#131
  def offending_empty_no_space?(config, left_token, right_token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#127
  def offending_empty_space?(config, left_token, right_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#94
  def reposition(src, pos, step); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#14
  def side_space_range(range:, side:); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#135
  def space_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#100
  def space_offense(node, token, side, message, command); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#70
  def space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#45
  def token_table; end
end

# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#9
RuboCop::Cop::SurroundingSpace::NO_SPACE_COMMAND = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#10
RuboCop::Cop::SurroundingSpace::SPACE_COMMAND = T.let(T.unsafe(nil), String)

# Common functionality for checking target rails version.
#
# source://rubocop//lib/rubocop/cop/mixin/target_rails_version.rb#6
module RuboCop::Cop::TargetRailsVersion
  # source://rubocop//lib/rubocop/cop/mixin/target_rails_version.rb#7
  def minimum_target_rails_version(version); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/target_rails_version.rb#11
  def support_target_rails_version?(version); end
end

# Common functionality for checking target ruby version.
#
# source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#6
module RuboCop::Cop::TargetRubyVersion
  # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#7
  def minimum_target_ruby_version(version); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#11
  def support_target_ruby_version?(version); end
end

# FIXME
#
# source://rubocop//lib/rubocop/cop/team.rb#6
class RuboCop::Cop::Team
  # @return [Team] a new instance of Team
  #
  # source://rubocop//lib/rubocop/cop/team.rb#18
  def initialize(cop_classes, config, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/team.rb#68
  def autocorrect(buffer, cops); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#28
  def autocorrect?; end

  # source://rubocop//lib/rubocop/cop/team.rb#47
  def cops; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#32
  def debug?; end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#14
  def errors; end

  # source://rubocop//lib/rubocop/cop/team.rb#55
  def forces; end

  # source://rubocop//lib/rubocop/cop/team.rb#59
  def forces_for(cops); end

  # source://rubocop//lib/rubocop/cop/team.rb#36
  def inspect_file(processed_source); end

  # Returns the value of attribute updated_source_file.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#14
  def updated_source_file; end

  # Returns the value of attribute updated_source_file.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#14
  def updated_source_file?; end

  # Returns the value of attribute warnings.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#14
  def warnings; end

  private

  # source://rubocop//lib/rubocop/cop/team.rb#122
  def autocorrect_all_cops(buffer, cops); end

  # source://rubocop//lib/rubocop/cop/team.rb#134
  def collate_corrections(corrector, cops); end

  # source://rubocop//lib/rubocop/cop/team.rb#177
  def handle_error(error, location, cop); end

  # source://rubocop//lib/rubocop/cop/team.rb#169
  def handle_warning(error, location); end

  # @yield [offenses]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#112
  def investigate(cops, processed_source); end

  # source://rubocop//lib/rubocop/cop/team.rb#88
  def offenses(processed_source); end

  # source://rubocop//lib/rubocop/cop/team.rb#152
  def process_commissioner_errors(file, file_errors); end

  # source://rubocop//lib/rubocop/cop/team.rb#146
  def validate_config; end
end

# source://rubocop//lib/rubocop/cop/team.rb#7
RuboCop::Cop::Team::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/team.rb#12
class RuboCop::Cop::Team::Investigation < ::Struct
  # Returns the value of attribute errors
  #
  # @return [Object] the current value of errors
  def errors; end

  # Sets the attribute errors
  #
  # @param value [Object] the value to set the attribute errors to.
  # @return [Object] the newly set value
  def errors=(_); end

  # Returns the value of attribute offenses
  #
  # @return [Object] the current value of offenses
  def offenses; end

  # Sets the attribute offenses
  #
  # @param value [Object] the value to set the attribute offenses to.
  # @return [Object] the newly set value
  def offenses=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Common functionality for checking for too many lines.
#
# source://rubocop//lib/rubocop/cop/mixin/too_many_lines.rb#6
module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength

  private

  # source://rubocop//lib/rubocop/cop/mixin/too_many_lines.rb#18
  def code_length(node); end

  # source://rubocop//lib/rubocop/cop/mixin/too_many_lines.rb#25
  def extract_body(node); end

  # source://rubocop//lib/rubocop/cop/mixin/too_many_lines.rb#14
  def message(length, max_length); end
end

# source://rubocop//lib/rubocop/cop/mixin/too_many_lines.rb#10
RuboCop::Cop::TooManyLines::MSG = T.let(T.unsafe(nil), String)

# Common methods shared by TrailingBody cops
#
# source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#6
module RuboCop::Cop::TrailingBody
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#13
  def body_on_first_line?(node, body); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#17
  def first_part_of(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#7
  def trailing_body?(node); end
end

# Common methods shared by Style/TrailingCommaInArguments and
# Style/TrailingCommaInLiteral
#
# source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#7
module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # A single argument with the closing bracket on the same line as the end
  # of the argument is not considered multiline, even if the argument
  # itself might span multiple lines.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#102
  def allowed_multiline_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#172
  def any_heredoc?(items); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#159
  def autocorrect_range(item); end

  # By default, there's no reason to avoid auto-correct.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#168
  def avoid_autocorrect?(_nodes); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#131
  def avoid_comma(kind, comma_begin_pos, extra_info); end

  # Returns true if the node has round/square/curly brackets.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#82
  def brackets?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#19
  def check(node, items, kind, begin_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#35
  def check_comma(node, kind, comma_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#41
  def check_literal(node, kind); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#106
  def elements(node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#52
  def extra_avoid_comma_info; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#176
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#196
  def heredoc_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#74
  def inside_comment?(range, comma_offset); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#93
  def method_name_and_arguments_on_same_line?(node); end

  # Returns true if the round/square/curly brackets of the given node are
  # on different lines, each item within is on its own line, and the
  # closing bracket is on its own line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#89
  def multiline?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#121
  def no_elements_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#127
  def on_same_line?(range1, range2); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#143
  def put_comma(node, items, kind); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#63
  def should_have_comma?(style, node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#15
  def style_parameter_name; end
end

# source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#11
RuboCop::Cop::TrailingComma::MSG = T.let(T.unsafe(nil), String)

# Common functionality shared by Uncommunicative cops
#
# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#6
module RuboCop::Cop::UncommunicativeName
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#14
  def check(node, args); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#97
  def allow_nums; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#89
  def allowed_names; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#74
  def arg_range(arg, length); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#36
  def case_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#59
  def ends_with_num?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#93
  def forbidden_names; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#81
  def forbidden_offense(node, range, name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#27
  def issue_offenses(node, range, name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#63
  def length_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#70
  def long_enough?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#101
  def min_length; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#45
  def name_type(node); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#54
  def num_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#41
  def uppercase?(name); end
end

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#7
RuboCop::Cop::UncommunicativeName::CASE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#11
RuboCop::Cop::UncommunicativeName::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#9
RuboCop::Cop::UncommunicativeName::LENGTH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#8
RuboCop::Cop::UncommunicativeName::NUM_MSG = T.let(T.unsafe(nil), String)

# This auto-corrects unused arguments.
#
# source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#6
class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#12
    def correct(processed_source, node); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#10
    def processed_source; end
  end
end

# This module contains a collection of useful utility methods.
#
# source://rubocop//lib/rubocop/cop/util.rb#6
module RuboCop::Cop::Util
  include ::RuboCop::PathUtil

  private

  # source://rubocop//lib/rubocop/cop/util.rb#38
  def begins_its_line?(range); end

  # source://rubocop//lib/rubocop/cop/util.rb#16
  def comment_line?(line_source); end

  # source://rubocop//lib/rubocop/cop/util.rb#123
  def compatible_external_encoding_for?(src); end

  # If converting a string to Ruby string literal source code, must
  # double quotes be used?
  #
  # source://rubocop//lib/rubocop/cop/util.rb#62
  def double_quotes_required?(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#76
  def escape_string(string); end

  # Returns, for example, a bare `if` node if the given node is an `if`
  # with calls chained to the end of it.
  #
  # source://rubocop//lib/rubocop/cop/util.rb#44
  def first_part_of_call_chain(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#92
  def interpret_string_escapes(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#20
  def line_range(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#72
  def needs_escaping?(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#29
  def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/util.rb#24
  def parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#96
  def same_line?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/util.rb#80
  def to_string_literal(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#102
  def to_supported_styles(enforced_style); end

  # source://rubocop//lib/rubocop/cop/util.rb#108
  def tokens(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#88
  def trim_string_interporation_escape_character(str); end

  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#38
    def begins_its_line?(range); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#16
    def comment_line?(line_source); end

    # If converting a string to Ruby string literal source code, must
    # double quotes be used?
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#62
    def double_quotes_required?(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#76
    def escape_string(string); end

    # Returns, for example, a bare `if` node if the given node is an `if`
    # with calls chained to the end of it.
    #
    # source://rubocop//lib/rubocop/cop/util.rb#44
    def first_part_of_call_chain(node); end

    # source://rubocop//lib/rubocop/cop/util.rb#92
    def interpret_string_escapes(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#20
    def line_range(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#72
    def needs_escaping?(string); end

    # @yield [sexp]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#29
    def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#24
    def parentheses?(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#96
    def same_line?(node1, node2); end

    # source://rubocop//lib/rubocop/cop/util.rb#80
    def to_string_literal(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#102
    def to_supported_styles(enforced_style); end

    # source://rubocop//lib/rubocop/cop/util.rb#108
    def tokens(node); end

    # source://rubocop//lib/rubocop/cop/util.rb#88
    def trim_string_interporation_escape_character(str); end
  end
end

# Match literal regex characters, not including anchors, character
# classes, alternatives, groups, repetitions, references, etc
#
# source://rubocop//lib/rubocop/cop/util.rb#11
RuboCop::Cop::Util::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

# This force provides a way to track local variables and scopes of Ruby.
# Cops interact with this force need to override some of the hook methods.
#
#     def before_entering_scope(scope, variable_table)
#     end
#
#     def after_entering_scope(scope, variable_table)
#     end
#
#     def before_leaving_scope(scope, variable_table)
#     end
#
#     def after_leaving_scope(scope, variable_table)
#     end
#
#     def before_declaring_variable(variable, variable_table)
#     end
#
#     def after_declaring_variable(variable, variable_table)
#     end
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#25
class RuboCop::Cop::VariableForce < ::RuboCop::Cop::Force
  # Starting point.
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#75
  def investigate(processed_source); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#84
  def process_node(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#70
  def variable_table; end

  private

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def after_declaring_variable(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def after_entering_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def after_leaving_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def before_declaring_variable(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def before_entering_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#393
  def before_leaving_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#359
  def descendant_reference(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#349
  def each_descendant_reference(loop_node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#334
  def find_variables_in_loop(loop_node); end

  # This is called for each scope recursively.
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#93
  def inspect_variables_in_scope(scope_node); end

  # Mark all assignments which are referenced in the same loop
  # as referenced by ignoring AST order since they would be referenced
  # in next iteration.
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#314
  def mark_assignments_as_referenced_in_loop(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#112
  def node_handler_method_name(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#99
  def process_children(origin_node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#250
  def process_loop(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#172
  def process_regexp_named_captures(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#265
  def process_rescue(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#284
  def process_scope(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#301
  def process_send(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#152
  def process_variable_assignment(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#140
  def process_variable_declaration(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#238
  def process_variable_multiple_assignment(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#200
  def process_variable_operator_assignment(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#245
  def process_variable_referencing(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#276
  def process_zero_arity_super(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#192
  def regexp_captured_names(node); end

  # Use Node#equal? for accurate check.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#374
  def scanned_node?(node); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#380
  def scanned_nodes; end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#107
  def skip_children!; end
end

# source://rubocop//lib/rubocop/cop/variable_force.rb#31
RuboCop::Cop::VariableForce::ARGUMENT_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

# This class represents each assignment of a variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#7
class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable

  # @return [Assignment] a new instance of Assignment
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#15
  def initialize(node, variable); end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#66
  def meta_assignment_node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#55
  def multiple_assignment?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#28
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def node; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#61
  def operator; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#49
  def operator_assignment?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#36
  def reference!(node); end

  # Returns the value of attribute referenced.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced; end

  # Returns the value of attribute referenced.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced?; end

  # Returns the value of attribute references.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def references; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#45
  def regexp_named_capture?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#32
  def scope; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#41
  def used?; end

  # Returns the value of attribute variable.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def variable; end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#85
  def multiple_assignment_node; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#77
  def operator_assignment_node; end
end

# source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#10
RuboCop::Cop::VariableForce::Assignment::MULTIPLE_LEFT_HAND_SIDE_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/variable_force.rb#64
class RuboCop::Cop::VariableForce::AssignmentReference < ::Struct
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#65
  def assignment?; end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Namespace for branch classes for each control structure.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#7
module RuboCop::Cop::VariableForce::Branch
  class << self
    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#8
    def of(target_node, scope: T.unsafe(nil)); end
  end
end

# left_body && right_body
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#256
class RuboCop::Cop::VariableForce::Branch::And < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def left_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def right_body?; end
end

# Abstract base class for branch classes.
# A branch represents a conditional branch in a scope.
#
# @example
#   def some_scope
#   do_something     # no branch
#
#   if foo
#   do_something   # branch A
#   do_something   # branch A
#   else
#   do_something   # branch B
#   if bar
#   do_something # branch C (whose parent is branch B)
#   end
#   end
#
#   do_something     # no branch
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#44
class RuboCop::Cop::VariableForce::Branch::Base < ::Struct
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#126
  def ==(other); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#97
  def always_run?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#93
  def branched?; end

  # Returns the value of attribute child_node
  #
  # @return [Object] the current value of child_node
  def child_node; end

  # Sets the attribute child_node
  #
  # @param value [Object] the value to set the attribute child_node to.
  # @return [Object] the newly set value
  def child_node=(_); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#73
  def control_node; end

  # @yield [_self]
  # @yieldparam _self [RuboCop::Cop::VariableForce::Branch::Base] the object that the method was called on
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#83
  def each_ancestor(include_self: T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#126
  def eql?(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#109
  def exclusive_with?(other); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#135
  def hash; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#101
  def may_jump_to_other_branch?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#105
  def may_run_incompletely?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#77
  def parent; end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#141
  def scan_ancestors; end

  class << self
    def [](*_arg0); end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#47
    def classes; end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#59
    def define_predicate(name, child_index: T.unsafe(nil)); end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#51
    def inherited(subclass); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#55
    def type; end
  end
end

# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#316
RuboCop::Cop::VariableForce::Branch::CLASSES_BY_TYPE = T.let(T.unsafe(nil), Hash)

# case target
# when /pattern/ # when_clause
# else
#   else_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#225
class RuboCop::Cop::VariableForce::Branch::Case < ::RuboCop::Cop::VariableForce::Branch::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#230
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def else_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def target?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def when_clause?; end
end

# begin
#     main_body
#   ensure
#     ensure_body
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#305
class RuboCop::Cop::VariableForce::Branch::Ensure < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#311
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def ensure_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def main_body?; end
end

# Mix-in module for exception handling control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#272
module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#273
  def may_jump_to_other_branch?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#277
  def may_run_incompletely?; end
end

# for element in collection
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#238
class RuboCop::Cop::VariableForce::Branch::For < ::RuboCop::Cop::VariableForce::Branch::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#243
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def collection?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def element?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def loop_body?; end
end

# if conditional_clause
#   truthy_body
# else
#   falsey_body
# end
#
# unless conditional_clause
#   falsey_body
# else
#   truthy_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#172
class RuboCop::Cop::VariableForce::Branch::If < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def falsey_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def truthy_body?; end
end

# Mix-in module for logical operator control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#249
module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#250
  def always_run?; end
end

# left_body || right_body
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#264
class RuboCop::Cop::VariableForce::Branch::Or < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def left_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def right_body?; end
end

# begin
#     main_body
#   rescue StandardError => error # rescue_clause
#   else
#     else_body
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#288
class RuboCop::Cop::VariableForce::Branch::Rescue < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#295
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def else_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def main_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def rescue_clause?; end
end

# Mix-in module for simple conditional control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#151
module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#156
  def always_run?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#152
  def conditional_clause?; end
end

# until conditional_clause
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#193
class RuboCop::Cop::VariableForce::Branch::Until < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def loop_body?; end
end

# begin
#   loop_body
# end until conditional_clause
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#213
class RuboCop::Cop::VariableForce::Branch::UntilPost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def loop_body?; end
end

# while conditional_clause
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#183
class RuboCop::Cop::VariableForce::Branch::While < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def loop_body?; end
end

# begin
#   loop_body
# end while conditional_clause
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#203
class RuboCop::Cop::VariableForce::Branch::WhilePost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#60
  def loop_body?; end
end

# Mix-in module for classes which own a node and need branch information
# of the node. The user classes must implement #node and #scope.
#
# source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#8
module RuboCop::Cop::VariableForce::Branchable
  # source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#9
  def branch; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#15
  def run_exclusively_with?(other); end
end

# source://rubocop//lib/rubocop/cop/variable_force.rb#38
RuboCop::Cop::VariableForce::LOGICAL_OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#47
RuboCop::Cop::VariableForce::LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#42
RuboCop::Cop::VariableForce::MULTIPLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/variable_force.rb#39
RuboCop::Cop::VariableForce::OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#46
RuboCop::Cop::VariableForce::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#27
RuboCop::Cop::VariableForce::REGEXP_NAMED_CAPTURE_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/variable_force.rb#49
RuboCop::Cop::VariableForce::RESCUE_TYPE = T.let(T.unsafe(nil), Symbol)

# This class represents each reference of a variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/reference.rb#7
class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable

  # @return [Reference] a new instance of Reference
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#18
  def initialize(node, scope); end

  # There's an implicit variable reference by the zero-arity `super`:
  #
  #     def some_method(foo)
  #       super
  #     end
  #
  # Another case is `binding`:
  #
  #     def some_method(foo)
  #       do_something(binding)
  #     end
  #
  # In these cases, the variable `foo` is not explicitly referenced,
  # but it can be considered used implicitly by the `super` or `binding`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#43
  def explicit?; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#16
  def node; end

  # Returns the value of attribute scope.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#16
  def scope; end
end

# source://rubocop//lib/rubocop/cop/variable_force/reference.rb#10
RuboCop::Cop::VariableForce::Reference::VARIABLE_REFERENCE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#54
RuboCop::Cop::VariableForce::SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#56
RuboCop::Cop::VariableForce::SEND_TYPE = T.let(T.unsafe(nil), Symbol)

# A Scope represents a context of local variable visibility.
# This is a place where local variables belong to.
# A scope instance holds a scope node and variable entries.
#
# source://rubocop//lib/rubocop/cop/variable_force/scope.rb#9
class RuboCop::Cop::VariableForce::Scope
  # @return [Scope] a new instance of Scope
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#21
  def initialize(node); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#35
  def ==(other); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#43
  def body_node; end

  # @yield [node]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#62
  def each_node(&block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#57
  def include?(target_node); end

  # Returns the value of attribute naked_top_level.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level; end

  # Returns the value of attribute naked_top_level.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level?; end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#39
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def node; end

  # Returns the value of attribute variables.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def variables; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#101
  def ancestor_node?(target_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#91
  def belong_to_inner_scope?(target_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#80
  def belong_to_outer_scope?(target_node); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#71
  def scan_node(node, &block); end
end

# source://rubocop//lib/rubocop/cop/variable_force/scope.rb#10
RuboCop::Cop::VariableForce::Scope::OUTER_SCOPE_CHILD_INDICES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/variable_force.rb#53
RuboCop::Cop::VariableForce::TWISTED_SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#26
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/variable_force.rb#28
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#44
RuboCop::Cop::VariableForce::VARIABLE_REFERENCE_TYPE = T.let(T.unsafe(nil), Symbol)

# A Variable represents existence of a local variable.
# This holds a variable declaration node and some states of the variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/variable.rb#8
class RuboCop::Cop::VariableForce::Variable
  # @return [Variable] a new instance of Variable
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#16
  def initialize(name, declaration_node, scope); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#82
  def argument?; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#32
  def assign(node); end

  # Returns the value of attribute assignments.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def assignments; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#90
  def block_argument?; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#62
  def capture_with_block!; end

  # Returns the value of attribute captured_by_block.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def captured_by_block; end

  # Returns the value of attribute captured_by_block.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def captured_by_block?; end

  # Returns the value of attribute declaration_node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def declaration_node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#98
  def explicit_block_local_variable?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#94
  def keyword_argument?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#86
  def method_argument?; end

  # Returns the value of attribute name.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def name; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#41
  def reference!(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#36
  def referenced?; end

  # Returns the value of attribute references.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def references; end

  # Returns the value of attribute scope.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#12
  def scope; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#78
  def should_be_unused?; end

  # This is a convenient way to check whether the variable is used
  # in its entire variable lifetime.
  # For more precise usage check, refer Assignment#used?.
  #
  # Once the variable is captured by a block, we have no idea
  # when, where, and how many times the block would be invoked.
  # This means we cannot track the usage of the variable.
  # So we consider it's used to suppress false positive offenses.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#74
  def used?; end
end

# source://rubocop//lib/rubocop/cop/variable_force/variable.rb#9
RuboCop::Cop::VariableForce::Variable::VARIABLE_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/variable_force.rb#58
class RuboCop::Cop::VariableForce::VariableReference < ::Struct
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#59
  def assignment?; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A VariableTable manages the lifetime of all scopes and local variables
# in a program.
# This holds scopes as stack structure, provides a way to add local
# variables to current scope, and find local variables by considering
# variable visibility of the current scope.
#
# source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#11
class RuboCop::Cop::VariableForce::VariableTable
  # @return [VariableTable] a new instance of VariableTable
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#12
  def initialize(hook_receiver = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#111
  def accessible_variables; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#56
  def assign_to_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#40
  def current_scope; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#44
  def current_scope_level; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#48
  def declare_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#94
  def find_variable(name); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#16
  def invoke_hook(hook_name, *args); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#32
  def pop_scope; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#24
  def push_scope(scope_node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#68
  def reference_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#20
  def scope_stack; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#107
  def variable_exist?(name); end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#120
  def mark_variable_as_captured_by_block_if_so(variable); end
end

# source://rubocop//lib/rubocop/cop/variable_force.rb#51
RuboCop::Cop::VariableForce::ZERO_ARITY_SUPER_TYPE = T.let(T.unsafe(nil), Symbol)

# An Error exception is different from an Offense with severity 'error'
# When this exception is raised, it means that RuboCop is unable to perform
# a requested action (probably due to misconfiguration) and must stop
# immediately, rather than carrying on
#
# source://rubocop//lib/rubocop/error.rb#8
class RuboCop::Error < ::StandardError; end

# Common methods for finding files.
#
# source://rubocop//lib/rubocop/file_finder.rb#7
module RuboCop::FileFinder
  # source://rubocop//lib/rubocop/file_finder.rb#16
  def find_file_upwards(filename, start_dir, use_home: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/file_finder.rb#23
  def find_files_upwards(filename, start_dir, use_home: T.unsafe(nil)); end

  private

  # @yield [file]
  #
  # source://rubocop//lib/rubocop/file_finder.rb#33
  def traverse_files_upwards(filename, start_dir, use_home); end

  class << self
    # source://rubocop//lib/rubocop/file_finder.rb#8
    def root_level=(level); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/file_finder.rb#12
    def root_level?(path); end
  end
end

# source://rubocop//lib/rubocop/formatter/base_formatter.rb#6
module RuboCop::Formatter; end

# Does not show individual offenses in the console.
#
# source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#6
class RuboCop::Formatter::AutoGenConfigFormatter < ::RuboCop::Formatter::ProgressFormatter
  # source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#7
  def finished(inspected_files); end
end

# Abstract base class for formatter, implements all public API methods.
#
# ## Creating Custom Formatter
#
# You can create a custom formatter by subclassing
# `RuboCop::Formatter::BaseFormatter` and overriding some methods
# or by implementing all the methods by duck typing.
#
# ## Using Custom Formatter in Command Line
#
# You can tell RuboCop to use your custom formatter with a combination of
# `--format` and `--require` option.
# For example, when you have defined `MyCustomFormatter` in
# `./path/to/my_custom_formatter.rb`, you would type this command:
#
#     rubocop --require ./path/to/my_custom_formatter --format MyCustomFormatter
#
# Note: The path passed to `--require` is directly passed to
# `Kernel.require`.
# If your custom formatter file is not in `$LOAD_PATH`,
# you need to specify the path as relative path prefixed with `./`
# explicitly or absolute path.
#
# ## Method Invocation Order
#
# For example, when RuboCop inspects 2 files,
# the invocation order should be like this:
#
# * `#initialize`
# * `#started`
# * `#file_started`
# * `#file_finished`
# * `#file_started`
# * `#file_finished`
# * `#finished`
#
# source://rubocop//lib/rubocop/formatter/base_formatter.rb#43
class RuboCop::Formatter::BaseFormatter
  # @api public
  # @param output [IO] `$stdout` or opened file
  # @return [BaseFormatter] a new instance of BaseFormatter
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#67
  def initialize(output, options = T.unsafe(nil)); end

  # Invoked at the end of inspecting each files.
  #
  # @api public
  # @param file [String] the file path
  # @param offenses [Array(RuboCop::Cop::Offense)] all detected offenses for the file
  # @return [void]
  # @see RuboCop::Cop::Offense
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#108
  def file_finished(file, offenses); end

  # Invoked at the beginning of inspecting each files.
  #
  # @api public
  # @param file [String] the file path
  # @param options [Hash] file specific information, currently this is always empty.
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#93
  def file_started(file, options); end

  # Invoked after all files are inspected or interrupted by user.
  #
  # @api public
  # @param inspected_files [Array(String)] the inspected file paths.
  #   This would be same as `target_files` passed to `#started`
  #   unless RuboCop is interrupted by user.
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#120
  def finished(inspected_files); end

  # @api public
  # @return [Hash]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#61
  def options; end

  # @api public
  # @return [IO] the IO object passed to `#initialize`
  # @see #initialize
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#54
  def output; end

  # Invoked once before any files are inspected.
  #
  # @api public
  # @param target_files [Array(String)] all target file paths to be inspected
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#80
  def started(target_files); end
end

# This formatter formats report data in clang style.
# The precise location of the problem is shown together with the
# relevant source code.
#
# source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#8
class RuboCop::Formatter::ClangStyleFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#11
  def report_file(file, offenses); end

  private

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#48
  def report_highlighted_area(highlighted_area); end

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#38
  def report_line(location); end

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#17
  def report_offense(file, offense); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#34
  def valid_line?(offense); end
end

# source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#9
RuboCop::Formatter::ClangStyleFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

# This mix-in module provides string coloring methods for terminals.
# It automatically disables coloring if coloring is disabled in the process
# globally or the formatter's output is not a terminal.
#
# source://rubocop//lib/rubocop/formatter/colorizable.rb#8
module RuboCop::Formatter::Colorizable
  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def black(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def blue(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#21
  def colorize(string, *args); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def cyan(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def green(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def magenta(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#9
  def rainbow; end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def red(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def white(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def yellow(string); end
end

# This formatter displays a YAML configuration file where all cops that
# detected any offenses are configured to not detect the offense.
#
# source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#7
class RuboCop::Formatter::DisabledConfigFormatter < ::RuboCop::Formatter::BaseFormatter
  # @return [DisabledConfigFormatter] a new instance of DisabledConfigFormatter
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#25
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#38
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#31
  def file_started(_file, _file_info); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#46
  def finished(_inspected_files); end

  private

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#59
  def command; end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#132
  def cop_config_params(default_cfg, cfg); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#154
  def default_config(cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#193
  def excludes(offending_files, cop_name, parent); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#85
  def output_cop(cop_name, offense_count); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#113
  def output_cop_comments(output_buffer, cfg, cop_name, offense_count); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#158
  def output_cop_config(output_buffer, cfg, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#139
  def output_cop_param_comments(output_buffer, params, default_cfg); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#183
  def output_exclude_list(output_buffer, offending_files, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#205
  def output_exclude_path(output_buffer, exclude_path, parent); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#172
  def output_offending_files(output_buffer, cfg, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#79
  def output_offenses; end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#99
  def set_max(cfg, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#75
  def timestamp; end

  class << self
    # Returns the value of attribute config_to_allow_offenses.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#22
    def config_to_allow_offenses; end

    # Sets the attribute config_to_allow_offenses
    #
    # @param value the value to set the attribute config_to_allow_offenses to.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#22
    def config_to_allow_offenses=(_arg0); end

    # Returns the value of attribute detected_styles.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#22
    def detected_styles; end

    # Sets the attribute detected_styles
    #
    # @param value the value to set the attribute detected_styles to.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#22
    def detected_styles=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#8
RuboCop::Formatter::DisabledConfigFormatter::HEADING = T.let(T.unsafe(nil), String)

# A basic formatter that displays the lines disabled
# inline comments.
#
# source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#7
class RuboCop::Formatter::DisabledLinesFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::Colorizable

  # Returns the value of attribute cop_disabled_line_ranges.
  #
  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#11
  def cop_disabled_line_ranges; end

  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#17
  def file_started(file, options); end

  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#24
  def finished(_inspected_files); end

  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#13
  def started(_target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#30
  def cops_disabled_in_comments_summary; end

  # source://rubocop//lib/rubocop/formatter/disabled_lines_formatter.rb#45
  def smart_path(path); end
end

# This formatter displays the report data in format that's
# easy to process in the Emacs text editor.
# The output is machine-parsable.
#
# source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#8
class RuboCop::Formatter::EmacsStyleFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#9
  def file_finished(file, offenses); end
end

# This formatter displays just a list of the files with offenses in them,
# separated by newlines. The output is machine-parsable.
#
# Here's the format:
#
# /some/file
# /some/other/file
#
# source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#12
class RuboCop::Formatter::FileListFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#13
  def file_finished(file, offenses); end
end

# This is a collection of formatters. A FormatterSet can hold multiple
# formatter instances and provides transparent formatter API methods
# which invoke same method of each formatters.
#
# source://rubocop//lib/rubocop/formatter/formatter_set.rb#10
class RuboCop::Formatter::FormatterSet < ::Array
  # @return [FormatterSet] a new instance of FormatterSet
  #
  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#36
  def initialize(options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#51
  def add_formatter(formatter_type, output_path = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#63
  def close_output_files; end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#46
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#40
  def file_started(file, options); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#31
  def finished(*args); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#31
  def started(*args); end

  private

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#82
  def builtin_formatter_class(specified_key); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#96
  def custom_formatter_class(specified_class_name); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#71
  def formatter_class(formatter_type); end
end

# source://rubocop//lib/rubocop/formatter/formatter_set.rb#11
RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTERS_FOR_KEYS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/formatter/formatter_set.rb#28
RuboCop::Formatter::FormatterSet::FORMATTER_APIS = T.let(T.unsafe(nil), Array)

# This formatter displays a progress bar and shows details of offenses as
# soon as they are detected.
# This is inspired by the Fuubar formatter for RSpec by Jeff Kreeftmeijer.
# https://github.com/jeffkreeftmeijer/fuubar
#
# source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#11
class RuboCop::Formatter::FuubarStyleFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # @return [FuubarStyleFormatter] a new instance of FuubarStyleFormatter
  #
  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#14
  def initialize(*output); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#51
  def count_stats(offenses); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#40
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#71
  def progressbar_color; end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#20
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#61
  def with_color; end
end

# source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#12
RuboCop::Formatter::FuubarStyleFormatter::RESET_SEQUENCE = T.let(T.unsafe(nil), String)

# This formatter saves the output as an html file.
#
# source://rubocop//lib/rubocop/formatter/html_formatter.rb#12
class RuboCop::Formatter::HTMLFormatter < ::RuboCop::Formatter::BaseFormatter
  # @return [HTMLFormatter] a new instance of HTMLFormatter
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#31
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#41
  def file_finished(file, offenses); end

  # Returns the value of attribute files.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#29
  def files; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#46
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#52
  def render_html; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#37
  def started(target_files); end

  # Returns the value of attribute summary.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#29
  def summary; end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#17
class RuboCop::Formatter::HTMLFormatter::Color < ::Struct
  # Returns the value of attribute alpha
  #
  # @return [Object] the current value of alpha
  def alpha; end

  # Sets the attribute alpha
  #
  # @param value [Object] the value to set the attribute alpha to.
  # @return [Object] the newly set value
  def alpha=(_); end

  # Returns the value of attribute blue
  #
  # @return [Object] the current value of blue
  def blue; end

  # Sets the attribute blue
  #
  # @param value [Object] the value to set the attribute blue to.
  # @return [Object] the newly set value
  def blue=(_); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#22
  def fade_out(amount); end

  # Returns the value of attribute green
  #
  # @return [Object] the current value of green
  def green; end

  # Sets the attribute green
  #
  # @param value [Object] the value to set the attribute green to.
  # @return [Object] the newly set value
  def green=(_); end

  # Returns the value of attribute red
  #
  # @return [Object] the current value of red
  def red; end

  # Sets the attribute red
  #
  # @param value [Object] the value to set the attribute red to.
  # @return [Object] the newly set value
  def red=(_); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#18
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#13
RuboCop::Formatter::HTMLFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

# This class provides helper methods used in the ERB template.
#
# source://rubocop//lib/rubocop/formatter/html_formatter.rb#70
class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil

  # @return [ERBContext] a new instance of ERBContext
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#87
  def initialize(files, summary); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#134
  def base64_encoded_logo_image; end

  # Make Kernel#binding public.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#93
  def binding; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#97
  def decorated_message(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#130
  def escape(string); end

  # Returns the value of attribute files.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#85
  def files; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#103
  def highlighted_source_line(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#110
  def hightlight_source_tag(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#126
  def possible_ellipses(location); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#121
  def source_after_highlight(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#116
  def source_before_highlight(offense); end

  # Returns the value of attribute summary.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#85
  def summary; end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#82
RuboCop::Formatter::HTMLFormatter::ERBContext::LOGO_IMAGE_PATH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#74
RuboCop::Formatter::HTMLFormatter::ERBContext::SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#14
RuboCop::Formatter::HTMLFormatter::TEMPLATE_PATH = T.let(T.unsafe(nil), String)

# This formatter formats the report data in JSON format.
#
# source://rubocop//lib/rubocop/formatter/json_formatter.rb#9
class RuboCop::Formatter::JSONFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  # @return [JSONFormatter] a new instance of JSONFormatter
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#14
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#27
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#32
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#47
  def hash_for_file(file, offenses); end

  # TODO: Consider better solution for Offense#real_column.
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#65
  def hash_for_location(offense); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#54
  def hash_for_offense(offense); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#37
  def metadata_hash; end

  # Returns the value of attribute output_hash.
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#12
  def output_hash; end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#23
  def started(target_files); end
end

# This formatter displays the list of offended cops with a count of how
# many offenses of their kind were found. Ordered by desc offense count
#
# Here's the format:
#
# 26  LineLength
# 3   OneLineConditional
# --
# 29  Total
#
# source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#14
class RuboCop::Formatter::OffenseCountFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#38
  def file_finished(_file, offenses); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#43
  def finished(_inspected_files); end

  # Returns the value of attribute offense_counts.
  #
  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#15
  def offense_counts; end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#65
  def ordered_offense_counts(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#48
  def report_summary(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#17
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#69
  def total_offense_count(offense_counts); end
end

# This formatter display dots for files with no offenses and
# letters for files with problems in the them. In the end it
# appends the regular report data in the clang style format.
#
# source://rubocop//lib/rubocop/formatter/progress_formatter.rb#8
class RuboCop::Formatter::ProgressFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  # @return [ProgressFormatter] a new instance of ProgressFormatter
  #
  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#13
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#33
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#51
  def report_file_as_mark(offenses); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#18
  def started(target_files); end
end

# source://rubocop//lib/rubocop/formatter/progress_formatter.rb#11
RuboCop::Formatter::ProgressFormatter::DOT = T.let(T.unsafe(nil), String)

# If no offenses are found, no output is displayed.
# Otherwise, SimpleTextFormatter's output is displayed.
#
# source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#7
class RuboCop::Formatter::QuietFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#8
  def report_summary(file_count, offense_count, correction_count); end
end

# A basic formatter that displays only files with offenses.
# Offenses are displayed at compact form - just the
# location of the problem and the associated message.
#
# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#11
class RuboCop::Formatter::SimpleTextFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#28
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#35
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#41
  def report_file(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#51
  def report_summary(file_count, offense_count, correction_count); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#23
  def started(_target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#73
  def annotate_message(msg); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#68
  def colored_severity_code(offense); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#63
  def count_stats(offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#77
  def message(offense); end
end

# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#15
RuboCop::Formatter::SimpleTextFormatter::COLOR_FOR_SEVERITY = T.let(T.unsafe(nil), Hash)

# A helper class for building the report summary text.
#
# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#83
class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil

  # @return [Report] a new instance of Report
  #
  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#87
  def initialize(file_count, offense_count, correction_count, rainbow); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#94
  def summary; end

  private

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#117
  def corrections; end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#106
  def files; end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#110
  def offenses; end

  # Returns the value of attribute rainbow.
  #
  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#104
  def rainbow; end
end

# This formatter formats report data using the Test Anything Protocol.
# TAP allows for to communicate tests results in a language agnostics way.
#
# source://rubocop//lib/rubocop/formatter/tap_formatter.rb#7
class RuboCop::Formatter::TapFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#14
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#8
  def started(target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#61
  def annotate_message(msg); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#65
  def message(offense); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#39
  def report_highlighted_area(highlighted_area); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#29
  def report_line(location); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#44
  def report_offense(file, offense); end
end

# Common logic for UI texts.
#
# source://rubocop//lib/rubocop/formatter/text_util.rb#6
module RuboCop::Formatter::TextUtil
  private

  # source://rubocop//lib/rubocop/formatter/text_util.rb#9
  def pluralize(number, thing, options = T.unsafe(nil)); end

  class << self
    # source://rubocop//lib/rubocop/formatter/text_util.rb#9
    def pluralize(number, thing, options = T.unsafe(nil)); end
  end
end

# This formatter displays the list of offensive files, sorted by number of
# offenses with the worst offenders first.
#
# Here's the format:
#
# 26  this/file/is/really/bad.rb
# 3   just/ok.rb
# --
# 29  Total
#
# source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#16
class RuboCop::Formatter::WorstOffendersFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#31
  def finished(_inspected_files); end

  # Returns the value of attribute offense_counts.
  #
  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#17
  def offense_counts; end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#53
  def ordered_offense_counts(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#36
  def report_summary(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#19
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#57
  def total_offense_count(offense_counts); end
end

# source://rubocop//lib/rubocop/options.rb#7
class RuboCop::IncorrectCopNameError < ::StandardError; end

# Parse different formats of magic comments.
#
# @abstract parent of three different magic comment handlers
#
# source://rubocop//lib/rubocop/magic_comment.rb#7
class RuboCop::MagicComment
  # @return [MagicComment] a new instance of MagicComment
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#25
  def initialize(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#29
  def any?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#68
  def encoding_specified?; end

  # Expose the `frozen_string_literal` value coerced to a boolean if possible.
  #
  # @return [Boolean] if value is `true` or `false`
  # @return [nil] if frozen_string_literal comment isn't found
  # @return [String] if comment is found but isn't true or false
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#57
  def frozen_string_literal; end

  # Does the magic comment enable the frozen string literal feature.
  #
  # Test whether the frozen string literal value is `true`. Cannot
  # just return `frozen_string_literal` since an invalid magic comment
  # `'yes'` does not actually enable the feature
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#41
  def frozen_string_literal?; end

  # Was a magic comment for the frozen string literal found?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#48
  def frozen_string_literal_specified?; end

  private

  # Match the entire comment string with a pattern and take the first capture.
  #
  # @param pattern [Regexp]
  # @return [String] if pattern matched
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#84
  def extract(pattern); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#74
  def specified?(value); end

  class << self
    # Detect magic comment format and pass it to the appropriate wrapper.
    #
    # @param comment [String]
    # @return [RuboCop::MagicComment]
    #
    # source://rubocop//lib/rubocop/magic_comment.rb#16
    def parse(comment); end
  end
end

# Parent to Vim and Emacs magic comment handling.
#
# @abstract
#
# source://rubocop//lib/rubocop/magic_comment.rb#91
class RuboCop::MagicComment::EditorComment < ::RuboCop::MagicComment
  private

  # Find a token starting with the provided keyword and extract its value.
  #
  # @param keyword [String]
  # @return [String] extracted value if it is found
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#100
  def match(keyword); end

  # Individual tokens composing an editor specific comment string.
  #
  # @return [Array<String>]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#115
  def tokens; end
end

# Wrapper for Emacs style magic comments.
#
# @example Emacs style comment
#   comment = RuboCop::MagicComment.parse(
#   '# -*- encoding: ASCII-8BIT -*-'
#   )
#
#   comment.encoding # => 'ascii-8bit'
# @see https://www.gnu.org/software/emacs/manual/html_node/emacs/Specify-Coding.html
# @see https://git.io/vMCXh Emacs handling in Ruby's parse.y
#
# source://rubocop//lib/rubocop/magic_comment.rb#131
class RuboCop::MagicComment::EmacsComment < ::RuboCop::MagicComment::EditorComment
  # source://rubocop//lib/rubocop/magic_comment.rb#136
  def encoding; end

  private

  # source://rubocop//lib/rubocop/magic_comment.rb#142
  def extract_frozen_string_literal; end
end

# source://rubocop//lib/rubocop/magic_comment.rb#132
RuboCop::MagicComment::EmacsComment::FORMAT = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/magic_comment.rb#134
RuboCop::MagicComment::EmacsComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#133
RuboCop::MagicComment::EmacsComment::SEPARATOR = T.let(T.unsafe(nil), String)

# Wrapper for regular magic comments not bound to an editor.
#
# Simple comments can only specify one setting per comment.
#
# @example frozen string literal comments
#   comment1 = RuboCop::MagicComment.parse('# frozen_string_literal: true')
#   comment1.frozen_string_literal # => true
#   comment1.encoding              # => nil
# @example encoding comments
#   comment2 = RuboCop::MagicComment.parse('# encoding: utf-8')
#   comment2.frozen_string_literal # => nil
#   comment2.encoding              # => 'utf-8'
#
# source://rubocop//lib/rubocop/magic_comment.rb#190
class RuboCop::MagicComment::SimpleComment < ::RuboCop::MagicComment
  # Match `encoding` or `coding`
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#192
  def encoding; end

  private

  # Extract `frozen_string_literal`.
  #
  # The `frozen_string_literal` magic comment only works if it
  # is the only text in the comment.
  #
  # Case-insensitive and dashes/underscores are acceptable.
  #
  # @see https://git.io/vM7Mg
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#205
  def extract_frozen_string_literal; end
end

# @see https://git.io/vMC1C IRB's pattern for matching magic comment tokens
#
# source://rubocop//lib/rubocop/magic_comment.rb#9
RuboCop::MagicComment::TOKEN = T.let(T.unsafe(nil), Regexp)

# Wrapper for Vim style magic comments.
#
# @example Vim style comment
#   comment = RuboCop::MagicComment.parse(
#   '# vim: filetype=ruby, fileencoding=ascii-8bit'
#   )
#
#   comment.encoding # => 'ascii-8bit'
#
# source://rubocop//lib/rubocop/magic_comment.rb#155
class RuboCop::MagicComment::VimComment < ::RuboCop::MagicComment::EditorComment
  # For some reason the fileencoding keyword only works if there
  # is at least one other token included in the string. For example
  #
  #    # works
  #      # vim: foo=bar, fileencoding=ascii-8bit
  #
  #    # does nothing
  #      # vim: foo=bar, fileencoding=ascii-8bit
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#169
  def encoding; end

  # Vim comments cannot specify frozen string literal behavior.
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#174
  def frozen_string_literal; end
end

# source://rubocop//lib/rubocop/magic_comment.rb#156
RuboCop::MagicComment::VimComment::FORMAT = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/magic_comment.rb#158
RuboCop::MagicComment::VimComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#157
RuboCop::MagicComment::VimComment::SEPARATOR = T.let(T.unsafe(nil), String)

# Common functionality for finding names that are similar to a given name.
#
# source://rubocop//lib/rubocop/name_similarity.rb#5
module RuboCop::NameSimilarity
  # source://rubocop//lib/rubocop/name_similarity.rb#8
  def find_similar_name(target_name, scope); end
end

# source://rubocop//lib/rubocop/name_similarity.rb#6
RuboCop::NameSimilarity::MINIMUM_SIMILARITY_TO_SUGGEST = T.let(T.unsafe(nil), Float)

# This class performs a pattern-matching operation on an AST node.
#
# Initialize a new `NodePattern` with `NodePattern.new(pattern_string)`, then
# pass an AST node to `NodePattern#match`. Alternatively, use one of the class
# macros in `NodePattern::Macros` to define your own pattern-matching method.
#
# If the match fails, `nil` will be returned. If the match succeeds, the
# return value depends on whether a block was provided to `#match`, and
# whether the pattern contained any "captures" (values which are extracted
# from a matching AST.)
#
# - With block: #match yields the captures (if any) and passes the return
#               value of the block through.
# - With no block, but one capture: the capture is returned.
# - With no block, but multiple captures: captures are returned as an array.
# - With no block and no captures: #match returns `true`.
#
# ## Pattern string format examples
#
#     ':sym'              # matches a literal symbol
#     '1'                 # matches a literal integer
#     'nil'               # matches a literal nil
#     'send'              # matches (send ...)
#     '(send)'            # matches (send)
#     '(send ...)'        # matches (send ...)
#     '(op-asgn)'         # node types with hyphenated names also work
#     '{send class}'      # matches (send ...) or (class ...)
#     '({send class})'    # matches (send) or (class)
#     '(send const)'      # matches (send (const ...))
#     '(send _ :new)'     # matches (send <anything> :new)
#     '(send $_ :new)'    # as above, but whatever matches the $_ is captured
#     '(send $_ $_)'      # you can use as many captures as you want
#     '(send !const ...)' # ! negates the next part of the pattern
#     '$(send const ...)' # arbitrary matching can be performed on a capture
#     '(send _recv _msg)' # wildcards can be named (for readability)
#     '(send ... :new)'   # you can match against the last children
#     '(send $...)'       # capture all the children as an array
#     '(send $... int)'   # capture all children but the last as an array
#     '(send _x :+ _x)'   # unification is performed on named wildcards
#                         # (like Prolog variables...)
#                         # (#== is used to see if values unify)
#     '(int odd?)'        # words which end with a ? are predicate methods,
#                         # are are called on the target to see if it matches
#                         # any Ruby method which the matched object supports
#                         # can be used
#                         # if a truthy value is returned, the match succeeds
#     '(int [!1 !2])'     # [] contains multiple patterns, ALL of which must
#                         # match in that position
#                         # in other words, while {} is pattern union (logical
#                         # OR), [] is intersection (logical AND)
#     '(send %1 _)'       # % stands for a parameter which must be supplied to
#                         # #match at matching time
#                         # it will be compared to the corresponding value in
#                         # the AST using #==
#                         # a bare '%' is the same as '%1'
#                         # the number of extra parameters passed to #match
#                         # must equal the highest % value in the pattern
#                         # for consistency, %0 is the 'root node' which is
#                         # passed as the 1st argument to #match, where the
#                         # matching process starts
#     '^^send'            # each ^ ascends one level in the AST
#                         # so this matches against the grandparent node
#     '#method'           # we call this a 'funcall'; it calls a method in the
#                         # context where a pattern-matching method is defined
#                         # if that returns a truthy value, the match succeeds
#     'equal?(%1)'        # predicates can be given 1 or more extra args
#     '#method(%0, 1)'    # funcalls can also be given 1 or more extra args
#
# You can nest arbitrarily deep:
#
#     # matches node parsed from 'Const = Class.new' or 'Const = Module.new':
#     '(casgn nil? :Const (send (const nil? {:Class :Module}) :new))'
#     # matches a node parsed from an 'if', with a '==' comparison,
#     # and no 'else' branch:
#     '(if (send _ :== _) _ nil?)'
#
# Note that patterns like 'send' are implemented by calling `#send_type?` on
# the node being matched, 'const' by `#const_type?`, 'int' by `#int_type?`,
# and so on. Therefore, if you add methods which are named like
# `#prefix_type?` to the AST node class, then 'prefix' will become usable as
# a pattern.
#
# Also note that if you need a "guard clause" to protect against possible nils
# in a certain place in the AST, you can do it like this: `[!nil <pattern>]`
#
# The compiler code is very simple; don't be afraid to read through it!
#
# source://rubocop//lib/rubocop/node_pattern.rb#91
class RuboCop::NodePattern
  # @return [NodePattern] a new instance of NodePattern
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#550
  def initialize(str); end

  # source://rubocop//lib/rubocop/node_pattern.rb#573
  def ==(other); end

  # source://rubocop//lib/rubocop/node_pattern.rb#573
  def eql?(other); end

  # source://rubocop//lib/rubocop/node_pattern.rb#569
  def marshal_dump; end

  # source://rubocop//lib/rubocop/node_pattern.rb#565
  def marshal_load(pattern); end

  # source://rubocop//lib/rubocop/node_pattern.rb#558
  def match(*args); end

  # Returns the value of attribute pattern.
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#548
  def pattern; end

  # source://rubocop//lib/rubocop/node_pattern.rb#579
  def to_s; end
end

# Builds Ruby code which implements a pattern
#
# @private
#
# source://rubocop//lib/rubocop/node_pattern.rb#97
class RuboCop::NodePattern::Compiler
  # @return [Compiler] a new instance of Compiler
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#127
  def initialize(str, node_var = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/node_pattern.rb#392
  def compile_arg(token); end

  # source://rubocop//lib/rubocop/node_pattern.rb#382
  def compile_args(tokens); end

  # source://rubocop//lib/rubocop/node_pattern.rb#326
  def compile_ascend(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#317
  def compile_capture(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#234
  def compile_ellipsis(tokens, cur_node, terms, index, capture = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/node_pattern.rb#148
  def compile_expr(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#292
  def compile_expr_with_capture_check(tokens, temp_node, seq_head, before, after); end

  # @yield [expr, captures_before, @captures]
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#285
  def compile_expr_with_captures(tokens, temp_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#222
  def compile_expr_with_index(tokens, cur_node, index); end

  # source://rubocop//lib/rubocop/node_pattern.rb#361
  def compile_funcall(tokens, cur_node, method, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#192
  def compile_guard_clause(cur_node); end

  # source://rubocop//lib/rubocop/node_pattern.rb#303
  def compile_intersect(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#347
  def compile_literal(cur_node, literal, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#322
  def compile_negation(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#374
  def compile_nodetype(cur_node, type); end

  # source://rubocop//lib/rubocop/node_pattern.rb#378
  def compile_param(cur_node, number, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#351
  def compile_predicate(tokens, cur_node, predicate, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#176
  def compile_seq(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#246
  def compile_seq_tail(tokens, cur_node); end

  # source://rubocop//lib/rubocop/node_pattern.rb#196
  def compile_seq_terms(tokens, cur_node); end

  # source://rubocop//lib/rubocop/node_pattern.rb#208
  def compile_seq_terms_with_size(tokens, cur_node); end

  # source://rubocop//lib/rubocop/node_pattern.rb#258
  def compile_union(tokens, cur_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#331
  def compile_wildcard(cur_node, name, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#420
  def emit_capture_list; end

  # source://rubocop//lib/rubocop/node_pattern.rb#443
  def emit_method_code; end

  # source://rubocop//lib/rubocop/node_pattern.rb#434
  def emit_param_list; end

  # source://rubocop//lib/rubocop/node_pattern.rb#424
  def emit_retval; end

  # source://rubocop//lib/rubocop/node_pattern.rb#438
  def emit_trailing_params; end

  # @raise [Invalid]
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#450
  def fail_due_to(message); end

  # source://rubocop//lib/rubocop/node_pattern.rb#410
  def get_param(number); end

  # source://rubocop//lib/rubocop/node_pattern.rb#416
  def join_terms(init, terms, operator); end

  # Returns the value of attribute match_code.
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#123
  def match_code; end

  # source://rubocop//lib/rubocop/node_pattern.rb#406
  def next_capture; end

  # source://rubocop//lib/rubocop/node_pattern.rb#465
  def next_temp_value; end

  # source://rubocop//lib/rubocop/node_pattern.rb#139
  def run(node_var); end

  # source://rubocop//lib/rubocop/node_pattern.rb#267
  def union_terms(tokens, temp_node, seq_head); end

  # source://rubocop//lib/rubocop/node_pattern.rb#454
  def with_temp_node(cur_node); end

  # @yield ["temp#{next_temp_value}"]
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#461
  def with_temp_variable; end

  class << self
    # source://rubocop//lib/rubocop/node_pattern.rb#469
    def tokens(pattern); end
  end
end

# source://rubocop//lib/rubocop/node_pattern.rb#121
RuboCop::NodePattern::Compiler::CAPTURED_REST = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/node_pattern.rb#118
RuboCop::NodePattern::Compiler::CLOSING = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#115
RuboCop::NodePattern::Compiler::FUNCALL = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#99
RuboCop::NodePattern::Compiler::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#116
RuboCop::NodePattern::Compiler::LITERAL = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#100
RuboCop::NodePattern::Compiler::META = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#103
RuboCop::NodePattern::Compiler::METHOD_NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#112
RuboCop::NodePattern::Compiler::NODE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#101
RuboCop::NodePattern::Compiler::NUMBER = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#117
RuboCop::NodePattern::Compiler::PARAM = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#104
RuboCop::NodePattern::Compiler::PARAM_NUMBER = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#113
RuboCop::NodePattern::Compiler::PREDICATE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#120
RuboCop::NodePattern::Compiler::REST = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/node_pattern.rb#106
RuboCop::NodePattern::Compiler::SEPARATORS = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#125
RuboCop::NodePattern::Compiler::SEQ_HEAD_INDEX = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/node_pattern.rb#102
RuboCop::NodePattern::Compiler::STRING = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#98
RuboCop::NodePattern::Compiler::SYMBOL = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#110
RuboCop::NodePattern::Compiler::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#107
RuboCop::NodePattern::Compiler::TOKENS = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/node_pattern.rb#114
RuboCop::NodePattern::Compiler::WILDCARD = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://rubocop//lib/rubocop/node_pattern.rb#93
class RuboCop::NodePattern::Invalid < ::StandardError; end

# Helpers for defining methods based on a pattern string
#
# source://rubocop//lib/rubocop/node_pattern.rb#476
module RuboCop::NodePattern::Macros
  # Define a method which applies a pattern to an AST node
  #
  # The new method will return nil if the node does not match
  # If the node matches, and a block is provided, the new method will
  # yield to the block (passing any captures as block arguments).
  # If the node matches, and no block is provided, the new method will
  # return the captures, or `true` if there were none.
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#484
  def def_node_matcher(method_name, pattern_str); end

  # Define a method which recurses over the descendants of an AST node,
  # checking whether any of them match the provided pattern
  #
  # If the method name ends with '?', the new method will return `true`
  # as soon as it finds a descendant which matches. Otherwise, it will
  # yield all descendants which match.
  #
  # source://rubocop//lib/rubocop/node_pattern.rb#500
  def def_node_search(method_name, pattern_str); end

  # source://rubocop//lib/rubocop/node_pattern.rb#525
  def node_search(method_name, compiler, on_match, prelude, called_from); end

  # source://rubocop//lib/rubocop/node_pattern.rb#515
  def node_search_all(method_name, compiler, called_from); end

  # source://rubocop//lib/rubocop/node_pattern.rb#532
  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  # source://rubocop//lib/rubocop/node_pattern.rb#511
  def node_search_first(method_name, compiler, called_from); end
end

# source://rubocop//lib/rubocop/options.rb#8
class RuboCop::OptionArgumentError < ::StandardError; end

# This class handles command line options.
#
# source://rubocop//lib/rubocop/options.rb#11
class RuboCop::Options
  # @return [Options] a new instance of Options
  #
  # source://rubocop//lib/rubocop/options.rb#19
  def initialize; end

  # source://rubocop//lib/rubocop/options.rb#24
  def parse(command_line_args); end

  private

  # source://rubocop//lib/rubocop/options.rb#173
  def add_aliases(opts); end

  # source://rubocop//lib/rubocop/options.rb#105
  def add_auto_gen_options(opts); end

  # source://rubocop//lib/rubocop/options.rb#153
  def add_boolean_flags(opts); end

  # source://rubocop//lib/rubocop/options.rb#97
  def add_configuration_options(opts); end

  # source://rubocop//lib/rubocop/options.rb#84
  def add_cop_selection_csv_option(option, opts); end

  # source://rubocop//lib/rubocop/options.rb#147
  def add_flags_with_optional_args(opts); end

  # source://rubocop//lib/rubocop/options.rb#122
  def add_formatting_options(opts); end

  # source://rubocop//lib/rubocop/options.rb#188
  def add_list_options(opts); end

  # source://rubocop//lib/rubocop/options.rb#78
  def add_only_options(opts); end

  # source://rubocop//lib/rubocop/options.rb#137
  def add_severity_option(opts); end

  # source://rubocop//lib/rubocop/options.rb#54
  def args_from_env; end

  # source://rubocop//lib/rubocop/options.rb#46
  def args_from_file; end

  # source://rubocop//lib/rubocop/options.rb#58
  def define_options; end

  # Finds the option in `args` starting with -- and converts it to a symbol,
  # e.g. [..., '--auto-correct', ...] to :auto_correct.
  #
  # source://rubocop//lib/rubocop/options.rb#205
  def long_opt_symbol(args); end

  # Sets a value in the @options hash, based on the given long option and its
  # value, in addition to calling the block if a block is given.
  #
  # source://rubocop//lib/rubocop/options.rb#194
  def option(opts, *args); end
end

# source://rubocop//lib/rubocop/options.rb#17
RuboCop::Options::DEFAULT_MAXIMUM_EXCLUSION_ITEMS = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/options.rb#16
RuboCop::Options::EXITING_OPTIONS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/options.rb#12
RuboCop::Options::E_STDIN_NO_PATH = T.let(T.unsafe(nil), String)

# This module contains help texts for command line options.
#
# source://rubocop//lib/rubocop/options.rb#353
module RuboCop::OptionsHelp; end

# source://rubocop//lib/rubocop/options.rb#354
RuboCop::OptionsHelp::MAX_EXCL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/options.rb#355
RuboCop::OptionsHelp::TEXT = T.let(T.unsafe(nil), Hash)

# Validates option arguments and the options' compatibility with each other.
#
# source://rubocop//lib/rubocop/options.rb#213
class RuboCop::OptionsValidator
  # @return [OptionsValidator] a new instance of OptionsValidator
  #
  # source://rubocop//lib/rubocop/options.rb#251
  def initialize(options); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#335
  def boolean_or_empty_cache?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#326
  def display_only_fail_level_offenses_with_autocorrect?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#330
  def except_syntax?; end

  # source://rubocop//lib/rubocop/options.rb#339
  def incompatible_options; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#320
  def only_includes_unneeded_disable?; end

  # source://rubocop//lib/rubocop/options.rb#280
  def validate_auto_gen_config; end

  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#255
  def validate_compatibility; end

  # @raise [OptionParser::MissingArgument]
  #
  # source://rubocop//lib/rubocop/options.rb#343
  def validate_exclude_limit_option; end

  # source://rubocop//lib/rubocop/options.rb#294
  def validate_parallel; end

  # source://rubocop//lib/rubocop/options.rb#306
  def validate_parallel_with_combo_option; end

  class << self
    # Cop name validation must be done later than option parsing, so it's not
    # called from within Options.
    #
    # source://rubocop//lib/rubocop/options.rb#217
    def validate_cop_list(names); end

    private

    # source://rubocop//lib/rubocop/options.rb#234
    def format_message_from(name, cop_names); end
  end
end

# Common methods and behaviors for dealing with paths.
#
# source://rubocop//lib/rubocop/path_util.rb#5
module RuboCop::PathUtil
  private

  # Returns true for an absolute Unix or Windows path.
  #
  # source://rubocop//lib/rubocop/path_util.rb#53
  def absolute?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#79
  def hidden_dir?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#72
  def hidden_file_in_not_hidden_dir?(pattern, path); end

  # source://rubocop//lib/rubocop/path_util.rb#36
  def match_path?(pattern, path); end

  # source://rubocop//lib/rubocop/path_util.rb#8
  def relative_path(path, base_dir = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/path_util.rb#25
  def smart_path(path); end

  class << self
    # Returns true for an absolute Unix or Windows path.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#53
    def absolute?(path); end

    # source://rubocop//lib/rubocop/path_util.rb#65
    def chdir(dir, &block); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#79
    def hidden_dir?(path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#72
    def hidden_file_in_not_hidden_dir?(pattern, path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#36
    def match_path?(pattern, path); end

    # source://rubocop//lib/rubocop/path_util.rb#57
    def pwd; end

    # source://rubocop//lib/rubocop/path_util.rb#8
    def relative_path(path, base_dir = T.unsafe(nil)); end

    # source://rubocop//lib/rubocop/path_util.rb#61
    def reset_pwd; end

    # source://rubocop//lib/rubocop/path_util.rb#25
    def smart_path(path); end
  end
end

# This module provides information on the platform that RuboCop is being run
# on.
#
# source://rubocop//lib/rubocop/platform.rb#6
module RuboCop::Platform
  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/platform.rb#7
    def windows?; end
  end
end

# ProcessedSource contains objects which are generated by Parser
# and other information such as disabled lines for cops.
# It also provides a convenient way to access source lines.
#
# source://rubocop//lib/rubocop/processed_source.rb#9
class RuboCop::ProcessedSource
  # @return [ProcessedSource] a new instance of ProcessedSource
  #
  # source://rubocop//lib/rubocop/processed_source.rb#22
  def initialize(source, ruby_version, path = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/processed_source.rb#69
  def [](*args); end

  # Returns the value of attribute ast.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def ast; end

  # source://rubocop//lib/rubocop/processed_source.rb#47
  def ast_with_comments; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/processed_source.rb#104
  def blank?; end

  # Returns the value of attribute buffer.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def buffer; end

  # Raw source checksum for tracking infinite loops.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#80
  def checksum; end

  # source://rubocop//lib/rubocop/processed_source.rb#39
  def comment_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/processed_source.rb#108
  def commented?(source_range); end

  # Returns the value of attribute comments.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def comments; end

  # source://rubocop//lib/rubocop/processed_source.rb#112
  def comments_before_line(line); end

  # Returns the value of attribute diagnostics.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def diagnostics; end

  # source://rubocop//lib/rubocop/processed_source.rb#43
  def disabled_line_ranges; end

  # source://rubocop//lib/rubocop/processed_source.rb#84
  def each_comment; end

  # source://rubocop//lib/rubocop/processed_source.rb#92
  def each_token; end

  # source://rubocop//lib/rubocop/processed_source.rb#100
  def file_path; end

  # source://rubocop//lib/rubocop/processed_source.rb#88
  def find_comment; end

  # source://rubocop//lib/rubocop/processed_source.rb#96
  def find_token; end

  # source://rubocop//lib/rubocop/processed_source.rb#126
  def following_line(token); end

  # source://rubocop//lib/rubocop/processed_source.rb#130
  def line_indentation(line_number); end

  # Returns the source lines, line break characters removed, excluding a
  # possible __END__ and everything that comes after.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#55
  def lines; end

  # Returns the value of attribute parser_error.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def parser_error; end

  # Returns the value of attribute path.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def path; end

  # source://rubocop//lib/rubocop/processed_source.rb#122
  def preceding_line(token); end

  # Returns the value of attribute raw_source.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def raw_source; end

  # Returns the value of attribute ruby_version.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def ruby_version; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/processed_source.rb#116
  def start_with?(string); end

  # Returns the value of attribute tokens.
  #
  # source://rubocop//lib/rubocop/processed_source.rb#12
  def tokens; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/processed_source.rb#73
  def valid_syntax?; end

  private

  # source://rubocop//lib/rubocop/processed_source.rb#139
  def comment_lines; end

  # source://rubocop//lib/rubocop/processed_source.rb#194
  def create_parser(ruby_version); end

  # source://rubocop//lib/rubocop/processed_source.rb#143
  def parse(source, ruby_version); end

  # source://rubocop//lib/rubocop/processed_source.rb#171
  def parser_class(ruby_version); end

  # source://rubocop//lib/rubocop/processed_source.rb#157
  def tokenize(parser); end

  class << self
    # source://rubocop//lib/rubocop/processed_source.rb#15
    def from_file(path, ruby_version); end
  end
end

# source://rubocop//lib/rubocop/processed_source.rb#10
RuboCop::ProcessedSource::STRING_SOURCE_NAME = T.let(T.unsafe(nil), String)

# Common methods and behaviors for dealing with remote config files.
#
# source://rubocop//lib/rubocop/remote_config.rb#8
class RuboCop::RemoteConfig
  # @return [RemoteConfig] a new instance of RemoteConfig
  #
  # source://rubocop//lib/rubocop/remote_config.rb#13
  def initialize(url, base_dir); end

  # source://rubocop//lib/rubocop/remote_config.rb#18
  def file; end

  # source://rubocop//lib/rubocop/remote_config.rb#33
  def inherit_from_remote(file, path); end

  # Returns the value of attribute uri.
  #
  # source://rubocop//lib/rubocop/remote_config.rb#9
  def uri; end

  private

  # source://rubocop//lib/rubocop/remote_config.rb#98
  def cache_name_from_uri; end

  # source://rubocop//lib/rubocop/remote_config.rb#81
  def cache_path; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#85
  def cache_path_exists?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#89
  def cache_path_expired?; end

  # @yield [request]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#56
  def generate_request(uri); end

  # source://rubocop//lib/rubocop/remote_config.rb#66
  def handle_response(response, limit, &block); end

  # @raise [ArgumentError]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#41
  def request(uri = T.unsafe(nil), limit = T.unsafe(nil), &block); end
end

# source://rubocop//lib/rubocop/remote_config.rb#11
RuboCop::RemoteConfig::CACHE_LIFETIME = T.let(T.unsafe(nil), Integer)

# Provides functionality for caching rubocop runs.
#
# source://rubocop//lib/rubocop/result_cache.rb#9
class RuboCop::ResultCache
  # @return [ResultCache] a new instance of ResultCache
  #
  # source://rubocop//lib/rubocop/result_cache.rb#80
  def initialize(file, options, config_store, cache_root = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/result_cache.rb#94
  def load; end

  # source://rubocop//lib/rubocop/result_cache.rb#98
  def save(offenses); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#90
  def valid?; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#132
  def any_symlink?(path); end

  # source://rubocop//lib/rubocop/result_cache.rb#143
  def file_checksum(file, config_store); end

  # Return a hash of the options given at invocation, minus the ones that have
  # no effect on which offenses and disabled line ranges are found, and thus
  # don't affect caching.
  #
  # source://rubocop//lib/rubocop/result_cache.rb#183
  def relevant_options_digest(options); end

  # The checksum of the rubocop program running the inspection.
  #
  # source://rubocop//lib/rubocop/result_cache.rb#162
  def rubocop_checksum; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#128
  def symlink_protection_triggered?(path); end

  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/result_cache.rb#76
    def allow_symlinks_in_cache_location?(config_store); end

    # source://rubocop//lib/rubocop/result_cache.rb#64
    def cache_root(config_store); end

    # Remove old files so that the cache doesn't grow too big. When the
    # threshold MaxFilesInCache has been exceeded, the oldest 50% of all the
    # files in the cache are removed. The reason for removing so much is that
    # cleaning should be done relatively seldom, since there is a slight risk
    # that some other RuboCop process was just about to read the file, when
    # there's parallel execution and the cache is shared.
    #
    # source://rubocop//lib/rubocop/result_cache.rb#19
    def cleanup(config_store, verbose, cache_root = T.unsafe(nil)); end

    # Returns the value of attribute inhibit_cleanup.
    #
    # source://rubocop//lib/rubocop/result_cache.rb#158
    def inhibit_cleanup; end

    # Sets the attribute inhibit_cleanup
    #
    # @param value the value to set the attribute inhibit_cleanup to.
    #
    # source://rubocop//lib/rubocop/result_cache.rb#158
    def inhibit_cleanup=(_arg0); end

    # Returns the value of attribute source_checksum.
    #
    # source://rubocop//lib/rubocop/result_cache.rb#158
    def source_checksum; end

    # Sets the attribute source_checksum
    #
    # @param value the value to set the attribute source_checksum to.
    #
    # source://rubocop//lib/rubocop/result_cache.rb#158
    def source_checksum=(_arg0); end

    private

    # source://rubocop//lib/rubocop/result_cache.rb#54
    def remove_files(files, dirs, remove_count); end

    # source://rubocop//lib/rubocop/result_cache.rb#39
    def remove_oldest_files(files, dirs, cache_root, verbose); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/result_cache.rb#34
    def requires_file_removal?(file_count, config_store); end
  end
end

# source://rubocop//lib/rubocop/result_cache.rb#10
RuboCop::ResultCache::NON_CHANGING = T.let(T.unsafe(nil), Array)

# This class handles the processing of files, which includes dealing with
# formatters and letting cops inspect the files.
#
# source://rubocop//lib/rubocop/runner.rb#8
class RuboCop::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://rubocop//lib/rubocop/runner.rb#25
  def initialize(options, config_store); end

  # Sets the attribute aborting
  #
  # @param value the value to set the attribute aborting to.
  #
  # source://rubocop//lib/rubocop/runner.rb#23
  def aborting=(_arg0); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#49
  def aborting?; end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/runner.rb#22
  def errors; end

  # source://rubocop//lib/rubocop/runner.rb#33
  def run(paths); end

  # Returns the value of attribute warnings.
  #
  # source://rubocop//lib/rubocop/runner.rb#22
  def warnings; end

  private

  # source://rubocop//lib/rubocop/runner.rb#144
  def add_unneeded_disables(file, offenses, source); end

  # source://rubocop//lib/rubocop/runner.rb#170
  def autocorrect_unneeded_disables(source, cop); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#186
  def cached_run?; end

  # Check whether a run created source identical to a previous run, which
  # means that we definitely have an infinite loop.
  #
  # source://rubocop//lib/rubocop/runner.rb#259
  def check_for_infinite_loop(processed_source, offenses); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#162
  def check_for_unneeded_disables?(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#327
  def considered_failure?(offense); end

  # source://rubocop//lib/rubocop/runner.rb#209
  def do_inspection_loop(file, processed_source); end

  # source://rubocop//lib/rubocop/runner.rb#80
  def each_inspected_file(files); end

  # source://rubocop//lib/rubocop/runner.rb#279
  def enable_rails_cops(config); end

  # source://rubocop//lib/rubocop/runner.rb#124
  def file_offense_cache(file); end

  # source://rubocop//lib/rubocop/runner.rb#116
  def file_offenses(file); end

  # source://rubocop//lib/rubocop/runner.rb#180
  def file_started(file); end

  # source://rubocop//lib/rubocop/runner.rb#305
  def filter_cop_classes(cop_classes, config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#166
  def filtered_run?; end

  # source://rubocop//lib/rubocop/runner.rb#62
  def find_target_files(paths); end

  # source://rubocop//lib/rubocop/runner.rb#316
  def formatter_set; end

  # source://rubocop//lib/rubocop/runner.rb#343
  def get_processed_source(file); end

  # source://rubocop//lib/rubocop/runner.rb#269
  def inspect_file(processed_source); end

  # source://rubocop//lib/rubocop/runner.rb#68
  def inspect_files(files); end

  # source://rubocop//lib/rubocop/runner.rb#234
  def iterate_until_no_changes(source, offenses); end

  # source://rubocop//lib/rubocop/runner.rb#95
  def list_files(paths); end

  # source://rubocop//lib/rubocop/runner.rb#336
  def minimum_severity_to_fail; end

  # source://rubocop//lib/rubocop/runner.rb#284
  def mobilized_cop_classes(config); end

  # source://rubocop//lib/rubocop/runner.rb#101
  def process_file(file); end

  # source://rubocop//lib/rubocop/runner.rb#199
  def save_in_cache(cache, offenses); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#312
  def style_guide_cops_only?(config); end

  # Warms up the RuboCop cache by forking a suitable number of rubocop
  # instances that each inspects its allotted group of files.
  #
  # source://rubocop//lib/rubocop/runner.rb#57
  def warm_cache(target_files); end
end

# An exception indicating that the inspection loop got stuck correcting
# offenses back and forth.
#
# source://rubocop//lib/rubocop/runner.rb#11
class RuboCop::Runner::InfiniteCorrectionLoop < ::RuntimeError
  # @return [InfiniteCorrectionLoop] a new instance of InfiniteCorrectionLoop
  #
  # source://rubocop//lib/rubocop/runner.rb#14
  def initialize(path, offenses); end

  # Returns the value of attribute offenses.
  #
  # source://rubocop//lib/rubocop/runner.rb#12
  def offenses; end
end

# source://rubocop//lib/rubocop/runner.rb#20
RuboCop::Runner::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)

# Take a string with embedded escapes, and convert the escapes as the Ruby
# interpreter would when reading a double-quoted string literal.
# For example, "\\n" will be converted to "\n".
#
# source://rubocop//lib/rubocop/string_interpreter.rb#7
class RuboCop::StringInterpreter
  class << self
    # source://rubocop//lib/rubocop/string_interpreter.rb#21
    def interpret(string); end

    private

    # source://rubocop//lib/rubocop/string_interpreter.rb#48
    def interpret_hex(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#52
    def interpret_octal(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#30
    def interpret_string_escape(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#40
    def interpret_unicode(escape); end
  end
end

# source://rubocop//lib/rubocop/string_interpreter.rb#8
RuboCop::StringInterpreter::STRING_ESCAPES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/string_interpreter.rb#12
RuboCop::StringInterpreter::STRING_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# This module provides approximate string matching methods.
#
# source://rubocop//lib/rubocop/string_util.rb#7
module RuboCop::StringUtil
  private

  # source://rubocop//lib/rubocop/string_util.rb#10
  def similarity(string_a, string_b); end

  class << self
    # source://rubocop//lib/rubocop/string_util.rb#10
    def similarity(string_a, string_b); end
  end
end

# This class finds target files to inspect by scanning the directory tree
# and picking ruby files.
#
# source://rubocop//lib/rubocop/target_finder.rb#8
class RuboCop::TargetFinder
  # @return [TargetFinder] a new instance of TargetFinder
  #
  # source://rubocop//lib/rubocop/target_finder.rb#9
  def initialize(config_store, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/target_finder.rb#139
  def all_cops_include; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#166
  def configured_include?(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#18
  def debug?; end

  # source://rubocop//lib/rubocop/target_finder.rb#109
  def excluded_dirs(base_dir); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#22
  def fail_fast?; end

  # Generate a list of target files by expanding globbing patterns
  # (if any). If args is empty, recursively find all Ruby source
  # files under the current directory
  #
  # @return [Array] array of file paths
  #
  # source://rubocop//lib/rubocop/target_finder.rb#30
  def find(args); end

  # Search for files recursively starting at the given base directory using
  # the given flags that determine how the match is made. Excluded files will
  # be removed later by the caller, but as an optimization find_files removes
  # the top level directories that are excluded in configuration in the
  # normal way (dir/**/*).
  #
  # source://rubocop//lib/rubocop/target_finder.rb#86
  def find_files(base_dir, flags); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#14
  def force_exclusion?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#170
  def included_file?(file); end

  # source://rubocop//lib/rubocop/target_finder.rb#174
  def process_explicit_path(path); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#143
  def ruby_executable?(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#117
  def ruby_extension?(file); end

  # source://rubocop//lib/rubocop/target_finder.rb#121
  def ruby_extensions; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#161
  def ruby_file?(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#128
  def ruby_filename?(file); end

  # source://rubocop//lib/rubocop/target_finder.rb#132
  def ruby_filenames; end

  # source://rubocop//lib/rubocop/target_finder.rb#153
  def ruby_interpreters(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#157
  def stdin?; end

  # Finds all Ruby source files under the current or other supplied
  # directory. A Ruby source file is defined as a file with the `.rb`
  # extension or a file with no extension that has a ruby shebang line
  # as its first line.
  # It is possible to specify includes and excludes using the config file,
  # so you can include other Ruby files like Rakefiles and gemspecs.
  #
  # @param base_dir Root directory under which to search for
  #   ruby source files
  # @return [Array] Array of filenames
  #
  # source://rubocop//lib/rubocop/target_finder.rb#55
  def target_files_in_dir(base_dir = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#74
  def to_inspect?(file, hidden_files, base_dir_config); end

  # source://rubocop//lib/rubocop/target_finder.rb#103
  def toplevel_dirs(base_dir, flags); end
end

# A basic wrapper around Parser's tokens.
#
# source://rubocop//lib/rubocop/token.rb#5
class RuboCop::Token
  # @return [Token] a new instance of Token
  #
  # source://rubocop//lib/rubocop/token.rb#14
  def initialize(pos, type, text); end

  # source://rubocop//lib/rubocop/token.rb#29
  def begin_pos; end

  # source://rubocop//lib/rubocop/token.rb#25
  def column; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#98
  def comma?; end

  # Type Predicates
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#54
  def comment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#106
  def end?; end

  # source://rubocop//lib/rubocop/token.rb#33
  def end_pos; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#110
  def equal_sign?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#62
  def left_array_bracket?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#78
  def left_brace?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#70
  def left_bracket?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#82
  def left_curly_brace?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#90
  def left_parens?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#66
  def left_ref_bracket?; end

  # source://rubocop//lib/rubocop/token.rb#21
  def line; end

  # Returns the value of attribute pos.
  #
  # source://rubocop//lib/rubocop/token.rb#6
  def pos; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#102
  def rescue_modifier?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#74
  def right_bracket?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#86
  def right_curly_brace?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#94
  def right_parens?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#58
  def semicolon?; end

  # Checks if there is whitespace after token
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#42
  def space_after?; end

  # Checks if there is whitespace before token
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/token.rb#47
  def space_before?; end

  # Returns the value of attribute text.
  #
  # source://rubocop//lib/rubocop/token.rb#6
  def text; end

  # source://rubocop//lib/rubocop/token.rb#37
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://rubocop//lib/rubocop/token.rb#6
  def type; end

  class << self
    # source://rubocop//lib/rubocop/token.rb#8
    def from_parser_token(parser_token); end
  end
end

# source://rubocop//lib/rubocop/error.rb#10
class RuboCop::ValidationError < ::RuboCop::Error; end

# This module holds the RuboCop version information.
#
# source://rubocop//lib/rubocop/version.rb#5
module RuboCop::Version
  class << self
    # source://rubocop//lib/rubocop/version.rb#11
    def version(debug = T.unsafe(nil)); end
  end
end

# source://rubocop//lib/rubocop/version.rb#8
RuboCop::Version::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/version.rb#6
RuboCop::Version::STRING = T.let(T.unsafe(nil), String)

# A Warning exception is different from an Offense with severity 'warning'
# When a Warning is raised, this means that RuboCop was unable to perform a
# requested operation (such as inspecting or correcting a source file) due to
# user error
# For example, a configuration value in .rubocop.yml might be malformed
#
# source://rubocop//lib/rubocop/warning.rb#9
class RuboCop::Warning < ::StandardError; end

# Find duplicated keys from YAML.
#
# source://rubocop//lib/rubocop/yaml_duplication_checker.rb#5
module RuboCop::YAMLDuplicationChecker
  class << self
    # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#6
    def check(yaml_string, filename, &on_duplicated); end

    private

    # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#14
    def traverse(tree, &on_duplicated); end
  end
end

# Extensions to the core String class
#
# source://rubocop//lib/rubocop/core_ext/string.rb#4
class String
  include ::Comparable

  # Checks whether a string is blank. A string is considered blank if it
  # is either empty or contains only whitespace characters.
  #
  # @example
  #   ''.blank? #=> true
  # @example
  #   '    '.blank? #=> true
  # @example
  #   '  test'.blank? #=> false
  # @return [Boolean] true is the string is blank, false otherwise
  #
  # source://rubocop//lib/rubocop/core_ext/string.rb#19
  def blank?; end

  # The method strips the whitespace preceding the base indentation.
  # Useful for HEREDOCs and other multi-line strings.
  #
  # @example
  #
  #   code = <<-END.strip_indent
  #   def test
  #   some_method
  #   other_method
  #   end
  #   END
  #
  #   #=> "def\n  some_method\n  \nother_method\nend"
  # @todo Replace call sites with squiggly heredocs when required Ruby
  #   version is >= 2.3.0
  #
  # source://rubocop//lib/rubocop/core_ext/string.rb#41
  def strip_indent; end
end
